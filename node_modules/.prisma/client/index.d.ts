
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model institutions
 * 
 */
export type institutions = $Result.DefaultSelection<Prisma.$institutionsPayload>
/**
 * Model profile
 * 
 */
export type profile = $Result.DefaultSelection<Prisma.$profilePayload>
/**
 * Model roadmaps
 * 
 */
export type roadmaps = $Result.DefaultSelection<Prisma.$roadmapsPayload>
/**
 * Model checkpoints
 * 
 */
export type checkpoints = $Result.DefaultSelection<Prisma.$checkpointsPayload>
/**
 * Model studentLearningProgress
 * 
 */
export type studentLearningProgress = $Result.DefaultSelection<Prisma.$studentLearningProgressPayload>
/**
 * Model courses
 * 
 */
export type courses = $Result.DefaultSelection<Prisma.$coursesPayload>
/**
 * Model courseEnrollments
 * 
 */
export type courseEnrollments = $Result.DefaultSelection<Prisma.$courseEnrollmentsPayload>
/**
 * Model mentors
 * 
 */
export type mentors = $Result.DefaultSelection<Prisma.$mentorsPayload>
/**
 * Model mentorSessions
 * 
 */
export type mentorSessions = $Result.DefaultSelection<Prisma.$mentorSessionsPayload>
/**
 * Model mentorReviews
 * 
 */
export type mentorReviews = $Result.DefaultSelection<Prisma.$mentorReviewsPayload>
/**
 * Model portfolioProjects
 * 
 */
export type portfolioProjects = $Result.DefaultSelection<Prisma.$portfolioProjectsPayload>
/**
 * Model internships
 * 
 */
export type internships = $Result.DefaultSelection<Prisma.$internshipsPayload>
/**
 * Model internship_applications
 * 
 */
export type internship_applications = $Result.DefaultSelection<Prisma.$internship_applicationsPayload>
/**
 * Model logbook_entries
 * 
 */
export type logbook_entries = $Result.DefaultSelection<Prisma.$logbook_entriesPayload>
/**
 * Model internship_evaluation
 * 
 */
export type internship_evaluation = $Result.DefaultSelection<Prisma.$internship_evaluationPayload>
/**
 * Model faculty
 * 
 */
export type faculty = $Result.DefaultSelection<Prisma.$facultyPayload>
/**
 * Model credits
 * 
 */
export type credits = $Result.DefaultSelection<Prisma.$creditsPayload>
/**
 * Model certificates
 * 
 */
export type certificates = $Result.DefaultSelection<Prisma.$certificatesPayload>
/**
 * Model notifications
 * 
 */
export type notifications = $Result.DefaultSelection<Prisma.$notificationsPayload>
/**
 * Model user_notifications
 * 
 */
export type user_notifications = $Result.DefaultSelection<Prisma.$user_notificationsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const CourseType: {
  PAID: 'PAID',
  FREE: 'FREE',
  GOVT: 'GOVT'
};

export type CourseType = (typeof CourseType)[keyof typeof CourseType]


export const MentorSessionStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type MentorSessionStatus = (typeof MentorSessionStatus)[keyof typeof MentorSessionStatus]


export const InternshipStatus: {
  APPLIED: 'APPLIED',
  SHORTLISTED: 'SHORTLISTED',
  SELECTED: 'SELECTED',
  REJECTED: 'REJECTED'
};

export type InternshipStatus = (typeof InternshipStatus)[keyof typeof InternshipStatus]

}

export type CourseType = $Enums.CourseType

export const CourseType: typeof $Enums.CourseType

export type MentorSessionStatus = $Enums.MentorSessionStatus

export const MentorSessionStatus: typeof $Enums.MentorSessionStatus

export type InternshipStatus = $Enums.InternshipStatus

export const InternshipStatus: typeof $Enums.InternshipStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.users.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.users.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs>;

  /**
   * `prisma.institutions`: Exposes CRUD operations for the **institutions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Institutions
    * const institutions = await prisma.institutions.findMany()
    * ```
    */
  get institutions(): Prisma.institutionsDelegate<ExtArgs>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.profileDelegate<ExtArgs>;

  /**
   * `prisma.roadmaps`: Exposes CRUD operations for the **roadmaps** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roadmaps
    * const roadmaps = await prisma.roadmaps.findMany()
    * ```
    */
  get roadmaps(): Prisma.roadmapsDelegate<ExtArgs>;

  /**
   * `prisma.checkpoints`: Exposes CRUD operations for the **checkpoints** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Checkpoints
    * const checkpoints = await prisma.checkpoints.findMany()
    * ```
    */
  get checkpoints(): Prisma.checkpointsDelegate<ExtArgs>;

  /**
   * `prisma.studentLearningProgress`: Exposes CRUD operations for the **studentLearningProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentLearningProgresses
    * const studentLearningProgresses = await prisma.studentLearningProgress.findMany()
    * ```
    */
  get studentLearningProgress(): Prisma.studentLearningProgressDelegate<ExtArgs>;

  /**
   * `prisma.courses`: Exposes CRUD operations for the **courses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courses
    * const courses = await prisma.courses.findMany()
    * ```
    */
  get courses(): Prisma.coursesDelegate<ExtArgs>;

  /**
   * `prisma.courseEnrollments`: Exposes CRUD operations for the **courseEnrollments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseEnrollments
    * const courseEnrollments = await prisma.courseEnrollments.findMany()
    * ```
    */
  get courseEnrollments(): Prisma.courseEnrollmentsDelegate<ExtArgs>;

  /**
   * `prisma.mentors`: Exposes CRUD operations for the **mentors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mentors
    * const mentors = await prisma.mentors.findMany()
    * ```
    */
  get mentors(): Prisma.mentorsDelegate<ExtArgs>;

  /**
   * `prisma.mentorSessions`: Exposes CRUD operations for the **mentorSessions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MentorSessions
    * const mentorSessions = await prisma.mentorSessions.findMany()
    * ```
    */
  get mentorSessions(): Prisma.mentorSessionsDelegate<ExtArgs>;

  /**
   * `prisma.mentorReviews`: Exposes CRUD operations for the **mentorReviews** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MentorReviews
    * const mentorReviews = await prisma.mentorReviews.findMany()
    * ```
    */
  get mentorReviews(): Prisma.mentorReviewsDelegate<ExtArgs>;

  /**
   * `prisma.portfolioProjects`: Exposes CRUD operations for the **portfolioProjects** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PortfolioProjects
    * const portfolioProjects = await prisma.portfolioProjects.findMany()
    * ```
    */
  get portfolioProjects(): Prisma.portfolioProjectsDelegate<ExtArgs>;

  /**
   * `prisma.internships`: Exposes CRUD operations for the **internships** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Internships
    * const internships = await prisma.internships.findMany()
    * ```
    */
  get internships(): Prisma.internshipsDelegate<ExtArgs>;

  /**
   * `prisma.internship_applications`: Exposes CRUD operations for the **internship_applications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Internship_applications
    * const internship_applications = await prisma.internship_applications.findMany()
    * ```
    */
  get internship_applications(): Prisma.internship_applicationsDelegate<ExtArgs>;

  /**
   * `prisma.logbook_entries`: Exposes CRUD operations for the **logbook_entries** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Logbook_entries
    * const logbook_entries = await prisma.logbook_entries.findMany()
    * ```
    */
  get logbook_entries(): Prisma.logbook_entriesDelegate<ExtArgs>;

  /**
   * `prisma.internship_evaluation`: Exposes CRUD operations for the **internship_evaluation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Internship_evaluations
    * const internship_evaluations = await prisma.internship_evaluation.findMany()
    * ```
    */
  get internship_evaluation(): Prisma.internship_evaluationDelegate<ExtArgs>;

  /**
   * `prisma.faculty`: Exposes CRUD operations for the **faculty** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Faculties
    * const faculties = await prisma.faculty.findMany()
    * ```
    */
  get faculty(): Prisma.facultyDelegate<ExtArgs>;

  /**
   * `prisma.credits`: Exposes CRUD operations for the **credits** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Credits
    * const credits = await prisma.credits.findMany()
    * ```
    */
  get credits(): Prisma.creditsDelegate<ExtArgs>;

  /**
   * `prisma.certificates`: Exposes CRUD operations for the **certificates** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Certificates
    * const certificates = await prisma.certificates.findMany()
    * ```
    */
  get certificates(): Prisma.certificatesDelegate<ExtArgs>;

  /**
   * `prisma.notifications`: Exposes CRUD operations for the **notifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notifications.findMany()
    * ```
    */
  get notifications(): Prisma.notificationsDelegate<ExtArgs>;

  /**
   * `prisma.user_notifications`: Exposes CRUD operations for the **user_notifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_notifications
    * const user_notifications = await prisma.user_notifications.findMany()
    * ```
    */
  get user_notifications(): Prisma.user_notificationsDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    users: 'users',
    institutions: 'institutions',
    profile: 'profile',
    roadmaps: 'roadmaps',
    checkpoints: 'checkpoints',
    studentLearningProgress: 'studentLearningProgress',
    courses: 'courses',
    courseEnrollments: 'courseEnrollments',
    mentors: 'mentors',
    mentorSessions: 'mentorSessions',
    mentorReviews: 'mentorReviews',
    portfolioProjects: 'portfolioProjects',
    internships: 'internships',
    internship_applications: 'internship_applications',
    logbook_entries: 'logbook_entries',
    internship_evaluation: 'internship_evaluation',
    faculty: 'faculty',
    credits: 'credits',
    certificates: 'certificates',
    notifications: 'notifications',
    user_notifications: 'user_notifications'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "users" | "institutions" | "profile" | "roadmaps" | "checkpoints" | "studentLearningProgress" | "courses" | "courseEnrollments" | "mentors" | "mentorSessions" | "mentorReviews" | "portfolioProjects" | "internships" | "internship_applications" | "logbook_entries" | "internship_evaluation" | "faculty" | "credits" | "certificates" | "notifications" | "user_notifications"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      institutions: {
        payload: Prisma.$institutionsPayload<ExtArgs>
        fields: Prisma.institutionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.institutionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$institutionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.institutionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$institutionsPayload>
          }
          findFirst: {
            args: Prisma.institutionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$institutionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.institutionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$institutionsPayload>
          }
          findMany: {
            args: Prisma.institutionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$institutionsPayload>[]
          }
          create: {
            args: Prisma.institutionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$institutionsPayload>
          }
          createMany: {
            args: Prisma.institutionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.institutionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$institutionsPayload>[]
          }
          delete: {
            args: Prisma.institutionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$institutionsPayload>
          }
          update: {
            args: Prisma.institutionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$institutionsPayload>
          }
          deleteMany: {
            args: Prisma.institutionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.institutionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.institutionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$institutionsPayload>
          }
          aggregate: {
            args: Prisma.InstitutionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstitutions>
          }
          groupBy: {
            args: Prisma.institutionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstitutionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.institutionsCountArgs<ExtArgs>
            result: $Utils.Optional<InstitutionsCountAggregateOutputType> | number
          }
        }
      }
      profile: {
        payload: Prisma.$profilePayload<ExtArgs>
        fields: Prisma.profileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.profileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.profileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilePayload>
          }
          findFirst: {
            args: Prisma.profileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.profileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilePayload>
          }
          findMany: {
            args: Prisma.profileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilePayload>[]
          }
          create: {
            args: Prisma.profileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilePayload>
          }
          createMany: {
            args: Prisma.profileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.profileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilePayload>[]
          }
          delete: {
            args: Prisma.profileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilePayload>
          }
          update: {
            args: Prisma.profileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilePayload>
          }
          deleteMany: {
            args: Prisma.profileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.profileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.profileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$profilePayload>
          }
          aggregate: {
            args: Prisma.ProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfile>
          }
          groupBy: {
            args: Prisma.profileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.profileCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileCountAggregateOutputType> | number
          }
        }
      }
      roadmaps: {
        payload: Prisma.$roadmapsPayload<ExtArgs>
        fields: Prisma.roadmapsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.roadmapsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roadmapsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.roadmapsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roadmapsPayload>
          }
          findFirst: {
            args: Prisma.roadmapsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roadmapsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.roadmapsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roadmapsPayload>
          }
          findMany: {
            args: Prisma.roadmapsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roadmapsPayload>[]
          }
          create: {
            args: Prisma.roadmapsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roadmapsPayload>
          }
          createMany: {
            args: Prisma.roadmapsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.roadmapsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roadmapsPayload>[]
          }
          delete: {
            args: Prisma.roadmapsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roadmapsPayload>
          }
          update: {
            args: Prisma.roadmapsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roadmapsPayload>
          }
          deleteMany: {
            args: Prisma.roadmapsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.roadmapsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.roadmapsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$roadmapsPayload>
          }
          aggregate: {
            args: Prisma.RoadmapsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoadmaps>
          }
          groupBy: {
            args: Prisma.roadmapsGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoadmapsGroupByOutputType>[]
          }
          count: {
            args: Prisma.roadmapsCountArgs<ExtArgs>
            result: $Utils.Optional<RoadmapsCountAggregateOutputType> | number
          }
        }
      }
      checkpoints: {
        payload: Prisma.$checkpointsPayload<ExtArgs>
        fields: Prisma.checkpointsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.checkpointsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checkpointsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.checkpointsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checkpointsPayload>
          }
          findFirst: {
            args: Prisma.checkpointsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checkpointsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.checkpointsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checkpointsPayload>
          }
          findMany: {
            args: Prisma.checkpointsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checkpointsPayload>[]
          }
          create: {
            args: Prisma.checkpointsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checkpointsPayload>
          }
          createMany: {
            args: Prisma.checkpointsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.checkpointsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checkpointsPayload>[]
          }
          delete: {
            args: Prisma.checkpointsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checkpointsPayload>
          }
          update: {
            args: Prisma.checkpointsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checkpointsPayload>
          }
          deleteMany: {
            args: Prisma.checkpointsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.checkpointsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.checkpointsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checkpointsPayload>
          }
          aggregate: {
            args: Prisma.CheckpointsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCheckpoints>
          }
          groupBy: {
            args: Prisma.checkpointsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CheckpointsGroupByOutputType>[]
          }
          count: {
            args: Prisma.checkpointsCountArgs<ExtArgs>
            result: $Utils.Optional<CheckpointsCountAggregateOutputType> | number
          }
        }
      }
      studentLearningProgress: {
        payload: Prisma.$studentLearningProgressPayload<ExtArgs>
        fields: Prisma.studentLearningProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.studentLearningProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentLearningProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.studentLearningProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentLearningProgressPayload>
          }
          findFirst: {
            args: Prisma.studentLearningProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentLearningProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.studentLearningProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentLearningProgressPayload>
          }
          findMany: {
            args: Prisma.studentLearningProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentLearningProgressPayload>[]
          }
          create: {
            args: Prisma.studentLearningProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentLearningProgressPayload>
          }
          createMany: {
            args: Prisma.studentLearningProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.studentLearningProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentLearningProgressPayload>[]
          }
          delete: {
            args: Prisma.studentLearningProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentLearningProgressPayload>
          }
          update: {
            args: Prisma.studentLearningProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentLearningProgressPayload>
          }
          deleteMany: {
            args: Prisma.studentLearningProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.studentLearningProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.studentLearningProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentLearningProgressPayload>
          }
          aggregate: {
            args: Prisma.StudentLearningProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentLearningProgress>
          }
          groupBy: {
            args: Prisma.studentLearningProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentLearningProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.studentLearningProgressCountArgs<ExtArgs>
            result: $Utils.Optional<StudentLearningProgressCountAggregateOutputType> | number
          }
        }
      }
      courses: {
        payload: Prisma.$coursesPayload<ExtArgs>
        fields: Prisma.coursesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.coursesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.coursesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursesPayload>
          }
          findFirst: {
            args: Prisma.coursesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.coursesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursesPayload>
          }
          findMany: {
            args: Prisma.coursesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursesPayload>[]
          }
          create: {
            args: Prisma.coursesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursesPayload>
          }
          createMany: {
            args: Prisma.coursesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.coursesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursesPayload>[]
          }
          delete: {
            args: Prisma.coursesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursesPayload>
          }
          update: {
            args: Prisma.coursesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursesPayload>
          }
          deleteMany: {
            args: Prisma.coursesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.coursesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.coursesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursesPayload>
          }
          aggregate: {
            args: Prisma.CoursesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourses>
          }
          groupBy: {
            args: Prisma.coursesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CoursesGroupByOutputType>[]
          }
          count: {
            args: Prisma.coursesCountArgs<ExtArgs>
            result: $Utils.Optional<CoursesCountAggregateOutputType> | number
          }
        }
      }
      courseEnrollments: {
        payload: Prisma.$courseEnrollmentsPayload<ExtArgs>
        fields: Prisma.courseEnrollmentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.courseEnrollmentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$courseEnrollmentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.courseEnrollmentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$courseEnrollmentsPayload>
          }
          findFirst: {
            args: Prisma.courseEnrollmentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$courseEnrollmentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.courseEnrollmentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$courseEnrollmentsPayload>
          }
          findMany: {
            args: Prisma.courseEnrollmentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$courseEnrollmentsPayload>[]
          }
          create: {
            args: Prisma.courseEnrollmentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$courseEnrollmentsPayload>
          }
          createMany: {
            args: Prisma.courseEnrollmentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.courseEnrollmentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$courseEnrollmentsPayload>[]
          }
          delete: {
            args: Prisma.courseEnrollmentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$courseEnrollmentsPayload>
          }
          update: {
            args: Prisma.courseEnrollmentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$courseEnrollmentsPayload>
          }
          deleteMany: {
            args: Prisma.courseEnrollmentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.courseEnrollmentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.courseEnrollmentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$courseEnrollmentsPayload>
          }
          aggregate: {
            args: Prisma.CourseEnrollmentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseEnrollments>
          }
          groupBy: {
            args: Prisma.courseEnrollmentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseEnrollmentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.courseEnrollmentsCountArgs<ExtArgs>
            result: $Utils.Optional<CourseEnrollmentsCountAggregateOutputType> | number
          }
        }
      }
      mentors: {
        payload: Prisma.$mentorsPayload<ExtArgs>
        fields: Prisma.mentorsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.mentorsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mentorsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.mentorsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mentorsPayload>
          }
          findFirst: {
            args: Prisma.mentorsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mentorsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.mentorsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mentorsPayload>
          }
          findMany: {
            args: Prisma.mentorsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mentorsPayload>[]
          }
          create: {
            args: Prisma.mentorsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mentorsPayload>
          }
          createMany: {
            args: Prisma.mentorsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.mentorsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mentorsPayload>[]
          }
          delete: {
            args: Prisma.mentorsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mentorsPayload>
          }
          update: {
            args: Prisma.mentorsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mentorsPayload>
          }
          deleteMany: {
            args: Prisma.mentorsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.mentorsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.mentorsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mentorsPayload>
          }
          aggregate: {
            args: Prisma.MentorsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMentors>
          }
          groupBy: {
            args: Prisma.mentorsGroupByArgs<ExtArgs>
            result: $Utils.Optional<MentorsGroupByOutputType>[]
          }
          count: {
            args: Prisma.mentorsCountArgs<ExtArgs>
            result: $Utils.Optional<MentorsCountAggregateOutputType> | number
          }
        }
      }
      mentorSessions: {
        payload: Prisma.$mentorSessionsPayload<ExtArgs>
        fields: Prisma.mentorSessionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.mentorSessionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mentorSessionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.mentorSessionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mentorSessionsPayload>
          }
          findFirst: {
            args: Prisma.mentorSessionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mentorSessionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.mentorSessionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mentorSessionsPayload>
          }
          findMany: {
            args: Prisma.mentorSessionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mentorSessionsPayload>[]
          }
          create: {
            args: Prisma.mentorSessionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mentorSessionsPayload>
          }
          createMany: {
            args: Prisma.mentorSessionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.mentorSessionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mentorSessionsPayload>[]
          }
          delete: {
            args: Prisma.mentorSessionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mentorSessionsPayload>
          }
          update: {
            args: Prisma.mentorSessionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mentorSessionsPayload>
          }
          deleteMany: {
            args: Prisma.mentorSessionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.mentorSessionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.mentorSessionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mentorSessionsPayload>
          }
          aggregate: {
            args: Prisma.MentorSessionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMentorSessions>
          }
          groupBy: {
            args: Prisma.mentorSessionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<MentorSessionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.mentorSessionsCountArgs<ExtArgs>
            result: $Utils.Optional<MentorSessionsCountAggregateOutputType> | number
          }
        }
      }
      mentorReviews: {
        payload: Prisma.$mentorReviewsPayload<ExtArgs>
        fields: Prisma.mentorReviewsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.mentorReviewsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mentorReviewsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.mentorReviewsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mentorReviewsPayload>
          }
          findFirst: {
            args: Prisma.mentorReviewsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mentorReviewsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.mentorReviewsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mentorReviewsPayload>
          }
          findMany: {
            args: Prisma.mentorReviewsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mentorReviewsPayload>[]
          }
          create: {
            args: Prisma.mentorReviewsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mentorReviewsPayload>
          }
          createMany: {
            args: Prisma.mentorReviewsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.mentorReviewsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mentorReviewsPayload>[]
          }
          delete: {
            args: Prisma.mentorReviewsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mentorReviewsPayload>
          }
          update: {
            args: Prisma.mentorReviewsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mentorReviewsPayload>
          }
          deleteMany: {
            args: Prisma.mentorReviewsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.mentorReviewsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.mentorReviewsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mentorReviewsPayload>
          }
          aggregate: {
            args: Prisma.MentorReviewsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMentorReviews>
          }
          groupBy: {
            args: Prisma.mentorReviewsGroupByArgs<ExtArgs>
            result: $Utils.Optional<MentorReviewsGroupByOutputType>[]
          }
          count: {
            args: Prisma.mentorReviewsCountArgs<ExtArgs>
            result: $Utils.Optional<MentorReviewsCountAggregateOutputType> | number
          }
        }
      }
      portfolioProjects: {
        payload: Prisma.$portfolioProjectsPayload<ExtArgs>
        fields: Prisma.portfolioProjectsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.portfolioProjectsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$portfolioProjectsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.portfolioProjectsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$portfolioProjectsPayload>
          }
          findFirst: {
            args: Prisma.portfolioProjectsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$portfolioProjectsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.portfolioProjectsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$portfolioProjectsPayload>
          }
          findMany: {
            args: Prisma.portfolioProjectsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$portfolioProjectsPayload>[]
          }
          create: {
            args: Prisma.portfolioProjectsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$portfolioProjectsPayload>
          }
          createMany: {
            args: Prisma.portfolioProjectsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.portfolioProjectsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$portfolioProjectsPayload>[]
          }
          delete: {
            args: Prisma.portfolioProjectsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$portfolioProjectsPayload>
          }
          update: {
            args: Prisma.portfolioProjectsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$portfolioProjectsPayload>
          }
          deleteMany: {
            args: Prisma.portfolioProjectsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.portfolioProjectsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.portfolioProjectsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$portfolioProjectsPayload>
          }
          aggregate: {
            args: Prisma.PortfolioProjectsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePortfolioProjects>
          }
          groupBy: {
            args: Prisma.portfolioProjectsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PortfolioProjectsGroupByOutputType>[]
          }
          count: {
            args: Prisma.portfolioProjectsCountArgs<ExtArgs>
            result: $Utils.Optional<PortfolioProjectsCountAggregateOutputType> | number
          }
        }
      }
      internships: {
        payload: Prisma.$internshipsPayload<ExtArgs>
        fields: Prisma.internshipsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.internshipsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$internshipsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.internshipsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$internshipsPayload>
          }
          findFirst: {
            args: Prisma.internshipsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$internshipsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.internshipsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$internshipsPayload>
          }
          findMany: {
            args: Prisma.internshipsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$internshipsPayload>[]
          }
          create: {
            args: Prisma.internshipsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$internshipsPayload>
          }
          createMany: {
            args: Prisma.internshipsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.internshipsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$internshipsPayload>[]
          }
          delete: {
            args: Prisma.internshipsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$internshipsPayload>
          }
          update: {
            args: Prisma.internshipsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$internshipsPayload>
          }
          deleteMany: {
            args: Prisma.internshipsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.internshipsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.internshipsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$internshipsPayload>
          }
          aggregate: {
            args: Prisma.InternshipsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInternships>
          }
          groupBy: {
            args: Prisma.internshipsGroupByArgs<ExtArgs>
            result: $Utils.Optional<InternshipsGroupByOutputType>[]
          }
          count: {
            args: Prisma.internshipsCountArgs<ExtArgs>
            result: $Utils.Optional<InternshipsCountAggregateOutputType> | number
          }
        }
      }
      internship_applications: {
        payload: Prisma.$internship_applicationsPayload<ExtArgs>
        fields: Prisma.internship_applicationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.internship_applicationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$internship_applicationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.internship_applicationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$internship_applicationsPayload>
          }
          findFirst: {
            args: Prisma.internship_applicationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$internship_applicationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.internship_applicationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$internship_applicationsPayload>
          }
          findMany: {
            args: Prisma.internship_applicationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$internship_applicationsPayload>[]
          }
          create: {
            args: Prisma.internship_applicationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$internship_applicationsPayload>
          }
          createMany: {
            args: Prisma.internship_applicationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.internship_applicationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$internship_applicationsPayload>[]
          }
          delete: {
            args: Prisma.internship_applicationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$internship_applicationsPayload>
          }
          update: {
            args: Prisma.internship_applicationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$internship_applicationsPayload>
          }
          deleteMany: {
            args: Prisma.internship_applicationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.internship_applicationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.internship_applicationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$internship_applicationsPayload>
          }
          aggregate: {
            args: Prisma.Internship_applicationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInternship_applications>
          }
          groupBy: {
            args: Prisma.internship_applicationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Internship_applicationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.internship_applicationsCountArgs<ExtArgs>
            result: $Utils.Optional<Internship_applicationsCountAggregateOutputType> | number
          }
        }
      }
      logbook_entries: {
        payload: Prisma.$logbook_entriesPayload<ExtArgs>
        fields: Prisma.logbook_entriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.logbook_entriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logbook_entriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.logbook_entriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logbook_entriesPayload>
          }
          findFirst: {
            args: Prisma.logbook_entriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logbook_entriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.logbook_entriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logbook_entriesPayload>
          }
          findMany: {
            args: Prisma.logbook_entriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logbook_entriesPayload>[]
          }
          create: {
            args: Prisma.logbook_entriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logbook_entriesPayload>
          }
          createMany: {
            args: Prisma.logbook_entriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.logbook_entriesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logbook_entriesPayload>[]
          }
          delete: {
            args: Prisma.logbook_entriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logbook_entriesPayload>
          }
          update: {
            args: Prisma.logbook_entriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logbook_entriesPayload>
          }
          deleteMany: {
            args: Prisma.logbook_entriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.logbook_entriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.logbook_entriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logbook_entriesPayload>
          }
          aggregate: {
            args: Prisma.Logbook_entriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLogbook_entries>
          }
          groupBy: {
            args: Prisma.logbook_entriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Logbook_entriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.logbook_entriesCountArgs<ExtArgs>
            result: $Utils.Optional<Logbook_entriesCountAggregateOutputType> | number
          }
        }
      }
      internship_evaluation: {
        payload: Prisma.$internship_evaluationPayload<ExtArgs>
        fields: Prisma.internship_evaluationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.internship_evaluationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$internship_evaluationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.internship_evaluationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$internship_evaluationPayload>
          }
          findFirst: {
            args: Prisma.internship_evaluationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$internship_evaluationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.internship_evaluationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$internship_evaluationPayload>
          }
          findMany: {
            args: Prisma.internship_evaluationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$internship_evaluationPayload>[]
          }
          create: {
            args: Prisma.internship_evaluationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$internship_evaluationPayload>
          }
          createMany: {
            args: Prisma.internship_evaluationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.internship_evaluationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$internship_evaluationPayload>[]
          }
          delete: {
            args: Prisma.internship_evaluationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$internship_evaluationPayload>
          }
          update: {
            args: Prisma.internship_evaluationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$internship_evaluationPayload>
          }
          deleteMany: {
            args: Prisma.internship_evaluationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.internship_evaluationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.internship_evaluationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$internship_evaluationPayload>
          }
          aggregate: {
            args: Prisma.Internship_evaluationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInternship_evaluation>
          }
          groupBy: {
            args: Prisma.internship_evaluationGroupByArgs<ExtArgs>
            result: $Utils.Optional<Internship_evaluationGroupByOutputType>[]
          }
          count: {
            args: Prisma.internship_evaluationCountArgs<ExtArgs>
            result: $Utils.Optional<Internship_evaluationCountAggregateOutputType> | number
          }
        }
      }
      faculty: {
        payload: Prisma.$facultyPayload<ExtArgs>
        fields: Prisma.facultyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.facultyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$facultyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.facultyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$facultyPayload>
          }
          findFirst: {
            args: Prisma.facultyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$facultyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.facultyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$facultyPayload>
          }
          findMany: {
            args: Prisma.facultyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$facultyPayload>[]
          }
          create: {
            args: Prisma.facultyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$facultyPayload>
          }
          createMany: {
            args: Prisma.facultyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.facultyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$facultyPayload>[]
          }
          delete: {
            args: Prisma.facultyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$facultyPayload>
          }
          update: {
            args: Prisma.facultyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$facultyPayload>
          }
          deleteMany: {
            args: Prisma.facultyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.facultyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.facultyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$facultyPayload>
          }
          aggregate: {
            args: Prisma.FacultyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFaculty>
          }
          groupBy: {
            args: Prisma.facultyGroupByArgs<ExtArgs>
            result: $Utils.Optional<FacultyGroupByOutputType>[]
          }
          count: {
            args: Prisma.facultyCountArgs<ExtArgs>
            result: $Utils.Optional<FacultyCountAggregateOutputType> | number
          }
        }
      }
      credits: {
        payload: Prisma.$creditsPayload<ExtArgs>
        fields: Prisma.creditsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.creditsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$creditsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.creditsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$creditsPayload>
          }
          findFirst: {
            args: Prisma.creditsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$creditsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.creditsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$creditsPayload>
          }
          findMany: {
            args: Prisma.creditsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$creditsPayload>[]
          }
          create: {
            args: Prisma.creditsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$creditsPayload>
          }
          createMany: {
            args: Prisma.creditsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.creditsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$creditsPayload>[]
          }
          delete: {
            args: Prisma.creditsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$creditsPayload>
          }
          update: {
            args: Prisma.creditsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$creditsPayload>
          }
          deleteMany: {
            args: Prisma.creditsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.creditsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.creditsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$creditsPayload>
          }
          aggregate: {
            args: Prisma.CreditsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCredits>
          }
          groupBy: {
            args: Prisma.creditsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreditsGroupByOutputType>[]
          }
          count: {
            args: Prisma.creditsCountArgs<ExtArgs>
            result: $Utils.Optional<CreditsCountAggregateOutputType> | number
          }
        }
      }
      certificates: {
        payload: Prisma.$certificatesPayload<ExtArgs>
        fields: Prisma.certificatesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.certificatesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificatesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.certificatesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificatesPayload>
          }
          findFirst: {
            args: Prisma.certificatesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificatesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.certificatesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificatesPayload>
          }
          findMany: {
            args: Prisma.certificatesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificatesPayload>[]
          }
          create: {
            args: Prisma.certificatesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificatesPayload>
          }
          createMany: {
            args: Prisma.certificatesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.certificatesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificatesPayload>[]
          }
          delete: {
            args: Prisma.certificatesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificatesPayload>
          }
          update: {
            args: Prisma.certificatesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificatesPayload>
          }
          deleteMany: {
            args: Prisma.certificatesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.certificatesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.certificatesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificatesPayload>
          }
          aggregate: {
            args: Prisma.CertificatesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCertificates>
          }
          groupBy: {
            args: Prisma.certificatesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CertificatesGroupByOutputType>[]
          }
          count: {
            args: Prisma.certificatesCountArgs<ExtArgs>
            result: $Utils.Optional<CertificatesCountAggregateOutputType> | number
          }
        }
      }
      notifications: {
        payload: Prisma.$notificationsPayload<ExtArgs>
        fields: Prisma.notificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notificationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notificationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          findFirst: {
            args: Prisma.notificationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notificationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          findMany: {
            args: Prisma.notificationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>[]
          }
          create: {
            args: Prisma.notificationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          createMany: {
            args: Prisma.notificationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.notificationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>[]
          }
          delete: {
            args: Prisma.notificationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          update: {
            args: Prisma.notificationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          deleteMany: {
            args: Prisma.notificationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.notificationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.notificationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          aggregate: {
            args: Prisma.NotificationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotifications>
          }
          groupBy: {
            args: Prisma.notificationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.notificationsCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationsCountAggregateOutputType> | number
          }
        }
      }
      user_notifications: {
        payload: Prisma.$user_notificationsPayload<ExtArgs>
        fields: Prisma.user_notificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_notificationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_notificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_notificationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_notificationsPayload>
          }
          findFirst: {
            args: Prisma.user_notificationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_notificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_notificationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_notificationsPayload>
          }
          findMany: {
            args: Prisma.user_notificationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_notificationsPayload>[]
          }
          create: {
            args: Prisma.user_notificationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_notificationsPayload>
          }
          createMany: {
            args: Prisma.user_notificationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.user_notificationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_notificationsPayload>[]
          }
          delete: {
            args: Prisma.user_notificationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_notificationsPayload>
          }
          update: {
            args: Prisma.user_notificationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_notificationsPayload>
          }
          deleteMany: {
            args: Prisma.user_notificationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_notificationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.user_notificationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_notificationsPayload>
          }
          aggregate: {
            args: Prisma.User_notificationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_notifications>
          }
          groupBy: {
            args: Prisma.user_notificationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_notificationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_notificationsCountArgs<ExtArgs>
            result: $Utils.Optional<User_notificationsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    courseEnrollments: number
    courses_instructor: number
    institutions_admin: number
    internships_industryUser: number
    user_notifications: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courseEnrollments?: boolean | UsersCountOutputTypeCountCourseEnrollmentsArgs
    courses_instructor?: boolean | UsersCountOutputTypeCountCourses_instructorArgs
    institutions_admin?: boolean | UsersCountOutputTypeCountInstitutions_adminArgs
    internships_industryUser?: boolean | UsersCountOutputTypeCountInternships_industryUserArgs
    user_notifications?: boolean | UsersCountOutputTypeCountUser_notificationsArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountCourseEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: courseEnrollmentsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountCourses_instructorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: coursesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountInstitutions_adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: institutionsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountInternships_industryUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: internshipsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUser_notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_notificationsWhereInput
  }


  /**
   * Count Type InstitutionsCountOutputType
   */

  export type InstitutionsCountOutputType = {
    faculty: number
    profiles: number
  }

  export type InstitutionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    faculty?: boolean | InstitutionsCountOutputTypeCountFacultyArgs
    profiles?: boolean | InstitutionsCountOutputTypeCountProfilesArgs
  }

  // Custom InputTypes
  /**
   * InstitutionsCountOutputType without action
   */
  export type InstitutionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstitutionsCountOutputType
     */
    select?: InstitutionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InstitutionsCountOutputType without action
   */
  export type InstitutionsCountOutputTypeCountFacultyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: facultyWhereInput
  }

  /**
   * InstitutionsCountOutputType without action
   */
  export type InstitutionsCountOutputTypeCountProfilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: profileWhereInput
  }


  /**
   * Count Type ProfileCountOutputType
   */

  export type ProfileCountOutputType = {
    certificates: number
    credits: number
    internshipApplications: number
    mentorReviews: number
    mentorSessions: number
    portfolioProjects: number
    learningProgress: number
  }

  export type ProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    certificates?: boolean | ProfileCountOutputTypeCountCertificatesArgs
    credits?: boolean | ProfileCountOutputTypeCountCreditsArgs
    internshipApplications?: boolean | ProfileCountOutputTypeCountInternshipApplicationsArgs
    mentorReviews?: boolean | ProfileCountOutputTypeCountMentorReviewsArgs
    mentorSessions?: boolean | ProfileCountOutputTypeCountMentorSessionsArgs
    portfolioProjects?: boolean | ProfileCountOutputTypeCountPortfolioProjectsArgs
    learningProgress?: boolean | ProfileCountOutputTypeCountLearningProgressArgs
  }

  // Custom InputTypes
  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileCountOutputType
     */
    select?: ProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountCertificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: certificatesWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountCreditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: creditsWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountInternshipApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: internship_applicationsWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountMentorReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mentorReviewsWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountMentorSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mentorSessionsWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountPortfolioProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: portfolioProjectsWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountLearningProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: studentLearningProgressWhereInput
  }


  /**
   * Count Type RoadmapsCountOutputType
   */

  export type RoadmapsCountOutputType = {
    checkpoints: number
  }

  export type RoadmapsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    checkpoints?: boolean | RoadmapsCountOutputTypeCountCheckpointsArgs
  }

  // Custom InputTypes
  /**
   * RoadmapsCountOutputType without action
   */
  export type RoadmapsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapsCountOutputType
     */
    select?: RoadmapsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoadmapsCountOutputType without action
   */
  export type RoadmapsCountOutputTypeCountCheckpointsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: checkpointsWhereInput
  }


  /**
   * Count Type CheckpointsCountOutputType
   */

  export type CheckpointsCountOutputType = {
    progress: number
  }

  export type CheckpointsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    progress?: boolean | CheckpointsCountOutputTypeCountProgressArgs
  }

  // Custom InputTypes
  /**
   * CheckpointsCountOutputType without action
   */
  export type CheckpointsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckpointsCountOutputType
     */
    select?: CheckpointsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CheckpointsCountOutputType without action
   */
  export type CheckpointsCountOutputTypeCountProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: studentLearningProgressWhereInput
  }


  /**
   * Count Type CoursesCountOutputType
   */

  export type CoursesCountOutputType = {
    enrollments: number
  }

  export type CoursesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enrollments?: boolean | CoursesCountOutputTypeCountEnrollmentsArgs
  }

  // Custom InputTypes
  /**
   * CoursesCountOutputType without action
   */
  export type CoursesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoursesCountOutputType
     */
    select?: CoursesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CoursesCountOutputType without action
   */
  export type CoursesCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: courseEnrollmentsWhereInput
  }


  /**
   * Count Type MentorsCountOutputType
   */

  export type MentorsCountOutputType = {
    reviews: number
    sessions: number
  }

  export type MentorsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviews?: boolean | MentorsCountOutputTypeCountReviewsArgs
    sessions?: boolean | MentorsCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * MentorsCountOutputType without action
   */
  export type MentorsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorsCountOutputType
     */
    select?: MentorsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MentorsCountOutputType without action
   */
  export type MentorsCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mentorReviewsWhereInput
  }

  /**
   * MentorsCountOutputType without action
   */
  export type MentorsCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mentorSessionsWhereInput
  }


  /**
   * Count Type InternshipsCountOutputType
   */

  export type InternshipsCountOutputType = {
    applications: number
  }

  export type InternshipsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applications?: boolean | InternshipsCountOutputTypeCountApplicationsArgs
  }

  // Custom InputTypes
  /**
   * InternshipsCountOutputType without action
   */
  export type InternshipsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternshipsCountOutputType
     */
    select?: InternshipsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InternshipsCountOutputType without action
   */
  export type InternshipsCountOutputTypeCountApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: internship_applicationsWhereInput
  }


  /**
   * Count Type Internship_applicationsCountOutputType
   */

  export type Internship_applicationsCountOutputType = {
    evaluations: number
    logbookEntries: number
  }

  export type Internship_applicationsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluations?: boolean | Internship_applicationsCountOutputTypeCountEvaluationsArgs
    logbookEntries?: boolean | Internship_applicationsCountOutputTypeCountLogbookEntriesArgs
  }

  // Custom InputTypes
  /**
   * Internship_applicationsCountOutputType without action
   */
  export type Internship_applicationsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Internship_applicationsCountOutputType
     */
    select?: Internship_applicationsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Internship_applicationsCountOutputType without action
   */
  export type Internship_applicationsCountOutputTypeCountEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: internship_evaluationWhereInput
  }

  /**
   * Internship_applicationsCountOutputType without action
   */
  export type Internship_applicationsCountOutputTypeCountLogbookEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: logbook_entriesWhereInput
  }


  /**
   * Count Type FacultyCountOutputType
   */

  export type FacultyCountOutputType = {
    evaluations: number
    students: number
  }

  export type FacultyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluations?: boolean | FacultyCountOutputTypeCountEvaluationsArgs
    students?: boolean | FacultyCountOutputTypeCountStudentsArgs
  }

  // Custom InputTypes
  /**
   * FacultyCountOutputType without action
   */
  export type FacultyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FacultyCountOutputType
     */
    select?: FacultyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FacultyCountOutputType without action
   */
  export type FacultyCountOutputTypeCountEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: internship_evaluationWhereInput
  }

  /**
   * FacultyCountOutputType without action
   */
  export type FacultyCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: profileWhereInput
  }


  /**
   * Count Type NotificationsCountOutputType
   */

  export type NotificationsCountOutputType = {
    userNotifications: number
  }

  export type NotificationsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userNotifications?: boolean | NotificationsCountOutputTypeCountUserNotificationsArgs
  }

  // Custom InputTypes
  /**
   * NotificationsCountOutputType without action
   */
  export type NotificationsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationsCountOutputType
     */
    select?: NotificationsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NotificationsCountOutputType without action
   */
  export type NotificationsCountOutputTypeCountUserNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_notificationsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersMinAggregateOutputType = {
    id: string | null
    displayName: string | null
    email: string | null
    salt: string | null
    phone: string | null
    hashPassword: string | null
  }

  export type UsersMaxAggregateOutputType = {
    id: string | null
    displayName: string | null
    email: string | null
    salt: string | null
    phone: string | null
    hashPassword: string | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    displayName: number
    role: number
    email: number
    salt: number
    phone: number
    hashPassword: number
    _all: number
  }


  export type UsersMinAggregateInputType = {
    id?: true
    displayName?: true
    email?: true
    salt?: true
    phone?: true
    hashPassword?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    displayName?: true
    email?: true
    salt?: true
    phone?: true
    hashPassword?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    displayName?: true
    role?: true
    email?: true
    salt?: true
    phone?: true
    hashPassword?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: string
    displayName: string
    role: string[]
    email: string
    salt: string
    phone: string
    hashPassword: string
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    displayName?: boolean
    role?: boolean
    email?: boolean
    salt?: boolean
    phone?: boolean
    hashPassword?: boolean
    courseEnrollments?: boolean | users$courseEnrollmentsArgs<ExtArgs>
    courses_instructor?: boolean | users$courses_instructorArgs<ExtArgs>
    facultyProfile?: boolean | users$facultyProfileArgs<ExtArgs>
    institutions_admin?: boolean | users$institutions_adminArgs<ExtArgs>
    internships_industryUser?: boolean | users$internships_industryUserArgs<ExtArgs>
    mentors?: boolean | users$mentorsArgs<ExtArgs>
    profiles?: boolean | users$profilesArgs<ExtArgs>
    user_notifications?: boolean | users$user_notificationsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    displayName?: boolean
    role?: boolean
    email?: boolean
    salt?: boolean
    phone?: boolean
    hashPassword?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    id?: boolean
    displayName?: boolean
    role?: boolean
    email?: boolean
    salt?: boolean
    phone?: boolean
    hashPassword?: boolean
  }

  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courseEnrollments?: boolean | users$courseEnrollmentsArgs<ExtArgs>
    courses_instructor?: boolean | users$courses_instructorArgs<ExtArgs>
    facultyProfile?: boolean | users$facultyProfileArgs<ExtArgs>
    institutions_admin?: boolean | users$institutions_adminArgs<ExtArgs>
    internships_industryUser?: boolean | users$internships_industryUserArgs<ExtArgs>
    mentors?: boolean | users$mentorsArgs<ExtArgs>
    profiles?: boolean | users$profilesArgs<ExtArgs>
    user_notifications?: boolean | users$user_notificationsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type usersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      courseEnrollments: Prisma.$courseEnrollmentsPayload<ExtArgs>[]
      courses_instructor: Prisma.$coursesPayload<ExtArgs>[]
      facultyProfile: Prisma.$facultyPayload<ExtArgs> | null
      institutions_admin: Prisma.$institutionsPayload<ExtArgs>[]
      internships_industryUser: Prisma.$internshipsPayload<ExtArgs>[]
      mentors: Prisma.$mentorsPayload<ExtArgs> | null
      profiles: Prisma.$profilePayload<ExtArgs> | null
      user_notifications: Prisma.$user_notificationsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      displayName: string
      role: string[]
      email: string
      salt: string
      phone: string
      hashPassword: string
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {usersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usersCreateManyAndReturnArgs>(args?: SelectSubset<T, usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    courseEnrollments<T extends users$courseEnrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, users$courseEnrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$courseEnrollmentsPayload<ExtArgs>, T, "findMany"> | Null>
    courses_instructor<T extends users$courses_instructorArgs<ExtArgs> = {}>(args?: Subset<T, users$courses_instructorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$coursesPayload<ExtArgs>, T, "findMany"> | Null>
    facultyProfile<T extends users$facultyProfileArgs<ExtArgs> = {}>(args?: Subset<T, users$facultyProfileArgs<ExtArgs>>): Prisma__facultyClient<$Result.GetResult<Prisma.$facultyPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    institutions_admin<T extends users$institutions_adminArgs<ExtArgs> = {}>(args?: Subset<T, users$institutions_adminArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$institutionsPayload<ExtArgs>, T, "findMany"> | Null>
    internships_industryUser<T extends users$internships_industryUserArgs<ExtArgs> = {}>(args?: Subset<T, users$internships_industryUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$internshipsPayload<ExtArgs>, T, "findMany"> | Null>
    mentors<T extends users$mentorsArgs<ExtArgs> = {}>(args?: Subset<T, users$mentorsArgs<ExtArgs>>): Prisma__mentorsClient<$Result.GetResult<Prisma.$mentorsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    profiles<T extends users$profilesArgs<ExtArgs> = {}>(args?: Subset<T, users$profilesArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    user_notifications<T extends users$user_notificationsArgs<ExtArgs> = {}>(args?: Subset<T, users$user_notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_notificationsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */ 
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'String'>
    readonly displayName: FieldRef<"users", 'String'>
    readonly role: FieldRef<"users", 'String[]'>
    readonly email: FieldRef<"users", 'String'>
    readonly salt: FieldRef<"users", 'String'>
    readonly phone: FieldRef<"users", 'String'>
    readonly hashPassword: FieldRef<"users", 'String'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users createManyAndReturn
   */
  export type usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
  }

  /**
   * users.courseEnrollments
   */
  export type users$courseEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courseEnrollments
     */
    select?: courseEnrollmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: courseEnrollmentsInclude<ExtArgs> | null
    where?: courseEnrollmentsWhereInput
    orderBy?: courseEnrollmentsOrderByWithRelationInput | courseEnrollmentsOrderByWithRelationInput[]
    cursor?: courseEnrollmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseEnrollmentsScalarFieldEnum | CourseEnrollmentsScalarFieldEnum[]
  }

  /**
   * users.courses_instructor
   */
  export type users$courses_instructorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courses
     */
    select?: coursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coursesInclude<ExtArgs> | null
    where?: coursesWhereInput
    orderBy?: coursesOrderByWithRelationInput | coursesOrderByWithRelationInput[]
    cursor?: coursesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CoursesScalarFieldEnum | CoursesScalarFieldEnum[]
  }

  /**
   * users.facultyProfile
   */
  export type users$facultyProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faculty
     */
    select?: facultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facultyInclude<ExtArgs> | null
    where?: facultyWhereInput
  }

  /**
   * users.institutions_admin
   */
  export type users$institutions_adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institutions
     */
    select?: institutionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: institutionsInclude<ExtArgs> | null
    where?: institutionsWhereInput
    orderBy?: institutionsOrderByWithRelationInput | institutionsOrderByWithRelationInput[]
    cursor?: institutionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstitutionsScalarFieldEnum | InstitutionsScalarFieldEnum[]
  }

  /**
   * users.internships_industryUser
   */
  export type users$internships_industryUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internships
     */
    select?: internshipsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internshipsInclude<ExtArgs> | null
    where?: internshipsWhereInput
    orderBy?: internshipsOrderByWithRelationInput | internshipsOrderByWithRelationInput[]
    cursor?: internshipsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InternshipsScalarFieldEnum | InternshipsScalarFieldEnum[]
  }

  /**
   * users.mentors
   */
  export type users$mentorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mentors
     */
    select?: mentorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mentorsInclude<ExtArgs> | null
    where?: mentorsWhereInput
  }

  /**
   * users.profiles
   */
  export type users$profilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
    where?: profileWhereInput
  }

  /**
   * users.user_notifications
   */
  export type users$user_notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_notifications
     */
    select?: user_notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_notificationsInclude<ExtArgs> | null
    where?: user_notificationsWhereInput
    orderBy?: user_notificationsOrderByWithRelationInput | user_notificationsOrderByWithRelationInput[]
    cursor?: user_notificationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_notificationsScalarFieldEnum | User_notificationsScalarFieldEnum[]
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Model institutions
   */

  export type AggregateInstitutions = {
    _count: InstitutionsCountAggregateOutputType | null
    _min: InstitutionsMinAggregateOutputType | null
    _max: InstitutionsMaxAggregateOutputType | null
  }

  export type InstitutionsMinAggregateOutputType = {
    id: string | null
    instituteName: string | null
    state: string | null
    adminUserId: string | null
    createdAt: Date | null
  }

  export type InstitutionsMaxAggregateOutputType = {
    id: string | null
    instituteName: string | null
    state: string | null
    adminUserId: string | null
    createdAt: Date | null
  }

  export type InstitutionsCountAggregateOutputType = {
    id: number
    instituteName: number
    state: number
    adminUserId: number
    createdAt: number
    _all: number
  }


  export type InstitutionsMinAggregateInputType = {
    id?: true
    instituteName?: true
    state?: true
    adminUserId?: true
    createdAt?: true
  }

  export type InstitutionsMaxAggregateInputType = {
    id?: true
    instituteName?: true
    state?: true
    adminUserId?: true
    createdAt?: true
  }

  export type InstitutionsCountAggregateInputType = {
    id?: true
    instituteName?: true
    state?: true
    adminUserId?: true
    createdAt?: true
    _all?: true
  }

  export type InstitutionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which institutions to aggregate.
     */
    where?: institutionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of institutions to fetch.
     */
    orderBy?: institutionsOrderByWithRelationInput | institutionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: institutionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` institutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` institutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned institutions
    **/
    _count?: true | InstitutionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstitutionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstitutionsMaxAggregateInputType
  }

  export type GetInstitutionsAggregateType<T extends InstitutionsAggregateArgs> = {
        [P in keyof T & keyof AggregateInstitutions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstitutions[P]>
      : GetScalarType<T[P], AggregateInstitutions[P]>
  }




  export type institutionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: institutionsWhereInput
    orderBy?: institutionsOrderByWithAggregationInput | institutionsOrderByWithAggregationInput[]
    by: InstitutionsScalarFieldEnum[] | InstitutionsScalarFieldEnum
    having?: institutionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstitutionsCountAggregateInputType | true
    _min?: InstitutionsMinAggregateInputType
    _max?: InstitutionsMaxAggregateInputType
  }

  export type InstitutionsGroupByOutputType = {
    id: string
    instituteName: string
    state: string
    adminUserId: string
    createdAt: Date
    _count: InstitutionsCountAggregateOutputType | null
    _min: InstitutionsMinAggregateOutputType | null
    _max: InstitutionsMaxAggregateOutputType | null
  }

  type GetInstitutionsGroupByPayload<T extends institutionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstitutionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstitutionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstitutionsGroupByOutputType[P]>
            : GetScalarType<T[P], InstitutionsGroupByOutputType[P]>
        }
      >
    >


  export type institutionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instituteName?: boolean
    state?: boolean
    adminUserId?: boolean
    createdAt?: boolean
    faculty?: boolean | institutions$facultyArgs<ExtArgs>
    adminUser?: boolean | usersDefaultArgs<ExtArgs>
    profiles?: boolean | institutions$profilesArgs<ExtArgs>
    _count?: boolean | InstitutionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["institutions"]>

  export type institutionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instituteName?: boolean
    state?: boolean
    adminUserId?: boolean
    createdAt?: boolean
    adminUser?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["institutions"]>

  export type institutionsSelectScalar = {
    id?: boolean
    instituteName?: boolean
    state?: boolean
    adminUserId?: boolean
    createdAt?: boolean
  }

  export type institutionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    faculty?: boolean | institutions$facultyArgs<ExtArgs>
    adminUser?: boolean | usersDefaultArgs<ExtArgs>
    profiles?: boolean | institutions$profilesArgs<ExtArgs>
    _count?: boolean | InstitutionsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type institutionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adminUser?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $institutionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "institutions"
    objects: {
      faculty: Prisma.$facultyPayload<ExtArgs>[]
      adminUser: Prisma.$usersPayload<ExtArgs>
      profiles: Prisma.$profilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      instituteName: string
      state: string
      adminUserId: string
      createdAt: Date
    }, ExtArgs["result"]["institutions"]>
    composites: {}
  }

  type institutionsGetPayload<S extends boolean | null | undefined | institutionsDefaultArgs> = $Result.GetResult<Prisma.$institutionsPayload, S>

  type institutionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<institutionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InstitutionsCountAggregateInputType | true
    }

  export interface institutionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['institutions'], meta: { name: 'institutions' } }
    /**
     * Find zero or one Institutions that matches the filter.
     * @param {institutionsFindUniqueArgs} args - Arguments to find a Institutions
     * @example
     * // Get one Institutions
     * const institutions = await prisma.institutions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends institutionsFindUniqueArgs>(args: SelectSubset<T, institutionsFindUniqueArgs<ExtArgs>>): Prisma__institutionsClient<$Result.GetResult<Prisma.$institutionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Institutions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {institutionsFindUniqueOrThrowArgs} args - Arguments to find a Institutions
     * @example
     * // Get one Institutions
     * const institutions = await prisma.institutions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends institutionsFindUniqueOrThrowArgs>(args: SelectSubset<T, institutionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__institutionsClient<$Result.GetResult<Prisma.$institutionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Institutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {institutionsFindFirstArgs} args - Arguments to find a Institutions
     * @example
     * // Get one Institutions
     * const institutions = await prisma.institutions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends institutionsFindFirstArgs>(args?: SelectSubset<T, institutionsFindFirstArgs<ExtArgs>>): Prisma__institutionsClient<$Result.GetResult<Prisma.$institutionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Institutions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {institutionsFindFirstOrThrowArgs} args - Arguments to find a Institutions
     * @example
     * // Get one Institutions
     * const institutions = await prisma.institutions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends institutionsFindFirstOrThrowArgs>(args?: SelectSubset<T, institutionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__institutionsClient<$Result.GetResult<Prisma.$institutionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Institutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {institutionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Institutions
     * const institutions = await prisma.institutions.findMany()
     * 
     * // Get first 10 Institutions
     * const institutions = await prisma.institutions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const institutionsWithIdOnly = await prisma.institutions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends institutionsFindManyArgs>(args?: SelectSubset<T, institutionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$institutionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Institutions.
     * @param {institutionsCreateArgs} args - Arguments to create a Institutions.
     * @example
     * // Create one Institutions
     * const Institutions = await prisma.institutions.create({
     *   data: {
     *     // ... data to create a Institutions
     *   }
     * })
     * 
     */
    create<T extends institutionsCreateArgs>(args: SelectSubset<T, institutionsCreateArgs<ExtArgs>>): Prisma__institutionsClient<$Result.GetResult<Prisma.$institutionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Institutions.
     * @param {institutionsCreateManyArgs} args - Arguments to create many Institutions.
     * @example
     * // Create many Institutions
     * const institutions = await prisma.institutions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends institutionsCreateManyArgs>(args?: SelectSubset<T, institutionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Institutions and returns the data saved in the database.
     * @param {institutionsCreateManyAndReturnArgs} args - Arguments to create many Institutions.
     * @example
     * // Create many Institutions
     * const institutions = await prisma.institutions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Institutions and only return the `id`
     * const institutionsWithIdOnly = await prisma.institutions.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends institutionsCreateManyAndReturnArgs>(args?: SelectSubset<T, institutionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$institutionsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Institutions.
     * @param {institutionsDeleteArgs} args - Arguments to delete one Institutions.
     * @example
     * // Delete one Institutions
     * const Institutions = await prisma.institutions.delete({
     *   where: {
     *     // ... filter to delete one Institutions
     *   }
     * })
     * 
     */
    delete<T extends institutionsDeleteArgs>(args: SelectSubset<T, institutionsDeleteArgs<ExtArgs>>): Prisma__institutionsClient<$Result.GetResult<Prisma.$institutionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Institutions.
     * @param {institutionsUpdateArgs} args - Arguments to update one Institutions.
     * @example
     * // Update one Institutions
     * const institutions = await prisma.institutions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends institutionsUpdateArgs>(args: SelectSubset<T, institutionsUpdateArgs<ExtArgs>>): Prisma__institutionsClient<$Result.GetResult<Prisma.$institutionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Institutions.
     * @param {institutionsDeleteManyArgs} args - Arguments to filter Institutions to delete.
     * @example
     * // Delete a few Institutions
     * const { count } = await prisma.institutions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends institutionsDeleteManyArgs>(args?: SelectSubset<T, institutionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Institutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {institutionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Institutions
     * const institutions = await prisma.institutions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends institutionsUpdateManyArgs>(args: SelectSubset<T, institutionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Institutions.
     * @param {institutionsUpsertArgs} args - Arguments to update or create a Institutions.
     * @example
     * // Update or create a Institutions
     * const institutions = await prisma.institutions.upsert({
     *   create: {
     *     // ... data to create a Institutions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Institutions we want to update
     *   }
     * })
     */
    upsert<T extends institutionsUpsertArgs>(args: SelectSubset<T, institutionsUpsertArgs<ExtArgs>>): Prisma__institutionsClient<$Result.GetResult<Prisma.$institutionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Institutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {institutionsCountArgs} args - Arguments to filter Institutions to count.
     * @example
     * // Count the number of Institutions
     * const count = await prisma.institutions.count({
     *   where: {
     *     // ... the filter for the Institutions we want to count
     *   }
     * })
    **/
    count<T extends institutionsCountArgs>(
      args?: Subset<T, institutionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstitutionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Institutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstitutionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstitutionsAggregateArgs>(args: Subset<T, InstitutionsAggregateArgs>): Prisma.PrismaPromise<GetInstitutionsAggregateType<T>>

    /**
     * Group by Institutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {institutionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends institutionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: institutionsGroupByArgs['orderBy'] }
        : { orderBy?: institutionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, institutionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstitutionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the institutions model
   */
  readonly fields: institutionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for institutions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__institutionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    faculty<T extends institutions$facultyArgs<ExtArgs> = {}>(args?: Subset<T, institutions$facultyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$facultyPayload<ExtArgs>, T, "findMany"> | Null>
    adminUser<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    profiles<T extends institutions$profilesArgs<ExtArgs> = {}>(args?: Subset<T, institutions$profilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the institutions model
   */ 
  interface institutionsFieldRefs {
    readonly id: FieldRef<"institutions", 'String'>
    readonly instituteName: FieldRef<"institutions", 'String'>
    readonly state: FieldRef<"institutions", 'String'>
    readonly adminUserId: FieldRef<"institutions", 'String'>
    readonly createdAt: FieldRef<"institutions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * institutions findUnique
   */
  export type institutionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institutions
     */
    select?: institutionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: institutionsInclude<ExtArgs> | null
    /**
     * Filter, which institutions to fetch.
     */
    where: institutionsWhereUniqueInput
  }

  /**
   * institutions findUniqueOrThrow
   */
  export type institutionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institutions
     */
    select?: institutionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: institutionsInclude<ExtArgs> | null
    /**
     * Filter, which institutions to fetch.
     */
    where: institutionsWhereUniqueInput
  }

  /**
   * institutions findFirst
   */
  export type institutionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institutions
     */
    select?: institutionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: institutionsInclude<ExtArgs> | null
    /**
     * Filter, which institutions to fetch.
     */
    where?: institutionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of institutions to fetch.
     */
    orderBy?: institutionsOrderByWithRelationInput | institutionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for institutions.
     */
    cursor?: institutionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` institutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` institutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of institutions.
     */
    distinct?: InstitutionsScalarFieldEnum | InstitutionsScalarFieldEnum[]
  }

  /**
   * institutions findFirstOrThrow
   */
  export type institutionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institutions
     */
    select?: institutionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: institutionsInclude<ExtArgs> | null
    /**
     * Filter, which institutions to fetch.
     */
    where?: institutionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of institutions to fetch.
     */
    orderBy?: institutionsOrderByWithRelationInput | institutionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for institutions.
     */
    cursor?: institutionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` institutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` institutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of institutions.
     */
    distinct?: InstitutionsScalarFieldEnum | InstitutionsScalarFieldEnum[]
  }

  /**
   * institutions findMany
   */
  export type institutionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institutions
     */
    select?: institutionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: institutionsInclude<ExtArgs> | null
    /**
     * Filter, which institutions to fetch.
     */
    where?: institutionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of institutions to fetch.
     */
    orderBy?: institutionsOrderByWithRelationInput | institutionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing institutions.
     */
    cursor?: institutionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` institutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` institutions.
     */
    skip?: number
    distinct?: InstitutionsScalarFieldEnum | InstitutionsScalarFieldEnum[]
  }

  /**
   * institutions create
   */
  export type institutionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institutions
     */
    select?: institutionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: institutionsInclude<ExtArgs> | null
    /**
     * The data needed to create a institutions.
     */
    data: XOR<institutionsCreateInput, institutionsUncheckedCreateInput>
  }

  /**
   * institutions createMany
   */
  export type institutionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many institutions.
     */
    data: institutionsCreateManyInput | institutionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * institutions createManyAndReturn
   */
  export type institutionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institutions
     */
    select?: institutionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many institutions.
     */
    data: institutionsCreateManyInput | institutionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: institutionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * institutions update
   */
  export type institutionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institutions
     */
    select?: institutionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: institutionsInclude<ExtArgs> | null
    /**
     * The data needed to update a institutions.
     */
    data: XOR<institutionsUpdateInput, institutionsUncheckedUpdateInput>
    /**
     * Choose, which institutions to update.
     */
    where: institutionsWhereUniqueInput
  }

  /**
   * institutions updateMany
   */
  export type institutionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update institutions.
     */
    data: XOR<institutionsUpdateManyMutationInput, institutionsUncheckedUpdateManyInput>
    /**
     * Filter which institutions to update
     */
    where?: institutionsWhereInput
  }

  /**
   * institutions upsert
   */
  export type institutionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institutions
     */
    select?: institutionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: institutionsInclude<ExtArgs> | null
    /**
     * The filter to search for the institutions to update in case it exists.
     */
    where: institutionsWhereUniqueInput
    /**
     * In case the institutions found by the `where` argument doesn't exist, create a new institutions with this data.
     */
    create: XOR<institutionsCreateInput, institutionsUncheckedCreateInput>
    /**
     * In case the institutions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<institutionsUpdateInput, institutionsUncheckedUpdateInput>
  }

  /**
   * institutions delete
   */
  export type institutionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institutions
     */
    select?: institutionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: institutionsInclude<ExtArgs> | null
    /**
     * Filter which institutions to delete.
     */
    where: institutionsWhereUniqueInput
  }

  /**
   * institutions deleteMany
   */
  export type institutionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which institutions to delete
     */
    where?: institutionsWhereInput
  }

  /**
   * institutions.faculty
   */
  export type institutions$facultyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faculty
     */
    select?: facultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facultyInclude<ExtArgs> | null
    where?: facultyWhereInput
    orderBy?: facultyOrderByWithRelationInput | facultyOrderByWithRelationInput[]
    cursor?: facultyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FacultyScalarFieldEnum | FacultyScalarFieldEnum[]
  }

  /**
   * institutions.profiles
   */
  export type institutions$profilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
    where?: profileWhereInput
    orderBy?: profileOrderByWithRelationInput | profileOrderByWithRelationInput[]
    cursor?: profileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * institutions without action
   */
  export type institutionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the institutions
     */
    select?: institutionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: institutionsInclude<ExtArgs> | null
  }


  /**
   * Model profile
   */

  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    bio: string | null
    gender: string | null
    DOB: Date | null
    avatarURL: string | null
    github: string | null
    linkedin: string | null
    department: string | null
    resourceId: string | null
    instituteId: string | null
    facultyId: string | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    bio: string | null
    gender: string | null
    DOB: Date | null
    avatarURL: string | null
    github: string | null
    linkedin: string | null
    department: string | null
    resourceId: string | null
    instituteId: string | null
    facultyId: string | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    userId: number
    bio: number
    gender: number
    DOB: number
    avatarURL: number
    github: number
    linkedin: number
    skills: number
    interests: number
    department: number
    resourceId: number
    instituteId: number
    facultyId: number
    _all: number
  }


  export type ProfileMinAggregateInputType = {
    id?: true
    userId?: true
    bio?: true
    gender?: true
    DOB?: true
    avatarURL?: true
    github?: true
    linkedin?: true
    department?: true
    resourceId?: true
    instituteId?: true
    facultyId?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    bio?: true
    gender?: true
    DOB?: true
    avatarURL?: true
    github?: true
    linkedin?: true
    department?: true
    resourceId?: true
    instituteId?: true
    facultyId?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    userId?: true
    bio?: true
    gender?: true
    DOB?: true
    avatarURL?: true
    github?: true
    linkedin?: true
    skills?: true
    interests?: true
    department?: true
    resourceId?: true
    instituteId?: true
    facultyId?: true
    _all?: true
  }

  export type ProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which profile to aggregate.
     */
    where?: profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profiles to fetch.
     */
    orderBy?: profileOrderByWithRelationInput | profileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type profileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: profileWhereInput
    orderBy?: profileOrderByWithAggregationInput | profileOrderByWithAggregationInput[]
    by: ProfileScalarFieldEnum[] | ProfileScalarFieldEnum
    having?: profileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }

  export type ProfileGroupByOutputType = {
    id: string
    userId: string
    bio: string | null
    gender: string | null
    DOB: Date | null
    avatarURL: string | null
    github: string | null
    linkedin: string | null
    skills: string[]
    interests: string[]
    department: string | null
    resourceId: string | null
    instituteId: string
    facultyId: string | null
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends profileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type profileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bio?: boolean
    gender?: boolean
    DOB?: boolean
    avatarURL?: boolean
    github?: boolean
    linkedin?: boolean
    skills?: boolean
    interests?: boolean
    department?: boolean
    resourceId?: boolean
    instituteId?: boolean
    facultyId?: boolean
    certificates?: boolean | profile$certificatesArgs<ExtArgs>
    credits?: boolean | profile$creditsArgs<ExtArgs>
    internshipApplications?: boolean | profile$internshipApplicationsArgs<ExtArgs>
    mentorReviews?: boolean | profile$mentorReviewsArgs<ExtArgs>
    mentorSessions?: boolean | profile$mentorSessionsArgs<ExtArgs>
    portfolioProjects?: boolean | profile$portfolioProjectsArgs<ExtArgs>
    faculty?: boolean | profile$facultyArgs<ExtArgs>
    institution?: boolean | institutionsDefaultArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
    learningProgress?: boolean | profile$learningProgressArgs<ExtArgs>
    _count?: boolean | ProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type profileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bio?: boolean
    gender?: boolean
    DOB?: boolean
    avatarURL?: boolean
    github?: boolean
    linkedin?: boolean
    skills?: boolean
    interests?: boolean
    department?: boolean
    resourceId?: boolean
    instituteId?: boolean
    facultyId?: boolean
    faculty?: boolean | profile$facultyArgs<ExtArgs>
    institution?: boolean | institutionsDefaultArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type profileSelectScalar = {
    id?: boolean
    userId?: boolean
    bio?: boolean
    gender?: boolean
    DOB?: boolean
    avatarURL?: boolean
    github?: boolean
    linkedin?: boolean
    skills?: boolean
    interests?: boolean
    department?: boolean
    resourceId?: boolean
    instituteId?: boolean
    facultyId?: boolean
  }

  export type profileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    certificates?: boolean | profile$certificatesArgs<ExtArgs>
    credits?: boolean | profile$creditsArgs<ExtArgs>
    internshipApplications?: boolean | profile$internshipApplicationsArgs<ExtArgs>
    mentorReviews?: boolean | profile$mentorReviewsArgs<ExtArgs>
    mentorSessions?: boolean | profile$mentorSessionsArgs<ExtArgs>
    portfolioProjects?: boolean | profile$portfolioProjectsArgs<ExtArgs>
    faculty?: boolean | profile$facultyArgs<ExtArgs>
    institution?: boolean | institutionsDefaultArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
    learningProgress?: boolean | profile$learningProgressArgs<ExtArgs>
    _count?: boolean | ProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type profileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    faculty?: boolean | profile$facultyArgs<ExtArgs>
    institution?: boolean | institutionsDefaultArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $profilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "profile"
    objects: {
      certificates: Prisma.$certificatesPayload<ExtArgs>[]
      credits: Prisma.$creditsPayload<ExtArgs>[]
      internshipApplications: Prisma.$internship_applicationsPayload<ExtArgs>[]
      mentorReviews: Prisma.$mentorReviewsPayload<ExtArgs>[]
      mentorSessions: Prisma.$mentorSessionsPayload<ExtArgs>[]
      portfolioProjects: Prisma.$portfolioProjectsPayload<ExtArgs>[]
      faculty: Prisma.$facultyPayload<ExtArgs> | null
      institution: Prisma.$institutionsPayload<ExtArgs>
      user: Prisma.$usersPayload<ExtArgs>
      learningProgress: Prisma.$studentLearningProgressPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      bio: string | null
      gender: string | null
      DOB: Date | null
      avatarURL: string | null
      github: string | null
      linkedin: string | null
      skills: string[]
      interests: string[]
      department: string | null
      resourceId: string | null
      instituteId: string
      facultyId: string | null
    }, ExtArgs["result"]["profile"]>
    composites: {}
  }

  type profileGetPayload<S extends boolean | null | undefined | profileDefaultArgs> = $Result.GetResult<Prisma.$profilePayload, S>

  type profileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<profileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface profileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['profile'], meta: { name: 'profile' } }
    /**
     * Find zero or one Profile that matches the filter.
     * @param {profileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends profileFindUniqueArgs>(args: SelectSubset<T, profileFindUniqueArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Profile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {profileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends profileFindUniqueOrThrowArgs>(args: SelectSubset<T, profileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends profileFindFirstArgs>(args?: SelectSubset<T, profileFindFirstArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends profileFindFirstOrThrowArgs>(args?: SelectSubset<T, profileFindFirstOrThrowArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends profileFindManyArgs>(args?: SelectSubset<T, profileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Profile.
     * @param {profileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
     */
    create<T extends profileCreateArgs>(args: SelectSubset<T, profileCreateArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Profiles.
     * @param {profileCreateManyArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends profileCreateManyArgs>(args?: SelectSubset<T, profileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Profiles and returns the data saved in the database.
     * @param {profileCreateManyAndReturnArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends profileCreateManyAndReturnArgs>(args?: SelectSubset<T, profileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Profile.
     * @param {profileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
     */
    delete<T extends profileDeleteArgs>(args: SelectSubset<T, profileDeleteArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Profile.
     * @param {profileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends profileUpdateArgs>(args: SelectSubset<T, profileUpdateArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Profiles.
     * @param {profileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends profileDeleteManyArgs>(args?: SelectSubset<T, profileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends profileUpdateManyArgs>(args: SelectSubset<T, profileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Profile.
     * @param {profileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
     */
    upsert<T extends profileUpsertArgs>(args: SelectSubset<T, profileUpsertArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends profileCountArgs>(
      args?: Subset<T, profileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends profileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: profileGroupByArgs['orderBy'] }
        : { orderBy?: profileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, profileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the profile model
   */
  readonly fields: profileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__profileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    certificates<T extends profile$certificatesArgs<ExtArgs> = {}>(args?: Subset<T, profile$certificatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$certificatesPayload<ExtArgs>, T, "findMany"> | Null>
    credits<T extends profile$creditsArgs<ExtArgs> = {}>(args?: Subset<T, profile$creditsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$creditsPayload<ExtArgs>, T, "findMany"> | Null>
    internshipApplications<T extends profile$internshipApplicationsArgs<ExtArgs> = {}>(args?: Subset<T, profile$internshipApplicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$internship_applicationsPayload<ExtArgs>, T, "findMany"> | Null>
    mentorReviews<T extends profile$mentorReviewsArgs<ExtArgs> = {}>(args?: Subset<T, profile$mentorReviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mentorReviewsPayload<ExtArgs>, T, "findMany"> | Null>
    mentorSessions<T extends profile$mentorSessionsArgs<ExtArgs> = {}>(args?: Subset<T, profile$mentorSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mentorSessionsPayload<ExtArgs>, T, "findMany"> | Null>
    portfolioProjects<T extends profile$portfolioProjectsArgs<ExtArgs> = {}>(args?: Subset<T, profile$portfolioProjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$portfolioProjectsPayload<ExtArgs>, T, "findMany"> | Null>
    faculty<T extends profile$facultyArgs<ExtArgs> = {}>(args?: Subset<T, profile$facultyArgs<ExtArgs>>): Prisma__facultyClient<$Result.GetResult<Prisma.$facultyPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    institution<T extends institutionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, institutionsDefaultArgs<ExtArgs>>): Prisma__institutionsClient<$Result.GetResult<Prisma.$institutionsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    learningProgress<T extends profile$learningProgressArgs<ExtArgs> = {}>(args?: Subset<T, profile$learningProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentLearningProgressPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the profile model
   */ 
  interface profileFieldRefs {
    readonly id: FieldRef<"profile", 'String'>
    readonly userId: FieldRef<"profile", 'String'>
    readonly bio: FieldRef<"profile", 'String'>
    readonly gender: FieldRef<"profile", 'String'>
    readonly DOB: FieldRef<"profile", 'DateTime'>
    readonly avatarURL: FieldRef<"profile", 'String'>
    readonly github: FieldRef<"profile", 'String'>
    readonly linkedin: FieldRef<"profile", 'String'>
    readonly skills: FieldRef<"profile", 'String[]'>
    readonly interests: FieldRef<"profile", 'String[]'>
    readonly department: FieldRef<"profile", 'String'>
    readonly resourceId: FieldRef<"profile", 'String'>
    readonly instituteId: FieldRef<"profile", 'String'>
    readonly facultyId: FieldRef<"profile", 'String'>
  }
    

  // Custom InputTypes
  /**
   * profile findUnique
   */
  export type profileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * Filter, which profile to fetch.
     */
    where: profileWhereUniqueInput
  }

  /**
   * profile findUniqueOrThrow
   */
  export type profileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * Filter, which profile to fetch.
     */
    where: profileWhereUniqueInput
  }

  /**
   * profile findFirst
   */
  export type profileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * Filter, which profile to fetch.
     */
    where?: profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profiles to fetch.
     */
    orderBy?: profileOrderByWithRelationInput | profileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for profiles.
     */
    cursor?: profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * profile findFirstOrThrow
   */
  export type profileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * Filter, which profile to fetch.
     */
    where?: profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profiles to fetch.
     */
    orderBy?: profileOrderByWithRelationInput | profileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for profiles.
     */
    cursor?: profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * profile findMany
   */
  export type profileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * Filter, which profiles to fetch.
     */
    where?: profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profiles to fetch.
     */
    orderBy?: profileOrderByWithRelationInput | profileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing profiles.
     */
    cursor?: profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profiles.
     */
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * profile create
   */
  export type profileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * The data needed to create a profile.
     */
    data: XOR<profileCreateInput, profileUncheckedCreateInput>
  }

  /**
   * profile createMany
   */
  export type profileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many profiles.
     */
    data: profileCreateManyInput | profileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * profile createManyAndReturn
   */
  export type profileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many profiles.
     */
    data: profileCreateManyInput | profileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * profile update
   */
  export type profileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * The data needed to update a profile.
     */
    data: XOR<profileUpdateInput, profileUncheckedUpdateInput>
    /**
     * Choose, which profile to update.
     */
    where: profileWhereUniqueInput
  }

  /**
   * profile updateMany
   */
  export type profileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update profiles.
     */
    data: XOR<profileUpdateManyMutationInput, profileUncheckedUpdateManyInput>
    /**
     * Filter which profiles to update
     */
    where?: profileWhereInput
  }

  /**
   * profile upsert
   */
  export type profileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * The filter to search for the profile to update in case it exists.
     */
    where: profileWhereUniqueInput
    /**
     * In case the profile found by the `where` argument doesn't exist, create a new profile with this data.
     */
    create: XOR<profileCreateInput, profileUncheckedCreateInput>
    /**
     * In case the profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<profileUpdateInput, profileUncheckedUpdateInput>
  }

  /**
   * profile delete
   */
  export type profileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * Filter which profile to delete.
     */
    where: profileWhereUniqueInput
  }

  /**
   * profile deleteMany
   */
  export type profileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which profiles to delete
     */
    where?: profileWhereInput
  }

  /**
   * profile.certificates
   */
  export type profile$certificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificates
     */
    select?: certificatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificatesInclude<ExtArgs> | null
    where?: certificatesWhereInput
    orderBy?: certificatesOrderByWithRelationInput | certificatesOrderByWithRelationInput[]
    cursor?: certificatesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificatesScalarFieldEnum | CertificatesScalarFieldEnum[]
  }

  /**
   * profile.credits
   */
  export type profile$creditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credits
     */
    select?: creditsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: creditsInclude<ExtArgs> | null
    where?: creditsWhereInput
    orderBy?: creditsOrderByWithRelationInput | creditsOrderByWithRelationInput[]
    cursor?: creditsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreditsScalarFieldEnum | CreditsScalarFieldEnum[]
  }

  /**
   * profile.internshipApplications
   */
  export type profile$internshipApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internship_applications
     */
    select?: internship_applicationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internship_applicationsInclude<ExtArgs> | null
    where?: internship_applicationsWhereInput
    orderBy?: internship_applicationsOrderByWithRelationInput | internship_applicationsOrderByWithRelationInput[]
    cursor?: internship_applicationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Internship_applicationsScalarFieldEnum | Internship_applicationsScalarFieldEnum[]
  }

  /**
   * profile.mentorReviews
   */
  export type profile$mentorReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mentorReviews
     */
    select?: mentorReviewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mentorReviewsInclude<ExtArgs> | null
    where?: mentorReviewsWhereInput
    orderBy?: mentorReviewsOrderByWithRelationInput | mentorReviewsOrderByWithRelationInput[]
    cursor?: mentorReviewsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MentorReviewsScalarFieldEnum | MentorReviewsScalarFieldEnum[]
  }

  /**
   * profile.mentorSessions
   */
  export type profile$mentorSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mentorSessions
     */
    select?: mentorSessionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mentorSessionsInclude<ExtArgs> | null
    where?: mentorSessionsWhereInput
    orderBy?: mentorSessionsOrderByWithRelationInput | mentorSessionsOrderByWithRelationInput[]
    cursor?: mentorSessionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MentorSessionsScalarFieldEnum | MentorSessionsScalarFieldEnum[]
  }

  /**
   * profile.portfolioProjects
   */
  export type profile$portfolioProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the portfolioProjects
     */
    select?: portfolioProjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: portfolioProjectsInclude<ExtArgs> | null
    where?: portfolioProjectsWhereInput
    orderBy?: portfolioProjectsOrderByWithRelationInput | portfolioProjectsOrderByWithRelationInput[]
    cursor?: portfolioProjectsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PortfolioProjectsScalarFieldEnum | PortfolioProjectsScalarFieldEnum[]
  }

  /**
   * profile.faculty
   */
  export type profile$facultyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faculty
     */
    select?: facultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facultyInclude<ExtArgs> | null
    where?: facultyWhereInput
  }

  /**
   * profile.learningProgress
   */
  export type profile$learningProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentLearningProgress
     */
    select?: studentLearningProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentLearningProgressInclude<ExtArgs> | null
    where?: studentLearningProgressWhereInput
    orderBy?: studentLearningProgressOrderByWithRelationInput | studentLearningProgressOrderByWithRelationInput[]
    cursor?: studentLearningProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentLearningProgressScalarFieldEnum | StudentLearningProgressScalarFieldEnum[]
  }

  /**
   * profile without action
   */
  export type profileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
  }


  /**
   * Model roadmaps
   */

  export type AggregateRoadmaps = {
    _count: RoadmapsCountAggregateOutputType | null
    _min: RoadmapsMinAggregateOutputType | null
    _max: RoadmapsMaxAggregateOutputType | null
  }

  export type RoadmapsMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    domain: string | null
  }

  export type RoadmapsMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    domain: string | null
  }

  export type RoadmapsCountAggregateOutputType = {
    id: number
    title: number
    description: number
    domain: number
    _all: number
  }


  export type RoadmapsMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    domain?: true
  }

  export type RoadmapsMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    domain?: true
  }

  export type RoadmapsCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    domain?: true
    _all?: true
  }

  export type RoadmapsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roadmaps to aggregate.
     */
    where?: roadmapsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roadmaps to fetch.
     */
    orderBy?: roadmapsOrderByWithRelationInput | roadmapsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: roadmapsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roadmaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roadmaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned roadmaps
    **/
    _count?: true | RoadmapsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoadmapsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoadmapsMaxAggregateInputType
  }

  export type GetRoadmapsAggregateType<T extends RoadmapsAggregateArgs> = {
        [P in keyof T & keyof AggregateRoadmaps]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoadmaps[P]>
      : GetScalarType<T[P], AggregateRoadmaps[P]>
  }




  export type roadmapsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: roadmapsWhereInput
    orderBy?: roadmapsOrderByWithAggregationInput | roadmapsOrderByWithAggregationInput[]
    by: RoadmapsScalarFieldEnum[] | RoadmapsScalarFieldEnum
    having?: roadmapsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoadmapsCountAggregateInputType | true
    _min?: RoadmapsMinAggregateInputType
    _max?: RoadmapsMaxAggregateInputType
  }

  export type RoadmapsGroupByOutputType = {
    id: string
    title: string
    description: string
    domain: string
    _count: RoadmapsCountAggregateOutputType | null
    _min: RoadmapsMinAggregateOutputType | null
    _max: RoadmapsMaxAggregateOutputType | null
  }

  type GetRoadmapsGroupByPayload<T extends roadmapsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoadmapsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoadmapsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoadmapsGroupByOutputType[P]>
            : GetScalarType<T[P], RoadmapsGroupByOutputType[P]>
        }
      >
    >


  export type roadmapsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    domain?: boolean
    checkpoints?: boolean | roadmaps$checkpointsArgs<ExtArgs>
    _count?: boolean | RoadmapsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roadmaps"]>

  export type roadmapsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    domain?: boolean
  }, ExtArgs["result"]["roadmaps"]>

  export type roadmapsSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    domain?: boolean
  }

  export type roadmapsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    checkpoints?: boolean | roadmaps$checkpointsArgs<ExtArgs>
    _count?: boolean | RoadmapsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type roadmapsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $roadmapsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "roadmaps"
    objects: {
      checkpoints: Prisma.$checkpointsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      domain: string
    }, ExtArgs["result"]["roadmaps"]>
    composites: {}
  }

  type roadmapsGetPayload<S extends boolean | null | undefined | roadmapsDefaultArgs> = $Result.GetResult<Prisma.$roadmapsPayload, S>

  type roadmapsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<roadmapsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoadmapsCountAggregateInputType | true
    }

  export interface roadmapsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['roadmaps'], meta: { name: 'roadmaps' } }
    /**
     * Find zero or one Roadmaps that matches the filter.
     * @param {roadmapsFindUniqueArgs} args - Arguments to find a Roadmaps
     * @example
     * // Get one Roadmaps
     * const roadmaps = await prisma.roadmaps.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends roadmapsFindUniqueArgs>(args: SelectSubset<T, roadmapsFindUniqueArgs<ExtArgs>>): Prisma__roadmapsClient<$Result.GetResult<Prisma.$roadmapsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Roadmaps that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {roadmapsFindUniqueOrThrowArgs} args - Arguments to find a Roadmaps
     * @example
     * // Get one Roadmaps
     * const roadmaps = await prisma.roadmaps.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends roadmapsFindUniqueOrThrowArgs>(args: SelectSubset<T, roadmapsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__roadmapsClient<$Result.GetResult<Prisma.$roadmapsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Roadmaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roadmapsFindFirstArgs} args - Arguments to find a Roadmaps
     * @example
     * // Get one Roadmaps
     * const roadmaps = await prisma.roadmaps.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends roadmapsFindFirstArgs>(args?: SelectSubset<T, roadmapsFindFirstArgs<ExtArgs>>): Prisma__roadmapsClient<$Result.GetResult<Prisma.$roadmapsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Roadmaps that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roadmapsFindFirstOrThrowArgs} args - Arguments to find a Roadmaps
     * @example
     * // Get one Roadmaps
     * const roadmaps = await prisma.roadmaps.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends roadmapsFindFirstOrThrowArgs>(args?: SelectSubset<T, roadmapsFindFirstOrThrowArgs<ExtArgs>>): Prisma__roadmapsClient<$Result.GetResult<Prisma.$roadmapsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Roadmaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roadmapsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roadmaps
     * const roadmaps = await prisma.roadmaps.findMany()
     * 
     * // Get first 10 Roadmaps
     * const roadmaps = await prisma.roadmaps.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roadmapsWithIdOnly = await prisma.roadmaps.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends roadmapsFindManyArgs>(args?: SelectSubset<T, roadmapsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$roadmapsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Roadmaps.
     * @param {roadmapsCreateArgs} args - Arguments to create a Roadmaps.
     * @example
     * // Create one Roadmaps
     * const Roadmaps = await prisma.roadmaps.create({
     *   data: {
     *     // ... data to create a Roadmaps
     *   }
     * })
     * 
     */
    create<T extends roadmapsCreateArgs>(args: SelectSubset<T, roadmapsCreateArgs<ExtArgs>>): Prisma__roadmapsClient<$Result.GetResult<Prisma.$roadmapsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Roadmaps.
     * @param {roadmapsCreateManyArgs} args - Arguments to create many Roadmaps.
     * @example
     * // Create many Roadmaps
     * const roadmaps = await prisma.roadmaps.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends roadmapsCreateManyArgs>(args?: SelectSubset<T, roadmapsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roadmaps and returns the data saved in the database.
     * @param {roadmapsCreateManyAndReturnArgs} args - Arguments to create many Roadmaps.
     * @example
     * // Create many Roadmaps
     * const roadmaps = await prisma.roadmaps.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roadmaps and only return the `id`
     * const roadmapsWithIdOnly = await prisma.roadmaps.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends roadmapsCreateManyAndReturnArgs>(args?: SelectSubset<T, roadmapsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$roadmapsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Roadmaps.
     * @param {roadmapsDeleteArgs} args - Arguments to delete one Roadmaps.
     * @example
     * // Delete one Roadmaps
     * const Roadmaps = await prisma.roadmaps.delete({
     *   where: {
     *     // ... filter to delete one Roadmaps
     *   }
     * })
     * 
     */
    delete<T extends roadmapsDeleteArgs>(args: SelectSubset<T, roadmapsDeleteArgs<ExtArgs>>): Prisma__roadmapsClient<$Result.GetResult<Prisma.$roadmapsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Roadmaps.
     * @param {roadmapsUpdateArgs} args - Arguments to update one Roadmaps.
     * @example
     * // Update one Roadmaps
     * const roadmaps = await prisma.roadmaps.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends roadmapsUpdateArgs>(args: SelectSubset<T, roadmapsUpdateArgs<ExtArgs>>): Prisma__roadmapsClient<$Result.GetResult<Prisma.$roadmapsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Roadmaps.
     * @param {roadmapsDeleteManyArgs} args - Arguments to filter Roadmaps to delete.
     * @example
     * // Delete a few Roadmaps
     * const { count } = await prisma.roadmaps.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends roadmapsDeleteManyArgs>(args?: SelectSubset<T, roadmapsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roadmaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roadmapsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roadmaps
     * const roadmaps = await prisma.roadmaps.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends roadmapsUpdateManyArgs>(args: SelectSubset<T, roadmapsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Roadmaps.
     * @param {roadmapsUpsertArgs} args - Arguments to update or create a Roadmaps.
     * @example
     * // Update or create a Roadmaps
     * const roadmaps = await prisma.roadmaps.upsert({
     *   create: {
     *     // ... data to create a Roadmaps
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roadmaps we want to update
     *   }
     * })
     */
    upsert<T extends roadmapsUpsertArgs>(args: SelectSubset<T, roadmapsUpsertArgs<ExtArgs>>): Prisma__roadmapsClient<$Result.GetResult<Prisma.$roadmapsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Roadmaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roadmapsCountArgs} args - Arguments to filter Roadmaps to count.
     * @example
     * // Count the number of Roadmaps
     * const count = await prisma.roadmaps.count({
     *   where: {
     *     // ... the filter for the Roadmaps we want to count
     *   }
     * })
    **/
    count<T extends roadmapsCountArgs>(
      args?: Subset<T, roadmapsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoadmapsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roadmaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoadmapsAggregateArgs>(args: Subset<T, RoadmapsAggregateArgs>): Prisma.PrismaPromise<GetRoadmapsAggregateType<T>>

    /**
     * Group by Roadmaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {roadmapsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends roadmapsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: roadmapsGroupByArgs['orderBy'] }
        : { orderBy?: roadmapsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, roadmapsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoadmapsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the roadmaps model
   */
  readonly fields: roadmapsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for roadmaps.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__roadmapsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    checkpoints<T extends roadmaps$checkpointsArgs<ExtArgs> = {}>(args?: Subset<T, roadmaps$checkpointsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$checkpointsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the roadmaps model
   */ 
  interface roadmapsFieldRefs {
    readonly id: FieldRef<"roadmaps", 'String'>
    readonly title: FieldRef<"roadmaps", 'String'>
    readonly description: FieldRef<"roadmaps", 'String'>
    readonly domain: FieldRef<"roadmaps", 'String'>
  }
    

  // Custom InputTypes
  /**
   * roadmaps findUnique
   */
  export type roadmapsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roadmaps
     */
    select?: roadmapsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roadmapsInclude<ExtArgs> | null
    /**
     * Filter, which roadmaps to fetch.
     */
    where: roadmapsWhereUniqueInput
  }

  /**
   * roadmaps findUniqueOrThrow
   */
  export type roadmapsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roadmaps
     */
    select?: roadmapsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roadmapsInclude<ExtArgs> | null
    /**
     * Filter, which roadmaps to fetch.
     */
    where: roadmapsWhereUniqueInput
  }

  /**
   * roadmaps findFirst
   */
  export type roadmapsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roadmaps
     */
    select?: roadmapsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roadmapsInclude<ExtArgs> | null
    /**
     * Filter, which roadmaps to fetch.
     */
    where?: roadmapsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roadmaps to fetch.
     */
    orderBy?: roadmapsOrderByWithRelationInput | roadmapsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roadmaps.
     */
    cursor?: roadmapsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roadmaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roadmaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roadmaps.
     */
    distinct?: RoadmapsScalarFieldEnum | RoadmapsScalarFieldEnum[]
  }

  /**
   * roadmaps findFirstOrThrow
   */
  export type roadmapsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roadmaps
     */
    select?: roadmapsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roadmapsInclude<ExtArgs> | null
    /**
     * Filter, which roadmaps to fetch.
     */
    where?: roadmapsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roadmaps to fetch.
     */
    orderBy?: roadmapsOrderByWithRelationInput | roadmapsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roadmaps.
     */
    cursor?: roadmapsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roadmaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roadmaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roadmaps.
     */
    distinct?: RoadmapsScalarFieldEnum | RoadmapsScalarFieldEnum[]
  }

  /**
   * roadmaps findMany
   */
  export type roadmapsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roadmaps
     */
    select?: roadmapsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roadmapsInclude<ExtArgs> | null
    /**
     * Filter, which roadmaps to fetch.
     */
    where?: roadmapsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roadmaps to fetch.
     */
    orderBy?: roadmapsOrderByWithRelationInput | roadmapsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing roadmaps.
     */
    cursor?: roadmapsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roadmaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roadmaps.
     */
    skip?: number
    distinct?: RoadmapsScalarFieldEnum | RoadmapsScalarFieldEnum[]
  }

  /**
   * roadmaps create
   */
  export type roadmapsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roadmaps
     */
    select?: roadmapsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roadmapsInclude<ExtArgs> | null
    /**
     * The data needed to create a roadmaps.
     */
    data: XOR<roadmapsCreateInput, roadmapsUncheckedCreateInput>
  }

  /**
   * roadmaps createMany
   */
  export type roadmapsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many roadmaps.
     */
    data: roadmapsCreateManyInput | roadmapsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * roadmaps createManyAndReturn
   */
  export type roadmapsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roadmaps
     */
    select?: roadmapsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many roadmaps.
     */
    data: roadmapsCreateManyInput | roadmapsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * roadmaps update
   */
  export type roadmapsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roadmaps
     */
    select?: roadmapsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roadmapsInclude<ExtArgs> | null
    /**
     * The data needed to update a roadmaps.
     */
    data: XOR<roadmapsUpdateInput, roadmapsUncheckedUpdateInput>
    /**
     * Choose, which roadmaps to update.
     */
    where: roadmapsWhereUniqueInput
  }

  /**
   * roadmaps updateMany
   */
  export type roadmapsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update roadmaps.
     */
    data: XOR<roadmapsUpdateManyMutationInput, roadmapsUncheckedUpdateManyInput>
    /**
     * Filter which roadmaps to update
     */
    where?: roadmapsWhereInput
  }

  /**
   * roadmaps upsert
   */
  export type roadmapsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roadmaps
     */
    select?: roadmapsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roadmapsInclude<ExtArgs> | null
    /**
     * The filter to search for the roadmaps to update in case it exists.
     */
    where: roadmapsWhereUniqueInput
    /**
     * In case the roadmaps found by the `where` argument doesn't exist, create a new roadmaps with this data.
     */
    create: XOR<roadmapsCreateInput, roadmapsUncheckedCreateInput>
    /**
     * In case the roadmaps was found with the provided `where` argument, update it with this data.
     */
    update: XOR<roadmapsUpdateInput, roadmapsUncheckedUpdateInput>
  }

  /**
   * roadmaps delete
   */
  export type roadmapsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roadmaps
     */
    select?: roadmapsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roadmapsInclude<ExtArgs> | null
    /**
     * Filter which roadmaps to delete.
     */
    where: roadmapsWhereUniqueInput
  }

  /**
   * roadmaps deleteMany
   */
  export type roadmapsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roadmaps to delete
     */
    where?: roadmapsWhereInput
  }

  /**
   * roadmaps.checkpoints
   */
  export type roadmaps$checkpointsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkpoints
     */
    select?: checkpointsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: checkpointsInclude<ExtArgs> | null
    where?: checkpointsWhereInput
    orderBy?: checkpointsOrderByWithRelationInput | checkpointsOrderByWithRelationInput[]
    cursor?: checkpointsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CheckpointsScalarFieldEnum | CheckpointsScalarFieldEnum[]
  }

  /**
   * roadmaps without action
   */
  export type roadmapsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roadmaps
     */
    select?: roadmapsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: roadmapsInclude<ExtArgs> | null
  }


  /**
   * Model checkpoints
   */

  export type AggregateCheckpoints = {
    _count: CheckpointsCountAggregateOutputType | null
    _min: CheckpointsMinAggregateOutputType | null
    _max: CheckpointsMaxAggregateOutputType | null
  }

  export type CheckpointsMinAggregateOutputType = {
    id: string | null
    roadmapId: string | null
    title: string | null
    description: string | null
    resourceType: string | null
    resourceUrl: string | null
  }

  export type CheckpointsMaxAggregateOutputType = {
    id: string | null
    roadmapId: string | null
    title: string | null
    description: string | null
    resourceType: string | null
    resourceUrl: string | null
  }

  export type CheckpointsCountAggregateOutputType = {
    id: number
    roadmapId: number
    title: number
    description: number
    resourceType: number
    resourceUrl: number
    _all: number
  }


  export type CheckpointsMinAggregateInputType = {
    id?: true
    roadmapId?: true
    title?: true
    description?: true
    resourceType?: true
    resourceUrl?: true
  }

  export type CheckpointsMaxAggregateInputType = {
    id?: true
    roadmapId?: true
    title?: true
    description?: true
    resourceType?: true
    resourceUrl?: true
  }

  export type CheckpointsCountAggregateInputType = {
    id?: true
    roadmapId?: true
    title?: true
    description?: true
    resourceType?: true
    resourceUrl?: true
    _all?: true
  }

  export type CheckpointsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which checkpoints to aggregate.
     */
    where?: checkpointsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of checkpoints to fetch.
     */
    orderBy?: checkpointsOrderByWithRelationInput | checkpointsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: checkpointsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` checkpoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` checkpoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned checkpoints
    **/
    _count?: true | CheckpointsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CheckpointsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CheckpointsMaxAggregateInputType
  }

  export type GetCheckpointsAggregateType<T extends CheckpointsAggregateArgs> = {
        [P in keyof T & keyof AggregateCheckpoints]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCheckpoints[P]>
      : GetScalarType<T[P], AggregateCheckpoints[P]>
  }




  export type checkpointsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: checkpointsWhereInput
    orderBy?: checkpointsOrderByWithAggregationInput | checkpointsOrderByWithAggregationInput[]
    by: CheckpointsScalarFieldEnum[] | CheckpointsScalarFieldEnum
    having?: checkpointsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CheckpointsCountAggregateInputType | true
    _min?: CheckpointsMinAggregateInputType
    _max?: CheckpointsMaxAggregateInputType
  }

  export type CheckpointsGroupByOutputType = {
    id: string
    roadmapId: string
    title: string
    description: string
    resourceType: string
    resourceUrl: string
    _count: CheckpointsCountAggregateOutputType | null
    _min: CheckpointsMinAggregateOutputType | null
    _max: CheckpointsMaxAggregateOutputType | null
  }

  type GetCheckpointsGroupByPayload<T extends checkpointsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CheckpointsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CheckpointsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CheckpointsGroupByOutputType[P]>
            : GetScalarType<T[P], CheckpointsGroupByOutputType[P]>
        }
      >
    >


  export type checkpointsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roadmapId?: boolean
    title?: boolean
    description?: boolean
    resourceType?: boolean
    resourceUrl?: boolean
    roadmap?: boolean | roadmapsDefaultArgs<ExtArgs>
    progress?: boolean | checkpoints$progressArgs<ExtArgs>
    _count?: boolean | CheckpointsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["checkpoints"]>

  export type checkpointsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roadmapId?: boolean
    title?: boolean
    description?: boolean
    resourceType?: boolean
    resourceUrl?: boolean
    roadmap?: boolean | roadmapsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["checkpoints"]>

  export type checkpointsSelectScalar = {
    id?: boolean
    roadmapId?: boolean
    title?: boolean
    description?: boolean
    resourceType?: boolean
    resourceUrl?: boolean
  }

  export type checkpointsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roadmap?: boolean | roadmapsDefaultArgs<ExtArgs>
    progress?: boolean | checkpoints$progressArgs<ExtArgs>
    _count?: boolean | CheckpointsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type checkpointsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roadmap?: boolean | roadmapsDefaultArgs<ExtArgs>
  }

  export type $checkpointsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "checkpoints"
    objects: {
      roadmap: Prisma.$roadmapsPayload<ExtArgs>
      progress: Prisma.$studentLearningProgressPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roadmapId: string
      title: string
      description: string
      resourceType: string
      resourceUrl: string
    }, ExtArgs["result"]["checkpoints"]>
    composites: {}
  }

  type checkpointsGetPayload<S extends boolean | null | undefined | checkpointsDefaultArgs> = $Result.GetResult<Prisma.$checkpointsPayload, S>

  type checkpointsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<checkpointsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CheckpointsCountAggregateInputType | true
    }

  export interface checkpointsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['checkpoints'], meta: { name: 'checkpoints' } }
    /**
     * Find zero or one Checkpoints that matches the filter.
     * @param {checkpointsFindUniqueArgs} args - Arguments to find a Checkpoints
     * @example
     * // Get one Checkpoints
     * const checkpoints = await prisma.checkpoints.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends checkpointsFindUniqueArgs>(args: SelectSubset<T, checkpointsFindUniqueArgs<ExtArgs>>): Prisma__checkpointsClient<$Result.GetResult<Prisma.$checkpointsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Checkpoints that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {checkpointsFindUniqueOrThrowArgs} args - Arguments to find a Checkpoints
     * @example
     * // Get one Checkpoints
     * const checkpoints = await prisma.checkpoints.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends checkpointsFindUniqueOrThrowArgs>(args: SelectSubset<T, checkpointsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__checkpointsClient<$Result.GetResult<Prisma.$checkpointsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Checkpoints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {checkpointsFindFirstArgs} args - Arguments to find a Checkpoints
     * @example
     * // Get one Checkpoints
     * const checkpoints = await prisma.checkpoints.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends checkpointsFindFirstArgs>(args?: SelectSubset<T, checkpointsFindFirstArgs<ExtArgs>>): Prisma__checkpointsClient<$Result.GetResult<Prisma.$checkpointsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Checkpoints that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {checkpointsFindFirstOrThrowArgs} args - Arguments to find a Checkpoints
     * @example
     * // Get one Checkpoints
     * const checkpoints = await prisma.checkpoints.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends checkpointsFindFirstOrThrowArgs>(args?: SelectSubset<T, checkpointsFindFirstOrThrowArgs<ExtArgs>>): Prisma__checkpointsClient<$Result.GetResult<Prisma.$checkpointsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Checkpoints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {checkpointsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Checkpoints
     * const checkpoints = await prisma.checkpoints.findMany()
     * 
     * // Get first 10 Checkpoints
     * const checkpoints = await prisma.checkpoints.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const checkpointsWithIdOnly = await prisma.checkpoints.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends checkpointsFindManyArgs>(args?: SelectSubset<T, checkpointsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$checkpointsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Checkpoints.
     * @param {checkpointsCreateArgs} args - Arguments to create a Checkpoints.
     * @example
     * // Create one Checkpoints
     * const Checkpoints = await prisma.checkpoints.create({
     *   data: {
     *     // ... data to create a Checkpoints
     *   }
     * })
     * 
     */
    create<T extends checkpointsCreateArgs>(args: SelectSubset<T, checkpointsCreateArgs<ExtArgs>>): Prisma__checkpointsClient<$Result.GetResult<Prisma.$checkpointsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Checkpoints.
     * @param {checkpointsCreateManyArgs} args - Arguments to create many Checkpoints.
     * @example
     * // Create many Checkpoints
     * const checkpoints = await prisma.checkpoints.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends checkpointsCreateManyArgs>(args?: SelectSubset<T, checkpointsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Checkpoints and returns the data saved in the database.
     * @param {checkpointsCreateManyAndReturnArgs} args - Arguments to create many Checkpoints.
     * @example
     * // Create many Checkpoints
     * const checkpoints = await prisma.checkpoints.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Checkpoints and only return the `id`
     * const checkpointsWithIdOnly = await prisma.checkpoints.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends checkpointsCreateManyAndReturnArgs>(args?: SelectSubset<T, checkpointsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$checkpointsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Checkpoints.
     * @param {checkpointsDeleteArgs} args - Arguments to delete one Checkpoints.
     * @example
     * // Delete one Checkpoints
     * const Checkpoints = await prisma.checkpoints.delete({
     *   where: {
     *     // ... filter to delete one Checkpoints
     *   }
     * })
     * 
     */
    delete<T extends checkpointsDeleteArgs>(args: SelectSubset<T, checkpointsDeleteArgs<ExtArgs>>): Prisma__checkpointsClient<$Result.GetResult<Prisma.$checkpointsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Checkpoints.
     * @param {checkpointsUpdateArgs} args - Arguments to update one Checkpoints.
     * @example
     * // Update one Checkpoints
     * const checkpoints = await prisma.checkpoints.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends checkpointsUpdateArgs>(args: SelectSubset<T, checkpointsUpdateArgs<ExtArgs>>): Prisma__checkpointsClient<$Result.GetResult<Prisma.$checkpointsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Checkpoints.
     * @param {checkpointsDeleteManyArgs} args - Arguments to filter Checkpoints to delete.
     * @example
     * // Delete a few Checkpoints
     * const { count } = await prisma.checkpoints.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends checkpointsDeleteManyArgs>(args?: SelectSubset<T, checkpointsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Checkpoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {checkpointsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Checkpoints
     * const checkpoints = await prisma.checkpoints.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends checkpointsUpdateManyArgs>(args: SelectSubset<T, checkpointsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Checkpoints.
     * @param {checkpointsUpsertArgs} args - Arguments to update or create a Checkpoints.
     * @example
     * // Update or create a Checkpoints
     * const checkpoints = await prisma.checkpoints.upsert({
     *   create: {
     *     // ... data to create a Checkpoints
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Checkpoints we want to update
     *   }
     * })
     */
    upsert<T extends checkpointsUpsertArgs>(args: SelectSubset<T, checkpointsUpsertArgs<ExtArgs>>): Prisma__checkpointsClient<$Result.GetResult<Prisma.$checkpointsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Checkpoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {checkpointsCountArgs} args - Arguments to filter Checkpoints to count.
     * @example
     * // Count the number of Checkpoints
     * const count = await prisma.checkpoints.count({
     *   where: {
     *     // ... the filter for the Checkpoints we want to count
     *   }
     * })
    **/
    count<T extends checkpointsCountArgs>(
      args?: Subset<T, checkpointsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CheckpointsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Checkpoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckpointsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CheckpointsAggregateArgs>(args: Subset<T, CheckpointsAggregateArgs>): Prisma.PrismaPromise<GetCheckpointsAggregateType<T>>

    /**
     * Group by Checkpoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {checkpointsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends checkpointsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: checkpointsGroupByArgs['orderBy'] }
        : { orderBy?: checkpointsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, checkpointsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCheckpointsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the checkpoints model
   */
  readonly fields: checkpointsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for checkpoints.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__checkpointsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roadmap<T extends roadmapsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, roadmapsDefaultArgs<ExtArgs>>): Prisma__roadmapsClient<$Result.GetResult<Prisma.$roadmapsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    progress<T extends checkpoints$progressArgs<ExtArgs> = {}>(args?: Subset<T, checkpoints$progressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentLearningProgressPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the checkpoints model
   */ 
  interface checkpointsFieldRefs {
    readonly id: FieldRef<"checkpoints", 'String'>
    readonly roadmapId: FieldRef<"checkpoints", 'String'>
    readonly title: FieldRef<"checkpoints", 'String'>
    readonly description: FieldRef<"checkpoints", 'String'>
    readonly resourceType: FieldRef<"checkpoints", 'String'>
    readonly resourceUrl: FieldRef<"checkpoints", 'String'>
  }
    

  // Custom InputTypes
  /**
   * checkpoints findUnique
   */
  export type checkpointsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkpoints
     */
    select?: checkpointsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: checkpointsInclude<ExtArgs> | null
    /**
     * Filter, which checkpoints to fetch.
     */
    where: checkpointsWhereUniqueInput
  }

  /**
   * checkpoints findUniqueOrThrow
   */
  export type checkpointsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkpoints
     */
    select?: checkpointsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: checkpointsInclude<ExtArgs> | null
    /**
     * Filter, which checkpoints to fetch.
     */
    where: checkpointsWhereUniqueInput
  }

  /**
   * checkpoints findFirst
   */
  export type checkpointsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkpoints
     */
    select?: checkpointsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: checkpointsInclude<ExtArgs> | null
    /**
     * Filter, which checkpoints to fetch.
     */
    where?: checkpointsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of checkpoints to fetch.
     */
    orderBy?: checkpointsOrderByWithRelationInput | checkpointsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for checkpoints.
     */
    cursor?: checkpointsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` checkpoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` checkpoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of checkpoints.
     */
    distinct?: CheckpointsScalarFieldEnum | CheckpointsScalarFieldEnum[]
  }

  /**
   * checkpoints findFirstOrThrow
   */
  export type checkpointsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkpoints
     */
    select?: checkpointsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: checkpointsInclude<ExtArgs> | null
    /**
     * Filter, which checkpoints to fetch.
     */
    where?: checkpointsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of checkpoints to fetch.
     */
    orderBy?: checkpointsOrderByWithRelationInput | checkpointsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for checkpoints.
     */
    cursor?: checkpointsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` checkpoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` checkpoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of checkpoints.
     */
    distinct?: CheckpointsScalarFieldEnum | CheckpointsScalarFieldEnum[]
  }

  /**
   * checkpoints findMany
   */
  export type checkpointsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkpoints
     */
    select?: checkpointsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: checkpointsInclude<ExtArgs> | null
    /**
     * Filter, which checkpoints to fetch.
     */
    where?: checkpointsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of checkpoints to fetch.
     */
    orderBy?: checkpointsOrderByWithRelationInput | checkpointsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing checkpoints.
     */
    cursor?: checkpointsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` checkpoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` checkpoints.
     */
    skip?: number
    distinct?: CheckpointsScalarFieldEnum | CheckpointsScalarFieldEnum[]
  }

  /**
   * checkpoints create
   */
  export type checkpointsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkpoints
     */
    select?: checkpointsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: checkpointsInclude<ExtArgs> | null
    /**
     * The data needed to create a checkpoints.
     */
    data: XOR<checkpointsCreateInput, checkpointsUncheckedCreateInput>
  }

  /**
   * checkpoints createMany
   */
  export type checkpointsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many checkpoints.
     */
    data: checkpointsCreateManyInput | checkpointsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * checkpoints createManyAndReturn
   */
  export type checkpointsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkpoints
     */
    select?: checkpointsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many checkpoints.
     */
    data: checkpointsCreateManyInput | checkpointsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: checkpointsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * checkpoints update
   */
  export type checkpointsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkpoints
     */
    select?: checkpointsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: checkpointsInclude<ExtArgs> | null
    /**
     * The data needed to update a checkpoints.
     */
    data: XOR<checkpointsUpdateInput, checkpointsUncheckedUpdateInput>
    /**
     * Choose, which checkpoints to update.
     */
    where: checkpointsWhereUniqueInput
  }

  /**
   * checkpoints updateMany
   */
  export type checkpointsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update checkpoints.
     */
    data: XOR<checkpointsUpdateManyMutationInput, checkpointsUncheckedUpdateManyInput>
    /**
     * Filter which checkpoints to update
     */
    where?: checkpointsWhereInput
  }

  /**
   * checkpoints upsert
   */
  export type checkpointsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkpoints
     */
    select?: checkpointsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: checkpointsInclude<ExtArgs> | null
    /**
     * The filter to search for the checkpoints to update in case it exists.
     */
    where: checkpointsWhereUniqueInput
    /**
     * In case the checkpoints found by the `where` argument doesn't exist, create a new checkpoints with this data.
     */
    create: XOR<checkpointsCreateInput, checkpointsUncheckedCreateInput>
    /**
     * In case the checkpoints was found with the provided `where` argument, update it with this data.
     */
    update: XOR<checkpointsUpdateInput, checkpointsUncheckedUpdateInput>
  }

  /**
   * checkpoints delete
   */
  export type checkpointsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkpoints
     */
    select?: checkpointsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: checkpointsInclude<ExtArgs> | null
    /**
     * Filter which checkpoints to delete.
     */
    where: checkpointsWhereUniqueInput
  }

  /**
   * checkpoints deleteMany
   */
  export type checkpointsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which checkpoints to delete
     */
    where?: checkpointsWhereInput
  }

  /**
   * checkpoints.progress
   */
  export type checkpoints$progressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentLearningProgress
     */
    select?: studentLearningProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentLearningProgressInclude<ExtArgs> | null
    where?: studentLearningProgressWhereInput
    orderBy?: studentLearningProgressOrderByWithRelationInput | studentLearningProgressOrderByWithRelationInput[]
    cursor?: studentLearningProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentLearningProgressScalarFieldEnum | StudentLearningProgressScalarFieldEnum[]
  }

  /**
   * checkpoints without action
   */
  export type checkpointsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkpoints
     */
    select?: checkpointsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: checkpointsInclude<ExtArgs> | null
  }


  /**
   * Model studentLearningProgress
   */

  export type AggregateStudentLearningProgress = {
    _count: StudentLearningProgressCountAggregateOutputType | null
    _min: StudentLearningProgressMinAggregateOutputType | null
    _max: StudentLearningProgressMaxAggregateOutputType | null
  }

  export type StudentLearningProgressMinAggregateOutputType = {
    id: string | null
    profileId: string | null
    checkpointId: string | null
    isCompleted: boolean | null
    completedAt: Date | null
  }

  export type StudentLearningProgressMaxAggregateOutputType = {
    id: string | null
    profileId: string | null
    checkpointId: string | null
    isCompleted: boolean | null
    completedAt: Date | null
  }

  export type StudentLearningProgressCountAggregateOutputType = {
    id: number
    profileId: number
    checkpointId: number
    isCompleted: number
    completedAt: number
    _all: number
  }


  export type StudentLearningProgressMinAggregateInputType = {
    id?: true
    profileId?: true
    checkpointId?: true
    isCompleted?: true
    completedAt?: true
  }

  export type StudentLearningProgressMaxAggregateInputType = {
    id?: true
    profileId?: true
    checkpointId?: true
    isCompleted?: true
    completedAt?: true
  }

  export type StudentLearningProgressCountAggregateInputType = {
    id?: true
    profileId?: true
    checkpointId?: true
    isCompleted?: true
    completedAt?: true
    _all?: true
  }

  export type StudentLearningProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which studentLearningProgress to aggregate.
     */
    where?: studentLearningProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of studentLearningProgresses to fetch.
     */
    orderBy?: studentLearningProgressOrderByWithRelationInput | studentLearningProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: studentLearningProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` studentLearningProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` studentLearningProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned studentLearningProgresses
    **/
    _count?: true | StudentLearningProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentLearningProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentLearningProgressMaxAggregateInputType
  }

  export type GetStudentLearningProgressAggregateType<T extends StudentLearningProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentLearningProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentLearningProgress[P]>
      : GetScalarType<T[P], AggregateStudentLearningProgress[P]>
  }




  export type studentLearningProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: studentLearningProgressWhereInput
    orderBy?: studentLearningProgressOrderByWithAggregationInput | studentLearningProgressOrderByWithAggregationInput[]
    by: StudentLearningProgressScalarFieldEnum[] | StudentLearningProgressScalarFieldEnum
    having?: studentLearningProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentLearningProgressCountAggregateInputType | true
    _min?: StudentLearningProgressMinAggregateInputType
    _max?: StudentLearningProgressMaxAggregateInputType
  }

  export type StudentLearningProgressGroupByOutputType = {
    id: string
    profileId: string
    checkpointId: string
    isCompleted: boolean
    completedAt: Date | null
    _count: StudentLearningProgressCountAggregateOutputType | null
    _min: StudentLearningProgressMinAggregateOutputType | null
    _max: StudentLearningProgressMaxAggregateOutputType | null
  }

  type GetStudentLearningProgressGroupByPayload<T extends studentLearningProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentLearningProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentLearningProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentLearningProgressGroupByOutputType[P]>
            : GetScalarType<T[P], StudentLearningProgressGroupByOutputType[P]>
        }
      >
    >


  export type studentLearningProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    checkpointId?: boolean
    isCompleted?: boolean
    completedAt?: boolean
    checkpoint?: boolean | checkpointsDefaultArgs<ExtArgs>
    profile?: boolean | profileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentLearningProgress"]>

  export type studentLearningProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    checkpointId?: boolean
    isCompleted?: boolean
    completedAt?: boolean
    checkpoint?: boolean | checkpointsDefaultArgs<ExtArgs>
    profile?: boolean | profileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentLearningProgress"]>

  export type studentLearningProgressSelectScalar = {
    id?: boolean
    profileId?: boolean
    checkpointId?: boolean
    isCompleted?: boolean
    completedAt?: boolean
  }

  export type studentLearningProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    checkpoint?: boolean | checkpointsDefaultArgs<ExtArgs>
    profile?: boolean | profileDefaultArgs<ExtArgs>
  }
  export type studentLearningProgressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    checkpoint?: boolean | checkpointsDefaultArgs<ExtArgs>
    profile?: boolean | profileDefaultArgs<ExtArgs>
  }

  export type $studentLearningProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "studentLearningProgress"
    objects: {
      checkpoint: Prisma.$checkpointsPayload<ExtArgs>
      profile: Prisma.$profilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profileId: string
      checkpointId: string
      isCompleted: boolean
      completedAt: Date | null
    }, ExtArgs["result"]["studentLearningProgress"]>
    composites: {}
  }

  type studentLearningProgressGetPayload<S extends boolean | null | undefined | studentLearningProgressDefaultArgs> = $Result.GetResult<Prisma.$studentLearningProgressPayload, S>

  type studentLearningProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<studentLearningProgressFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudentLearningProgressCountAggregateInputType | true
    }

  export interface studentLearningProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['studentLearningProgress'], meta: { name: 'studentLearningProgress' } }
    /**
     * Find zero or one StudentLearningProgress that matches the filter.
     * @param {studentLearningProgressFindUniqueArgs} args - Arguments to find a StudentLearningProgress
     * @example
     * // Get one StudentLearningProgress
     * const studentLearningProgress = await prisma.studentLearningProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends studentLearningProgressFindUniqueArgs>(args: SelectSubset<T, studentLearningProgressFindUniqueArgs<ExtArgs>>): Prisma__studentLearningProgressClient<$Result.GetResult<Prisma.$studentLearningProgressPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StudentLearningProgress that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {studentLearningProgressFindUniqueOrThrowArgs} args - Arguments to find a StudentLearningProgress
     * @example
     * // Get one StudentLearningProgress
     * const studentLearningProgress = await prisma.studentLearningProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends studentLearningProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, studentLearningProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__studentLearningProgressClient<$Result.GetResult<Prisma.$studentLearningProgressPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StudentLearningProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentLearningProgressFindFirstArgs} args - Arguments to find a StudentLearningProgress
     * @example
     * // Get one StudentLearningProgress
     * const studentLearningProgress = await prisma.studentLearningProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends studentLearningProgressFindFirstArgs>(args?: SelectSubset<T, studentLearningProgressFindFirstArgs<ExtArgs>>): Prisma__studentLearningProgressClient<$Result.GetResult<Prisma.$studentLearningProgressPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StudentLearningProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentLearningProgressFindFirstOrThrowArgs} args - Arguments to find a StudentLearningProgress
     * @example
     * // Get one StudentLearningProgress
     * const studentLearningProgress = await prisma.studentLearningProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends studentLearningProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, studentLearningProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__studentLearningProgressClient<$Result.GetResult<Prisma.$studentLearningProgressPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StudentLearningProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentLearningProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentLearningProgresses
     * const studentLearningProgresses = await prisma.studentLearningProgress.findMany()
     * 
     * // Get first 10 StudentLearningProgresses
     * const studentLearningProgresses = await prisma.studentLearningProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentLearningProgressWithIdOnly = await prisma.studentLearningProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends studentLearningProgressFindManyArgs>(args?: SelectSubset<T, studentLearningProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentLearningProgressPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StudentLearningProgress.
     * @param {studentLearningProgressCreateArgs} args - Arguments to create a StudentLearningProgress.
     * @example
     * // Create one StudentLearningProgress
     * const StudentLearningProgress = await prisma.studentLearningProgress.create({
     *   data: {
     *     // ... data to create a StudentLearningProgress
     *   }
     * })
     * 
     */
    create<T extends studentLearningProgressCreateArgs>(args: SelectSubset<T, studentLearningProgressCreateArgs<ExtArgs>>): Prisma__studentLearningProgressClient<$Result.GetResult<Prisma.$studentLearningProgressPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StudentLearningProgresses.
     * @param {studentLearningProgressCreateManyArgs} args - Arguments to create many StudentLearningProgresses.
     * @example
     * // Create many StudentLearningProgresses
     * const studentLearningProgress = await prisma.studentLearningProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends studentLearningProgressCreateManyArgs>(args?: SelectSubset<T, studentLearningProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentLearningProgresses and returns the data saved in the database.
     * @param {studentLearningProgressCreateManyAndReturnArgs} args - Arguments to create many StudentLearningProgresses.
     * @example
     * // Create many StudentLearningProgresses
     * const studentLearningProgress = await prisma.studentLearningProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentLearningProgresses and only return the `id`
     * const studentLearningProgressWithIdOnly = await prisma.studentLearningProgress.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends studentLearningProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, studentLearningProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentLearningProgressPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StudentLearningProgress.
     * @param {studentLearningProgressDeleteArgs} args - Arguments to delete one StudentLearningProgress.
     * @example
     * // Delete one StudentLearningProgress
     * const StudentLearningProgress = await prisma.studentLearningProgress.delete({
     *   where: {
     *     // ... filter to delete one StudentLearningProgress
     *   }
     * })
     * 
     */
    delete<T extends studentLearningProgressDeleteArgs>(args: SelectSubset<T, studentLearningProgressDeleteArgs<ExtArgs>>): Prisma__studentLearningProgressClient<$Result.GetResult<Prisma.$studentLearningProgressPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StudentLearningProgress.
     * @param {studentLearningProgressUpdateArgs} args - Arguments to update one StudentLearningProgress.
     * @example
     * // Update one StudentLearningProgress
     * const studentLearningProgress = await prisma.studentLearningProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends studentLearningProgressUpdateArgs>(args: SelectSubset<T, studentLearningProgressUpdateArgs<ExtArgs>>): Prisma__studentLearningProgressClient<$Result.GetResult<Prisma.$studentLearningProgressPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StudentLearningProgresses.
     * @param {studentLearningProgressDeleteManyArgs} args - Arguments to filter StudentLearningProgresses to delete.
     * @example
     * // Delete a few StudentLearningProgresses
     * const { count } = await prisma.studentLearningProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends studentLearningProgressDeleteManyArgs>(args?: SelectSubset<T, studentLearningProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentLearningProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentLearningProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentLearningProgresses
     * const studentLearningProgress = await prisma.studentLearningProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends studentLearningProgressUpdateManyArgs>(args: SelectSubset<T, studentLearningProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentLearningProgress.
     * @param {studentLearningProgressUpsertArgs} args - Arguments to update or create a StudentLearningProgress.
     * @example
     * // Update or create a StudentLearningProgress
     * const studentLearningProgress = await prisma.studentLearningProgress.upsert({
     *   create: {
     *     // ... data to create a StudentLearningProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentLearningProgress we want to update
     *   }
     * })
     */
    upsert<T extends studentLearningProgressUpsertArgs>(args: SelectSubset<T, studentLearningProgressUpsertArgs<ExtArgs>>): Prisma__studentLearningProgressClient<$Result.GetResult<Prisma.$studentLearningProgressPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StudentLearningProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentLearningProgressCountArgs} args - Arguments to filter StudentLearningProgresses to count.
     * @example
     * // Count the number of StudentLearningProgresses
     * const count = await prisma.studentLearningProgress.count({
     *   where: {
     *     // ... the filter for the StudentLearningProgresses we want to count
     *   }
     * })
    **/
    count<T extends studentLearningProgressCountArgs>(
      args?: Subset<T, studentLearningProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentLearningProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentLearningProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentLearningProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentLearningProgressAggregateArgs>(args: Subset<T, StudentLearningProgressAggregateArgs>): Prisma.PrismaPromise<GetStudentLearningProgressAggregateType<T>>

    /**
     * Group by StudentLearningProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentLearningProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends studentLearningProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: studentLearningProgressGroupByArgs['orderBy'] }
        : { orderBy?: studentLearningProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, studentLearningProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentLearningProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the studentLearningProgress model
   */
  readonly fields: studentLearningProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for studentLearningProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__studentLearningProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    checkpoint<T extends checkpointsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, checkpointsDefaultArgs<ExtArgs>>): Prisma__checkpointsClient<$Result.GetResult<Prisma.$checkpointsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    profile<T extends profileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, profileDefaultArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the studentLearningProgress model
   */ 
  interface studentLearningProgressFieldRefs {
    readonly id: FieldRef<"studentLearningProgress", 'String'>
    readonly profileId: FieldRef<"studentLearningProgress", 'String'>
    readonly checkpointId: FieldRef<"studentLearningProgress", 'String'>
    readonly isCompleted: FieldRef<"studentLearningProgress", 'Boolean'>
    readonly completedAt: FieldRef<"studentLearningProgress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * studentLearningProgress findUnique
   */
  export type studentLearningProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentLearningProgress
     */
    select?: studentLearningProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentLearningProgressInclude<ExtArgs> | null
    /**
     * Filter, which studentLearningProgress to fetch.
     */
    where: studentLearningProgressWhereUniqueInput
  }

  /**
   * studentLearningProgress findUniqueOrThrow
   */
  export type studentLearningProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentLearningProgress
     */
    select?: studentLearningProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentLearningProgressInclude<ExtArgs> | null
    /**
     * Filter, which studentLearningProgress to fetch.
     */
    where: studentLearningProgressWhereUniqueInput
  }

  /**
   * studentLearningProgress findFirst
   */
  export type studentLearningProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentLearningProgress
     */
    select?: studentLearningProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentLearningProgressInclude<ExtArgs> | null
    /**
     * Filter, which studentLearningProgress to fetch.
     */
    where?: studentLearningProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of studentLearningProgresses to fetch.
     */
    orderBy?: studentLearningProgressOrderByWithRelationInput | studentLearningProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for studentLearningProgresses.
     */
    cursor?: studentLearningProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` studentLearningProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` studentLearningProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of studentLearningProgresses.
     */
    distinct?: StudentLearningProgressScalarFieldEnum | StudentLearningProgressScalarFieldEnum[]
  }

  /**
   * studentLearningProgress findFirstOrThrow
   */
  export type studentLearningProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentLearningProgress
     */
    select?: studentLearningProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentLearningProgressInclude<ExtArgs> | null
    /**
     * Filter, which studentLearningProgress to fetch.
     */
    where?: studentLearningProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of studentLearningProgresses to fetch.
     */
    orderBy?: studentLearningProgressOrderByWithRelationInput | studentLearningProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for studentLearningProgresses.
     */
    cursor?: studentLearningProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` studentLearningProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` studentLearningProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of studentLearningProgresses.
     */
    distinct?: StudentLearningProgressScalarFieldEnum | StudentLearningProgressScalarFieldEnum[]
  }

  /**
   * studentLearningProgress findMany
   */
  export type studentLearningProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentLearningProgress
     */
    select?: studentLearningProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentLearningProgressInclude<ExtArgs> | null
    /**
     * Filter, which studentLearningProgresses to fetch.
     */
    where?: studentLearningProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of studentLearningProgresses to fetch.
     */
    orderBy?: studentLearningProgressOrderByWithRelationInput | studentLearningProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing studentLearningProgresses.
     */
    cursor?: studentLearningProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` studentLearningProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` studentLearningProgresses.
     */
    skip?: number
    distinct?: StudentLearningProgressScalarFieldEnum | StudentLearningProgressScalarFieldEnum[]
  }

  /**
   * studentLearningProgress create
   */
  export type studentLearningProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentLearningProgress
     */
    select?: studentLearningProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentLearningProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a studentLearningProgress.
     */
    data: XOR<studentLearningProgressCreateInput, studentLearningProgressUncheckedCreateInput>
  }

  /**
   * studentLearningProgress createMany
   */
  export type studentLearningProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many studentLearningProgresses.
     */
    data: studentLearningProgressCreateManyInput | studentLearningProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * studentLearningProgress createManyAndReturn
   */
  export type studentLearningProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentLearningProgress
     */
    select?: studentLearningProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many studentLearningProgresses.
     */
    data: studentLearningProgressCreateManyInput | studentLearningProgressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentLearningProgressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * studentLearningProgress update
   */
  export type studentLearningProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentLearningProgress
     */
    select?: studentLearningProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentLearningProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a studentLearningProgress.
     */
    data: XOR<studentLearningProgressUpdateInput, studentLearningProgressUncheckedUpdateInput>
    /**
     * Choose, which studentLearningProgress to update.
     */
    where: studentLearningProgressWhereUniqueInput
  }

  /**
   * studentLearningProgress updateMany
   */
  export type studentLearningProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update studentLearningProgresses.
     */
    data: XOR<studentLearningProgressUpdateManyMutationInput, studentLearningProgressUncheckedUpdateManyInput>
    /**
     * Filter which studentLearningProgresses to update
     */
    where?: studentLearningProgressWhereInput
  }

  /**
   * studentLearningProgress upsert
   */
  export type studentLearningProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentLearningProgress
     */
    select?: studentLearningProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentLearningProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the studentLearningProgress to update in case it exists.
     */
    where: studentLearningProgressWhereUniqueInput
    /**
     * In case the studentLearningProgress found by the `where` argument doesn't exist, create a new studentLearningProgress with this data.
     */
    create: XOR<studentLearningProgressCreateInput, studentLearningProgressUncheckedCreateInput>
    /**
     * In case the studentLearningProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<studentLearningProgressUpdateInput, studentLearningProgressUncheckedUpdateInput>
  }

  /**
   * studentLearningProgress delete
   */
  export type studentLearningProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentLearningProgress
     */
    select?: studentLearningProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentLearningProgressInclude<ExtArgs> | null
    /**
     * Filter which studentLearningProgress to delete.
     */
    where: studentLearningProgressWhereUniqueInput
  }

  /**
   * studentLearningProgress deleteMany
   */
  export type studentLearningProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which studentLearningProgresses to delete
     */
    where?: studentLearningProgressWhereInput
  }

  /**
   * studentLearningProgress without action
   */
  export type studentLearningProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentLearningProgress
     */
    select?: studentLearningProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentLearningProgressInclude<ExtArgs> | null
  }


  /**
   * Model courses
   */

  export type AggregateCourses = {
    _count: CoursesCountAggregateOutputType | null
    _avg: CoursesAvgAggregateOutputType | null
    _sum: CoursesSumAggregateOutputType | null
    _min: CoursesMinAggregateOutputType | null
    _max: CoursesMaxAggregateOutputType | null
  }

  export type CoursesAvgAggregateOutputType = {
    price: number | null
  }

  export type CoursesSumAggregateOutputType = {
    price: number | null
  }

  export type CoursesMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    type: $Enums.CourseType | null
    price: number | null
    instructorId: string | null
    thumbnail_url: string | null
    created_at: Date | null
  }

  export type CoursesMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    type: $Enums.CourseType | null
    price: number | null
    instructorId: string | null
    thumbnail_url: string | null
    created_at: Date | null
  }

  export type CoursesCountAggregateOutputType = {
    id: number
    title: number
    description: number
    type: number
    price: number
    instructorId: number
    thumbnail_url: number
    created_at: number
    _all: number
  }


  export type CoursesAvgAggregateInputType = {
    price?: true
  }

  export type CoursesSumAggregateInputType = {
    price?: true
  }

  export type CoursesMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    price?: true
    instructorId?: true
    thumbnail_url?: true
    created_at?: true
  }

  export type CoursesMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    price?: true
    instructorId?: true
    thumbnail_url?: true
    created_at?: true
  }

  export type CoursesCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    price?: true
    instructorId?: true
    thumbnail_url?: true
    created_at?: true
    _all?: true
  }

  export type CoursesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which courses to aggregate.
     */
    where?: coursesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of courses to fetch.
     */
    orderBy?: coursesOrderByWithRelationInput | coursesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: coursesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned courses
    **/
    _count?: true | CoursesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CoursesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CoursesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CoursesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CoursesMaxAggregateInputType
  }

  export type GetCoursesAggregateType<T extends CoursesAggregateArgs> = {
        [P in keyof T & keyof AggregateCourses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourses[P]>
      : GetScalarType<T[P], AggregateCourses[P]>
  }




  export type coursesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: coursesWhereInput
    orderBy?: coursesOrderByWithAggregationInput | coursesOrderByWithAggregationInput[]
    by: CoursesScalarFieldEnum[] | CoursesScalarFieldEnum
    having?: coursesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CoursesCountAggregateInputType | true
    _avg?: CoursesAvgAggregateInputType
    _sum?: CoursesSumAggregateInputType
    _min?: CoursesMinAggregateInputType
    _max?: CoursesMaxAggregateInputType
  }

  export type CoursesGroupByOutputType = {
    id: string
    title: string
    description: string
    type: $Enums.CourseType
    price: number | null
    instructorId: string
    thumbnail_url: string | null
    created_at: Date
    _count: CoursesCountAggregateOutputType | null
    _avg: CoursesAvgAggregateOutputType | null
    _sum: CoursesSumAggregateOutputType | null
    _min: CoursesMinAggregateOutputType | null
    _max: CoursesMaxAggregateOutputType | null
  }

  type GetCoursesGroupByPayload<T extends coursesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CoursesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CoursesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CoursesGroupByOutputType[P]>
            : GetScalarType<T[P], CoursesGroupByOutputType[P]>
        }
      >
    >


  export type coursesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    price?: boolean
    instructorId?: boolean
    thumbnail_url?: boolean
    created_at?: boolean
    enrollments?: boolean | courses$enrollmentsArgs<ExtArgs>
    instructor?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | CoursesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courses"]>

  export type coursesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    price?: boolean
    instructorId?: boolean
    thumbnail_url?: boolean
    created_at?: boolean
    instructor?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courses"]>

  export type coursesSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    price?: boolean
    instructorId?: boolean
    thumbnail_url?: boolean
    created_at?: boolean
  }

  export type coursesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enrollments?: boolean | courses$enrollmentsArgs<ExtArgs>
    instructor?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | CoursesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type coursesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instructor?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $coursesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "courses"
    objects: {
      enrollments: Prisma.$courseEnrollmentsPayload<ExtArgs>[]
      instructor: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      type: $Enums.CourseType
      price: number | null
      instructorId: string
      thumbnail_url: string | null
      created_at: Date
    }, ExtArgs["result"]["courses"]>
    composites: {}
  }

  type coursesGetPayload<S extends boolean | null | undefined | coursesDefaultArgs> = $Result.GetResult<Prisma.$coursesPayload, S>

  type coursesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<coursesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CoursesCountAggregateInputType | true
    }

  export interface coursesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['courses'], meta: { name: 'courses' } }
    /**
     * Find zero or one Courses that matches the filter.
     * @param {coursesFindUniqueArgs} args - Arguments to find a Courses
     * @example
     * // Get one Courses
     * const courses = await prisma.courses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends coursesFindUniqueArgs>(args: SelectSubset<T, coursesFindUniqueArgs<ExtArgs>>): Prisma__coursesClient<$Result.GetResult<Prisma.$coursesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Courses that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {coursesFindUniqueOrThrowArgs} args - Arguments to find a Courses
     * @example
     * // Get one Courses
     * const courses = await prisma.courses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends coursesFindUniqueOrThrowArgs>(args: SelectSubset<T, coursesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__coursesClient<$Result.GetResult<Prisma.$coursesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coursesFindFirstArgs} args - Arguments to find a Courses
     * @example
     * // Get one Courses
     * const courses = await prisma.courses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends coursesFindFirstArgs>(args?: SelectSubset<T, coursesFindFirstArgs<ExtArgs>>): Prisma__coursesClient<$Result.GetResult<Prisma.$coursesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Courses that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coursesFindFirstOrThrowArgs} args - Arguments to find a Courses
     * @example
     * // Get one Courses
     * const courses = await prisma.courses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends coursesFindFirstOrThrowArgs>(args?: SelectSubset<T, coursesFindFirstOrThrowArgs<ExtArgs>>): Prisma__coursesClient<$Result.GetResult<Prisma.$coursesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coursesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courses
     * const courses = await prisma.courses.findMany()
     * 
     * // Get first 10 Courses
     * const courses = await prisma.courses.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const coursesWithIdOnly = await prisma.courses.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends coursesFindManyArgs>(args?: SelectSubset<T, coursesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$coursesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Courses.
     * @param {coursesCreateArgs} args - Arguments to create a Courses.
     * @example
     * // Create one Courses
     * const Courses = await prisma.courses.create({
     *   data: {
     *     // ... data to create a Courses
     *   }
     * })
     * 
     */
    create<T extends coursesCreateArgs>(args: SelectSubset<T, coursesCreateArgs<ExtArgs>>): Prisma__coursesClient<$Result.GetResult<Prisma.$coursesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Courses.
     * @param {coursesCreateManyArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const courses = await prisma.courses.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends coursesCreateManyArgs>(args?: SelectSubset<T, coursesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Courses and returns the data saved in the database.
     * @param {coursesCreateManyAndReturnArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const courses = await prisma.courses.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Courses and only return the `id`
     * const coursesWithIdOnly = await prisma.courses.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends coursesCreateManyAndReturnArgs>(args?: SelectSubset<T, coursesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$coursesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Courses.
     * @param {coursesDeleteArgs} args - Arguments to delete one Courses.
     * @example
     * // Delete one Courses
     * const Courses = await prisma.courses.delete({
     *   where: {
     *     // ... filter to delete one Courses
     *   }
     * })
     * 
     */
    delete<T extends coursesDeleteArgs>(args: SelectSubset<T, coursesDeleteArgs<ExtArgs>>): Prisma__coursesClient<$Result.GetResult<Prisma.$coursesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Courses.
     * @param {coursesUpdateArgs} args - Arguments to update one Courses.
     * @example
     * // Update one Courses
     * const courses = await prisma.courses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends coursesUpdateArgs>(args: SelectSubset<T, coursesUpdateArgs<ExtArgs>>): Prisma__coursesClient<$Result.GetResult<Prisma.$coursesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Courses.
     * @param {coursesDeleteManyArgs} args - Arguments to filter Courses to delete.
     * @example
     * // Delete a few Courses
     * const { count } = await prisma.courses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends coursesDeleteManyArgs>(args?: SelectSubset<T, coursesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coursesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courses
     * const courses = await prisma.courses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends coursesUpdateManyArgs>(args: SelectSubset<T, coursesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Courses.
     * @param {coursesUpsertArgs} args - Arguments to update or create a Courses.
     * @example
     * // Update or create a Courses
     * const courses = await prisma.courses.upsert({
     *   create: {
     *     // ... data to create a Courses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Courses we want to update
     *   }
     * })
     */
    upsert<T extends coursesUpsertArgs>(args: SelectSubset<T, coursesUpsertArgs<ExtArgs>>): Prisma__coursesClient<$Result.GetResult<Prisma.$coursesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coursesCountArgs} args - Arguments to filter Courses to count.
     * @example
     * // Count the number of Courses
     * const count = await prisma.courses.count({
     *   where: {
     *     // ... the filter for the Courses we want to count
     *   }
     * })
    **/
    count<T extends coursesCountArgs>(
      args?: Subset<T, coursesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CoursesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CoursesAggregateArgs>(args: Subset<T, CoursesAggregateArgs>): Prisma.PrismaPromise<GetCoursesAggregateType<T>>

    /**
     * Group by Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coursesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends coursesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: coursesGroupByArgs['orderBy'] }
        : { orderBy?: coursesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, coursesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCoursesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the courses model
   */
  readonly fields: coursesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for courses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__coursesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    enrollments<T extends courses$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, courses$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$courseEnrollmentsPayload<ExtArgs>, T, "findMany"> | Null>
    instructor<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the courses model
   */ 
  interface coursesFieldRefs {
    readonly id: FieldRef<"courses", 'String'>
    readonly title: FieldRef<"courses", 'String'>
    readonly description: FieldRef<"courses", 'String'>
    readonly type: FieldRef<"courses", 'CourseType'>
    readonly price: FieldRef<"courses", 'Float'>
    readonly instructorId: FieldRef<"courses", 'String'>
    readonly thumbnail_url: FieldRef<"courses", 'String'>
    readonly created_at: FieldRef<"courses", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * courses findUnique
   */
  export type coursesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courses
     */
    select?: coursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coursesInclude<ExtArgs> | null
    /**
     * Filter, which courses to fetch.
     */
    where: coursesWhereUniqueInput
  }

  /**
   * courses findUniqueOrThrow
   */
  export type coursesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courses
     */
    select?: coursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coursesInclude<ExtArgs> | null
    /**
     * Filter, which courses to fetch.
     */
    where: coursesWhereUniqueInput
  }

  /**
   * courses findFirst
   */
  export type coursesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courses
     */
    select?: coursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coursesInclude<ExtArgs> | null
    /**
     * Filter, which courses to fetch.
     */
    where?: coursesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of courses to fetch.
     */
    orderBy?: coursesOrderByWithRelationInput | coursesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for courses.
     */
    cursor?: coursesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of courses.
     */
    distinct?: CoursesScalarFieldEnum | CoursesScalarFieldEnum[]
  }

  /**
   * courses findFirstOrThrow
   */
  export type coursesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courses
     */
    select?: coursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coursesInclude<ExtArgs> | null
    /**
     * Filter, which courses to fetch.
     */
    where?: coursesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of courses to fetch.
     */
    orderBy?: coursesOrderByWithRelationInput | coursesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for courses.
     */
    cursor?: coursesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of courses.
     */
    distinct?: CoursesScalarFieldEnum | CoursesScalarFieldEnum[]
  }

  /**
   * courses findMany
   */
  export type coursesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courses
     */
    select?: coursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coursesInclude<ExtArgs> | null
    /**
     * Filter, which courses to fetch.
     */
    where?: coursesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of courses to fetch.
     */
    orderBy?: coursesOrderByWithRelationInput | coursesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing courses.
     */
    cursor?: coursesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` courses.
     */
    skip?: number
    distinct?: CoursesScalarFieldEnum | CoursesScalarFieldEnum[]
  }

  /**
   * courses create
   */
  export type coursesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courses
     */
    select?: coursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coursesInclude<ExtArgs> | null
    /**
     * The data needed to create a courses.
     */
    data: XOR<coursesCreateInput, coursesUncheckedCreateInput>
  }

  /**
   * courses createMany
   */
  export type coursesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many courses.
     */
    data: coursesCreateManyInput | coursesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * courses createManyAndReturn
   */
  export type coursesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courses
     */
    select?: coursesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many courses.
     */
    data: coursesCreateManyInput | coursesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coursesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * courses update
   */
  export type coursesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courses
     */
    select?: coursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coursesInclude<ExtArgs> | null
    /**
     * The data needed to update a courses.
     */
    data: XOR<coursesUpdateInput, coursesUncheckedUpdateInput>
    /**
     * Choose, which courses to update.
     */
    where: coursesWhereUniqueInput
  }

  /**
   * courses updateMany
   */
  export type coursesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update courses.
     */
    data: XOR<coursesUpdateManyMutationInput, coursesUncheckedUpdateManyInput>
    /**
     * Filter which courses to update
     */
    where?: coursesWhereInput
  }

  /**
   * courses upsert
   */
  export type coursesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courses
     */
    select?: coursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coursesInclude<ExtArgs> | null
    /**
     * The filter to search for the courses to update in case it exists.
     */
    where: coursesWhereUniqueInput
    /**
     * In case the courses found by the `where` argument doesn't exist, create a new courses with this data.
     */
    create: XOR<coursesCreateInput, coursesUncheckedCreateInput>
    /**
     * In case the courses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<coursesUpdateInput, coursesUncheckedUpdateInput>
  }

  /**
   * courses delete
   */
  export type coursesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courses
     */
    select?: coursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coursesInclude<ExtArgs> | null
    /**
     * Filter which courses to delete.
     */
    where: coursesWhereUniqueInput
  }

  /**
   * courses deleteMany
   */
  export type coursesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which courses to delete
     */
    where?: coursesWhereInput
  }

  /**
   * courses.enrollments
   */
  export type courses$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courseEnrollments
     */
    select?: courseEnrollmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: courseEnrollmentsInclude<ExtArgs> | null
    where?: courseEnrollmentsWhereInput
    orderBy?: courseEnrollmentsOrderByWithRelationInput | courseEnrollmentsOrderByWithRelationInput[]
    cursor?: courseEnrollmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseEnrollmentsScalarFieldEnum | CourseEnrollmentsScalarFieldEnum[]
  }

  /**
   * courses without action
   */
  export type coursesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courses
     */
    select?: coursesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coursesInclude<ExtArgs> | null
  }


  /**
   * Model courseEnrollments
   */

  export type AggregateCourseEnrollments = {
    _count: CourseEnrollmentsCountAggregateOutputType | null
    _avg: CourseEnrollmentsAvgAggregateOutputType | null
    _sum: CourseEnrollmentsSumAggregateOutputType | null
    _min: CourseEnrollmentsMinAggregateOutputType | null
    _max: CourseEnrollmentsMaxAggregateOutputType | null
  }

  export type CourseEnrollmentsAvgAggregateOutputType = {
    progressPercent: number | null
  }

  export type CourseEnrollmentsSumAggregateOutputType = {
    progressPercent: number | null
  }

  export type CourseEnrollmentsMinAggregateOutputType = {
    id: string | null
    courseId: string | null
    userId: string | null
    progressPercent: number | null
    enrolledAt: Date | null
  }

  export type CourseEnrollmentsMaxAggregateOutputType = {
    id: string | null
    courseId: string | null
    userId: string | null
    progressPercent: number | null
    enrolledAt: Date | null
  }

  export type CourseEnrollmentsCountAggregateOutputType = {
    id: number
    courseId: number
    userId: number
    progressPercent: number
    enrolledAt: number
    _all: number
  }


  export type CourseEnrollmentsAvgAggregateInputType = {
    progressPercent?: true
  }

  export type CourseEnrollmentsSumAggregateInputType = {
    progressPercent?: true
  }

  export type CourseEnrollmentsMinAggregateInputType = {
    id?: true
    courseId?: true
    userId?: true
    progressPercent?: true
    enrolledAt?: true
  }

  export type CourseEnrollmentsMaxAggregateInputType = {
    id?: true
    courseId?: true
    userId?: true
    progressPercent?: true
    enrolledAt?: true
  }

  export type CourseEnrollmentsCountAggregateInputType = {
    id?: true
    courseId?: true
    userId?: true
    progressPercent?: true
    enrolledAt?: true
    _all?: true
  }

  export type CourseEnrollmentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which courseEnrollments to aggregate.
     */
    where?: courseEnrollmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of courseEnrollments to fetch.
     */
    orderBy?: courseEnrollmentsOrderByWithRelationInput | courseEnrollmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: courseEnrollmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` courseEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` courseEnrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned courseEnrollments
    **/
    _count?: true | CourseEnrollmentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseEnrollmentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseEnrollmentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseEnrollmentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseEnrollmentsMaxAggregateInputType
  }

  export type GetCourseEnrollmentsAggregateType<T extends CourseEnrollmentsAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseEnrollments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseEnrollments[P]>
      : GetScalarType<T[P], AggregateCourseEnrollments[P]>
  }




  export type courseEnrollmentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: courseEnrollmentsWhereInput
    orderBy?: courseEnrollmentsOrderByWithAggregationInput | courseEnrollmentsOrderByWithAggregationInput[]
    by: CourseEnrollmentsScalarFieldEnum[] | CourseEnrollmentsScalarFieldEnum
    having?: courseEnrollmentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseEnrollmentsCountAggregateInputType | true
    _avg?: CourseEnrollmentsAvgAggregateInputType
    _sum?: CourseEnrollmentsSumAggregateInputType
    _min?: CourseEnrollmentsMinAggregateInputType
    _max?: CourseEnrollmentsMaxAggregateInputType
  }

  export type CourseEnrollmentsGroupByOutputType = {
    id: string
    courseId: string
    userId: string
    progressPercent: number | null
    enrolledAt: Date
    _count: CourseEnrollmentsCountAggregateOutputType | null
    _avg: CourseEnrollmentsAvgAggregateOutputType | null
    _sum: CourseEnrollmentsSumAggregateOutputType | null
    _min: CourseEnrollmentsMinAggregateOutputType | null
    _max: CourseEnrollmentsMaxAggregateOutputType | null
  }

  type GetCourseEnrollmentsGroupByPayload<T extends courseEnrollmentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseEnrollmentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseEnrollmentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseEnrollmentsGroupByOutputType[P]>
            : GetScalarType<T[P], CourseEnrollmentsGroupByOutputType[P]>
        }
      >
    >


  export type courseEnrollmentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    userId?: boolean
    progressPercent?: boolean
    enrolledAt?: boolean
    course?: boolean | coursesDefaultArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseEnrollments"]>

  export type courseEnrollmentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    userId?: boolean
    progressPercent?: boolean
    enrolledAt?: boolean
    course?: boolean | coursesDefaultArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseEnrollments"]>

  export type courseEnrollmentsSelectScalar = {
    id?: boolean
    courseId?: boolean
    userId?: boolean
    progressPercent?: boolean
    enrolledAt?: boolean
  }

  export type courseEnrollmentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | coursesDefaultArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type courseEnrollmentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | coursesDefaultArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $courseEnrollmentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "courseEnrollments"
    objects: {
      course: Prisma.$coursesPayload<ExtArgs>
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      courseId: string
      userId: string
      progressPercent: number | null
      enrolledAt: Date
    }, ExtArgs["result"]["courseEnrollments"]>
    composites: {}
  }

  type courseEnrollmentsGetPayload<S extends boolean | null | undefined | courseEnrollmentsDefaultArgs> = $Result.GetResult<Prisma.$courseEnrollmentsPayload, S>

  type courseEnrollmentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<courseEnrollmentsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CourseEnrollmentsCountAggregateInputType | true
    }

  export interface courseEnrollmentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['courseEnrollments'], meta: { name: 'courseEnrollments' } }
    /**
     * Find zero or one CourseEnrollments that matches the filter.
     * @param {courseEnrollmentsFindUniqueArgs} args - Arguments to find a CourseEnrollments
     * @example
     * // Get one CourseEnrollments
     * const courseEnrollments = await prisma.courseEnrollments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends courseEnrollmentsFindUniqueArgs>(args: SelectSubset<T, courseEnrollmentsFindUniqueArgs<ExtArgs>>): Prisma__courseEnrollmentsClient<$Result.GetResult<Prisma.$courseEnrollmentsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CourseEnrollments that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {courseEnrollmentsFindUniqueOrThrowArgs} args - Arguments to find a CourseEnrollments
     * @example
     * // Get one CourseEnrollments
     * const courseEnrollments = await prisma.courseEnrollments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends courseEnrollmentsFindUniqueOrThrowArgs>(args: SelectSubset<T, courseEnrollmentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__courseEnrollmentsClient<$Result.GetResult<Prisma.$courseEnrollmentsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CourseEnrollments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {courseEnrollmentsFindFirstArgs} args - Arguments to find a CourseEnrollments
     * @example
     * // Get one CourseEnrollments
     * const courseEnrollments = await prisma.courseEnrollments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends courseEnrollmentsFindFirstArgs>(args?: SelectSubset<T, courseEnrollmentsFindFirstArgs<ExtArgs>>): Prisma__courseEnrollmentsClient<$Result.GetResult<Prisma.$courseEnrollmentsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CourseEnrollments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {courseEnrollmentsFindFirstOrThrowArgs} args - Arguments to find a CourseEnrollments
     * @example
     * // Get one CourseEnrollments
     * const courseEnrollments = await prisma.courseEnrollments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends courseEnrollmentsFindFirstOrThrowArgs>(args?: SelectSubset<T, courseEnrollmentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__courseEnrollmentsClient<$Result.GetResult<Prisma.$courseEnrollmentsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CourseEnrollments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {courseEnrollmentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseEnrollments
     * const courseEnrollments = await prisma.courseEnrollments.findMany()
     * 
     * // Get first 10 CourseEnrollments
     * const courseEnrollments = await prisma.courseEnrollments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseEnrollmentsWithIdOnly = await prisma.courseEnrollments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends courseEnrollmentsFindManyArgs>(args?: SelectSubset<T, courseEnrollmentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$courseEnrollmentsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CourseEnrollments.
     * @param {courseEnrollmentsCreateArgs} args - Arguments to create a CourseEnrollments.
     * @example
     * // Create one CourseEnrollments
     * const CourseEnrollments = await prisma.courseEnrollments.create({
     *   data: {
     *     // ... data to create a CourseEnrollments
     *   }
     * })
     * 
     */
    create<T extends courseEnrollmentsCreateArgs>(args: SelectSubset<T, courseEnrollmentsCreateArgs<ExtArgs>>): Prisma__courseEnrollmentsClient<$Result.GetResult<Prisma.$courseEnrollmentsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CourseEnrollments.
     * @param {courseEnrollmentsCreateManyArgs} args - Arguments to create many CourseEnrollments.
     * @example
     * // Create many CourseEnrollments
     * const courseEnrollments = await prisma.courseEnrollments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends courseEnrollmentsCreateManyArgs>(args?: SelectSubset<T, courseEnrollmentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourseEnrollments and returns the data saved in the database.
     * @param {courseEnrollmentsCreateManyAndReturnArgs} args - Arguments to create many CourseEnrollments.
     * @example
     * // Create many CourseEnrollments
     * const courseEnrollments = await prisma.courseEnrollments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourseEnrollments and only return the `id`
     * const courseEnrollmentsWithIdOnly = await prisma.courseEnrollments.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends courseEnrollmentsCreateManyAndReturnArgs>(args?: SelectSubset<T, courseEnrollmentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$courseEnrollmentsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CourseEnrollments.
     * @param {courseEnrollmentsDeleteArgs} args - Arguments to delete one CourseEnrollments.
     * @example
     * // Delete one CourseEnrollments
     * const CourseEnrollments = await prisma.courseEnrollments.delete({
     *   where: {
     *     // ... filter to delete one CourseEnrollments
     *   }
     * })
     * 
     */
    delete<T extends courseEnrollmentsDeleteArgs>(args: SelectSubset<T, courseEnrollmentsDeleteArgs<ExtArgs>>): Prisma__courseEnrollmentsClient<$Result.GetResult<Prisma.$courseEnrollmentsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CourseEnrollments.
     * @param {courseEnrollmentsUpdateArgs} args - Arguments to update one CourseEnrollments.
     * @example
     * // Update one CourseEnrollments
     * const courseEnrollments = await prisma.courseEnrollments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends courseEnrollmentsUpdateArgs>(args: SelectSubset<T, courseEnrollmentsUpdateArgs<ExtArgs>>): Prisma__courseEnrollmentsClient<$Result.GetResult<Prisma.$courseEnrollmentsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CourseEnrollments.
     * @param {courseEnrollmentsDeleteManyArgs} args - Arguments to filter CourseEnrollments to delete.
     * @example
     * // Delete a few CourseEnrollments
     * const { count } = await prisma.courseEnrollments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends courseEnrollmentsDeleteManyArgs>(args?: SelectSubset<T, courseEnrollmentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseEnrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {courseEnrollmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseEnrollments
     * const courseEnrollments = await prisma.courseEnrollments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends courseEnrollmentsUpdateManyArgs>(args: SelectSubset<T, courseEnrollmentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CourseEnrollments.
     * @param {courseEnrollmentsUpsertArgs} args - Arguments to update or create a CourseEnrollments.
     * @example
     * // Update or create a CourseEnrollments
     * const courseEnrollments = await prisma.courseEnrollments.upsert({
     *   create: {
     *     // ... data to create a CourseEnrollments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseEnrollments we want to update
     *   }
     * })
     */
    upsert<T extends courseEnrollmentsUpsertArgs>(args: SelectSubset<T, courseEnrollmentsUpsertArgs<ExtArgs>>): Prisma__courseEnrollmentsClient<$Result.GetResult<Prisma.$courseEnrollmentsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CourseEnrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {courseEnrollmentsCountArgs} args - Arguments to filter CourseEnrollments to count.
     * @example
     * // Count the number of CourseEnrollments
     * const count = await prisma.courseEnrollments.count({
     *   where: {
     *     // ... the filter for the CourseEnrollments we want to count
     *   }
     * })
    **/
    count<T extends courseEnrollmentsCountArgs>(
      args?: Subset<T, courseEnrollmentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseEnrollmentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseEnrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseEnrollmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseEnrollmentsAggregateArgs>(args: Subset<T, CourseEnrollmentsAggregateArgs>): Prisma.PrismaPromise<GetCourseEnrollmentsAggregateType<T>>

    /**
     * Group by CourseEnrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {courseEnrollmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends courseEnrollmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: courseEnrollmentsGroupByArgs['orderBy'] }
        : { orderBy?: courseEnrollmentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, courseEnrollmentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseEnrollmentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the courseEnrollments model
   */
  readonly fields: courseEnrollmentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for courseEnrollments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__courseEnrollmentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends coursesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, coursesDefaultArgs<ExtArgs>>): Prisma__coursesClient<$Result.GetResult<Prisma.$coursesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the courseEnrollments model
   */ 
  interface courseEnrollmentsFieldRefs {
    readonly id: FieldRef<"courseEnrollments", 'String'>
    readonly courseId: FieldRef<"courseEnrollments", 'String'>
    readonly userId: FieldRef<"courseEnrollments", 'String'>
    readonly progressPercent: FieldRef<"courseEnrollments", 'Float'>
    readonly enrolledAt: FieldRef<"courseEnrollments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * courseEnrollments findUnique
   */
  export type courseEnrollmentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courseEnrollments
     */
    select?: courseEnrollmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: courseEnrollmentsInclude<ExtArgs> | null
    /**
     * Filter, which courseEnrollments to fetch.
     */
    where: courseEnrollmentsWhereUniqueInput
  }

  /**
   * courseEnrollments findUniqueOrThrow
   */
  export type courseEnrollmentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courseEnrollments
     */
    select?: courseEnrollmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: courseEnrollmentsInclude<ExtArgs> | null
    /**
     * Filter, which courseEnrollments to fetch.
     */
    where: courseEnrollmentsWhereUniqueInput
  }

  /**
   * courseEnrollments findFirst
   */
  export type courseEnrollmentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courseEnrollments
     */
    select?: courseEnrollmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: courseEnrollmentsInclude<ExtArgs> | null
    /**
     * Filter, which courseEnrollments to fetch.
     */
    where?: courseEnrollmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of courseEnrollments to fetch.
     */
    orderBy?: courseEnrollmentsOrderByWithRelationInput | courseEnrollmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for courseEnrollments.
     */
    cursor?: courseEnrollmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` courseEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` courseEnrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of courseEnrollments.
     */
    distinct?: CourseEnrollmentsScalarFieldEnum | CourseEnrollmentsScalarFieldEnum[]
  }

  /**
   * courseEnrollments findFirstOrThrow
   */
  export type courseEnrollmentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courseEnrollments
     */
    select?: courseEnrollmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: courseEnrollmentsInclude<ExtArgs> | null
    /**
     * Filter, which courseEnrollments to fetch.
     */
    where?: courseEnrollmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of courseEnrollments to fetch.
     */
    orderBy?: courseEnrollmentsOrderByWithRelationInput | courseEnrollmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for courseEnrollments.
     */
    cursor?: courseEnrollmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` courseEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` courseEnrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of courseEnrollments.
     */
    distinct?: CourseEnrollmentsScalarFieldEnum | CourseEnrollmentsScalarFieldEnum[]
  }

  /**
   * courseEnrollments findMany
   */
  export type courseEnrollmentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courseEnrollments
     */
    select?: courseEnrollmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: courseEnrollmentsInclude<ExtArgs> | null
    /**
     * Filter, which courseEnrollments to fetch.
     */
    where?: courseEnrollmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of courseEnrollments to fetch.
     */
    orderBy?: courseEnrollmentsOrderByWithRelationInput | courseEnrollmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing courseEnrollments.
     */
    cursor?: courseEnrollmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` courseEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` courseEnrollments.
     */
    skip?: number
    distinct?: CourseEnrollmentsScalarFieldEnum | CourseEnrollmentsScalarFieldEnum[]
  }

  /**
   * courseEnrollments create
   */
  export type courseEnrollmentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courseEnrollments
     */
    select?: courseEnrollmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: courseEnrollmentsInclude<ExtArgs> | null
    /**
     * The data needed to create a courseEnrollments.
     */
    data: XOR<courseEnrollmentsCreateInput, courseEnrollmentsUncheckedCreateInput>
  }

  /**
   * courseEnrollments createMany
   */
  export type courseEnrollmentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many courseEnrollments.
     */
    data: courseEnrollmentsCreateManyInput | courseEnrollmentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * courseEnrollments createManyAndReturn
   */
  export type courseEnrollmentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courseEnrollments
     */
    select?: courseEnrollmentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many courseEnrollments.
     */
    data: courseEnrollmentsCreateManyInput | courseEnrollmentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: courseEnrollmentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * courseEnrollments update
   */
  export type courseEnrollmentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courseEnrollments
     */
    select?: courseEnrollmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: courseEnrollmentsInclude<ExtArgs> | null
    /**
     * The data needed to update a courseEnrollments.
     */
    data: XOR<courseEnrollmentsUpdateInput, courseEnrollmentsUncheckedUpdateInput>
    /**
     * Choose, which courseEnrollments to update.
     */
    where: courseEnrollmentsWhereUniqueInput
  }

  /**
   * courseEnrollments updateMany
   */
  export type courseEnrollmentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update courseEnrollments.
     */
    data: XOR<courseEnrollmentsUpdateManyMutationInput, courseEnrollmentsUncheckedUpdateManyInput>
    /**
     * Filter which courseEnrollments to update
     */
    where?: courseEnrollmentsWhereInput
  }

  /**
   * courseEnrollments upsert
   */
  export type courseEnrollmentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courseEnrollments
     */
    select?: courseEnrollmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: courseEnrollmentsInclude<ExtArgs> | null
    /**
     * The filter to search for the courseEnrollments to update in case it exists.
     */
    where: courseEnrollmentsWhereUniqueInput
    /**
     * In case the courseEnrollments found by the `where` argument doesn't exist, create a new courseEnrollments with this data.
     */
    create: XOR<courseEnrollmentsCreateInput, courseEnrollmentsUncheckedCreateInput>
    /**
     * In case the courseEnrollments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<courseEnrollmentsUpdateInput, courseEnrollmentsUncheckedUpdateInput>
  }

  /**
   * courseEnrollments delete
   */
  export type courseEnrollmentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courseEnrollments
     */
    select?: courseEnrollmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: courseEnrollmentsInclude<ExtArgs> | null
    /**
     * Filter which courseEnrollments to delete.
     */
    where: courseEnrollmentsWhereUniqueInput
  }

  /**
   * courseEnrollments deleteMany
   */
  export type courseEnrollmentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which courseEnrollments to delete
     */
    where?: courseEnrollmentsWhereInput
  }

  /**
   * courseEnrollments without action
   */
  export type courseEnrollmentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courseEnrollments
     */
    select?: courseEnrollmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: courseEnrollmentsInclude<ExtArgs> | null
  }


  /**
   * Model mentors
   */

  export type AggregateMentors = {
    _count: MentorsCountAggregateOutputType | null
    _avg: MentorsAvgAggregateOutputType | null
    _sum: MentorsSumAggregateOutputType | null
    _min: MentorsMinAggregateOutputType | null
    _max: MentorsMaxAggregateOutputType | null
  }

  export type MentorsAvgAggregateOutputType = {
    rating: number | null
  }

  export type MentorsSumAggregateOutputType = {
    rating: number | null
  }

  export type MentorsMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    rating: number | null
    bio: string | null
  }

  export type MentorsMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    rating: number | null
    bio: string | null
  }

  export type MentorsCountAggregateOutputType = {
    id: number
    user_id: number
    expertise: number
    rating: number
    bio: number
    _all: number
  }


  export type MentorsAvgAggregateInputType = {
    rating?: true
  }

  export type MentorsSumAggregateInputType = {
    rating?: true
  }

  export type MentorsMinAggregateInputType = {
    id?: true
    user_id?: true
    rating?: true
    bio?: true
  }

  export type MentorsMaxAggregateInputType = {
    id?: true
    user_id?: true
    rating?: true
    bio?: true
  }

  export type MentorsCountAggregateInputType = {
    id?: true
    user_id?: true
    expertise?: true
    rating?: true
    bio?: true
    _all?: true
  }

  export type MentorsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mentors to aggregate.
     */
    where?: mentorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mentors to fetch.
     */
    orderBy?: mentorsOrderByWithRelationInput | mentorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: mentorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mentors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mentors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mentors
    **/
    _count?: true | MentorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MentorsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MentorsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MentorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MentorsMaxAggregateInputType
  }

  export type GetMentorsAggregateType<T extends MentorsAggregateArgs> = {
        [P in keyof T & keyof AggregateMentors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMentors[P]>
      : GetScalarType<T[P], AggregateMentors[P]>
  }




  export type mentorsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mentorsWhereInput
    orderBy?: mentorsOrderByWithAggregationInput | mentorsOrderByWithAggregationInput[]
    by: MentorsScalarFieldEnum[] | MentorsScalarFieldEnum
    having?: mentorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MentorsCountAggregateInputType | true
    _avg?: MentorsAvgAggregateInputType
    _sum?: MentorsSumAggregateInputType
    _min?: MentorsMinAggregateInputType
    _max?: MentorsMaxAggregateInputType
  }

  export type MentorsGroupByOutputType = {
    id: string
    user_id: string
    expertise: JsonValue | null
    rating: number | null
    bio: string | null
    _count: MentorsCountAggregateOutputType | null
    _avg: MentorsAvgAggregateOutputType | null
    _sum: MentorsSumAggregateOutputType | null
    _min: MentorsMinAggregateOutputType | null
    _max: MentorsMaxAggregateOutputType | null
  }

  type GetMentorsGroupByPayload<T extends mentorsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MentorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MentorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MentorsGroupByOutputType[P]>
            : GetScalarType<T[P], MentorsGroupByOutputType[P]>
        }
      >
    >


  export type mentorsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    expertise?: boolean
    rating?: boolean
    bio?: boolean
    reviews?: boolean | mentors$reviewsArgs<ExtArgs>
    sessions?: boolean | mentors$sessionsArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | MentorsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentors"]>

  export type mentorsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    expertise?: boolean
    rating?: boolean
    bio?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentors"]>

  export type mentorsSelectScalar = {
    id?: boolean
    user_id?: boolean
    expertise?: boolean
    rating?: boolean
    bio?: boolean
  }

  export type mentorsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviews?: boolean | mentors$reviewsArgs<ExtArgs>
    sessions?: boolean | mentors$sessionsArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | MentorsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type mentorsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $mentorsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "mentors"
    objects: {
      reviews: Prisma.$mentorReviewsPayload<ExtArgs>[]
      sessions: Prisma.$mentorSessionsPayload<ExtArgs>[]
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      expertise: Prisma.JsonValue | null
      rating: number | null
      bio: string | null
    }, ExtArgs["result"]["mentors"]>
    composites: {}
  }

  type mentorsGetPayload<S extends boolean | null | undefined | mentorsDefaultArgs> = $Result.GetResult<Prisma.$mentorsPayload, S>

  type mentorsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<mentorsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MentorsCountAggregateInputType | true
    }

  export interface mentorsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['mentors'], meta: { name: 'mentors' } }
    /**
     * Find zero or one Mentors that matches the filter.
     * @param {mentorsFindUniqueArgs} args - Arguments to find a Mentors
     * @example
     * // Get one Mentors
     * const mentors = await prisma.mentors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends mentorsFindUniqueArgs>(args: SelectSubset<T, mentorsFindUniqueArgs<ExtArgs>>): Prisma__mentorsClient<$Result.GetResult<Prisma.$mentorsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Mentors that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {mentorsFindUniqueOrThrowArgs} args - Arguments to find a Mentors
     * @example
     * // Get one Mentors
     * const mentors = await prisma.mentors.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends mentorsFindUniqueOrThrowArgs>(args: SelectSubset<T, mentorsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__mentorsClient<$Result.GetResult<Prisma.$mentorsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Mentors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mentorsFindFirstArgs} args - Arguments to find a Mentors
     * @example
     * // Get one Mentors
     * const mentors = await prisma.mentors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends mentorsFindFirstArgs>(args?: SelectSubset<T, mentorsFindFirstArgs<ExtArgs>>): Prisma__mentorsClient<$Result.GetResult<Prisma.$mentorsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Mentors that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mentorsFindFirstOrThrowArgs} args - Arguments to find a Mentors
     * @example
     * // Get one Mentors
     * const mentors = await prisma.mentors.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends mentorsFindFirstOrThrowArgs>(args?: SelectSubset<T, mentorsFindFirstOrThrowArgs<ExtArgs>>): Prisma__mentorsClient<$Result.GetResult<Prisma.$mentorsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Mentors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mentorsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mentors
     * const mentors = await prisma.mentors.findMany()
     * 
     * // Get first 10 Mentors
     * const mentors = await prisma.mentors.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mentorsWithIdOnly = await prisma.mentors.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends mentorsFindManyArgs>(args?: SelectSubset<T, mentorsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mentorsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Mentors.
     * @param {mentorsCreateArgs} args - Arguments to create a Mentors.
     * @example
     * // Create one Mentors
     * const Mentors = await prisma.mentors.create({
     *   data: {
     *     // ... data to create a Mentors
     *   }
     * })
     * 
     */
    create<T extends mentorsCreateArgs>(args: SelectSubset<T, mentorsCreateArgs<ExtArgs>>): Prisma__mentorsClient<$Result.GetResult<Prisma.$mentorsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Mentors.
     * @param {mentorsCreateManyArgs} args - Arguments to create many Mentors.
     * @example
     * // Create many Mentors
     * const mentors = await prisma.mentors.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends mentorsCreateManyArgs>(args?: SelectSubset<T, mentorsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Mentors and returns the data saved in the database.
     * @param {mentorsCreateManyAndReturnArgs} args - Arguments to create many Mentors.
     * @example
     * // Create many Mentors
     * const mentors = await prisma.mentors.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Mentors and only return the `id`
     * const mentorsWithIdOnly = await prisma.mentors.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends mentorsCreateManyAndReturnArgs>(args?: SelectSubset<T, mentorsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mentorsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Mentors.
     * @param {mentorsDeleteArgs} args - Arguments to delete one Mentors.
     * @example
     * // Delete one Mentors
     * const Mentors = await prisma.mentors.delete({
     *   where: {
     *     // ... filter to delete one Mentors
     *   }
     * })
     * 
     */
    delete<T extends mentorsDeleteArgs>(args: SelectSubset<T, mentorsDeleteArgs<ExtArgs>>): Prisma__mentorsClient<$Result.GetResult<Prisma.$mentorsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Mentors.
     * @param {mentorsUpdateArgs} args - Arguments to update one Mentors.
     * @example
     * // Update one Mentors
     * const mentors = await prisma.mentors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends mentorsUpdateArgs>(args: SelectSubset<T, mentorsUpdateArgs<ExtArgs>>): Prisma__mentorsClient<$Result.GetResult<Prisma.$mentorsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Mentors.
     * @param {mentorsDeleteManyArgs} args - Arguments to filter Mentors to delete.
     * @example
     * // Delete a few Mentors
     * const { count } = await prisma.mentors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends mentorsDeleteManyArgs>(args?: SelectSubset<T, mentorsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mentors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mentorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mentors
     * const mentors = await prisma.mentors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends mentorsUpdateManyArgs>(args: SelectSubset<T, mentorsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Mentors.
     * @param {mentorsUpsertArgs} args - Arguments to update or create a Mentors.
     * @example
     * // Update or create a Mentors
     * const mentors = await prisma.mentors.upsert({
     *   create: {
     *     // ... data to create a Mentors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mentors we want to update
     *   }
     * })
     */
    upsert<T extends mentorsUpsertArgs>(args: SelectSubset<T, mentorsUpsertArgs<ExtArgs>>): Prisma__mentorsClient<$Result.GetResult<Prisma.$mentorsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Mentors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mentorsCountArgs} args - Arguments to filter Mentors to count.
     * @example
     * // Count the number of Mentors
     * const count = await prisma.mentors.count({
     *   where: {
     *     // ... the filter for the Mentors we want to count
     *   }
     * })
    **/
    count<T extends mentorsCountArgs>(
      args?: Subset<T, mentorsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MentorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mentors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MentorsAggregateArgs>(args: Subset<T, MentorsAggregateArgs>): Prisma.PrismaPromise<GetMentorsAggregateType<T>>

    /**
     * Group by Mentors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mentorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends mentorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: mentorsGroupByArgs['orderBy'] }
        : { orderBy?: mentorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, mentorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMentorsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the mentors model
   */
  readonly fields: mentorsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for mentors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__mentorsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reviews<T extends mentors$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, mentors$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mentorReviewsPayload<ExtArgs>, T, "findMany"> | Null>
    sessions<T extends mentors$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, mentors$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mentorSessionsPayload<ExtArgs>, T, "findMany"> | Null>
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the mentors model
   */ 
  interface mentorsFieldRefs {
    readonly id: FieldRef<"mentors", 'String'>
    readonly user_id: FieldRef<"mentors", 'String'>
    readonly expertise: FieldRef<"mentors", 'Json'>
    readonly rating: FieldRef<"mentors", 'Float'>
    readonly bio: FieldRef<"mentors", 'String'>
  }
    

  // Custom InputTypes
  /**
   * mentors findUnique
   */
  export type mentorsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mentors
     */
    select?: mentorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mentorsInclude<ExtArgs> | null
    /**
     * Filter, which mentors to fetch.
     */
    where: mentorsWhereUniqueInput
  }

  /**
   * mentors findUniqueOrThrow
   */
  export type mentorsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mentors
     */
    select?: mentorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mentorsInclude<ExtArgs> | null
    /**
     * Filter, which mentors to fetch.
     */
    where: mentorsWhereUniqueInput
  }

  /**
   * mentors findFirst
   */
  export type mentorsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mentors
     */
    select?: mentorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mentorsInclude<ExtArgs> | null
    /**
     * Filter, which mentors to fetch.
     */
    where?: mentorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mentors to fetch.
     */
    orderBy?: mentorsOrderByWithRelationInput | mentorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mentors.
     */
    cursor?: mentorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mentors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mentors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mentors.
     */
    distinct?: MentorsScalarFieldEnum | MentorsScalarFieldEnum[]
  }

  /**
   * mentors findFirstOrThrow
   */
  export type mentorsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mentors
     */
    select?: mentorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mentorsInclude<ExtArgs> | null
    /**
     * Filter, which mentors to fetch.
     */
    where?: mentorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mentors to fetch.
     */
    orderBy?: mentorsOrderByWithRelationInput | mentorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mentors.
     */
    cursor?: mentorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mentors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mentors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mentors.
     */
    distinct?: MentorsScalarFieldEnum | MentorsScalarFieldEnum[]
  }

  /**
   * mentors findMany
   */
  export type mentorsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mentors
     */
    select?: mentorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mentorsInclude<ExtArgs> | null
    /**
     * Filter, which mentors to fetch.
     */
    where?: mentorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mentors to fetch.
     */
    orderBy?: mentorsOrderByWithRelationInput | mentorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mentors.
     */
    cursor?: mentorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mentors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mentors.
     */
    skip?: number
    distinct?: MentorsScalarFieldEnum | MentorsScalarFieldEnum[]
  }

  /**
   * mentors create
   */
  export type mentorsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mentors
     */
    select?: mentorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mentorsInclude<ExtArgs> | null
    /**
     * The data needed to create a mentors.
     */
    data: XOR<mentorsCreateInput, mentorsUncheckedCreateInput>
  }

  /**
   * mentors createMany
   */
  export type mentorsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many mentors.
     */
    data: mentorsCreateManyInput | mentorsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * mentors createManyAndReturn
   */
  export type mentorsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mentors
     */
    select?: mentorsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many mentors.
     */
    data: mentorsCreateManyInput | mentorsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mentorsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * mentors update
   */
  export type mentorsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mentors
     */
    select?: mentorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mentorsInclude<ExtArgs> | null
    /**
     * The data needed to update a mentors.
     */
    data: XOR<mentorsUpdateInput, mentorsUncheckedUpdateInput>
    /**
     * Choose, which mentors to update.
     */
    where: mentorsWhereUniqueInput
  }

  /**
   * mentors updateMany
   */
  export type mentorsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update mentors.
     */
    data: XOR<mentorsUpdateManyMutationInput, mentorsUncheckedUpdateManyInput>
    /**
     * Filter which mentors to update
     */
    where?: mentorsWhereInput
  }

  /**
   * mentors upsert
   */
  export type mentorsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mentors
     */
    select?: mentorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mentorsInclude<ExtArgs> | null
    /**
     * The filter to search for the mentors to update in case it exists.
     */
    where: mentorsWhereUniqueInput
    /**
     * In case the mentors found by the `where` argument doesn't exist, create a new mentors with this data.
     */
    create: XOR<mentorsCreateInput, mentorsUncheckedCreateInput>
    /**
     * In case the mentors was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mentorsUpdateInput, mentorsUncheckedUpdateInput>
  }

  /**
   * mentors delete
   */
  export type mentorsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mentors
     */
    select?: mentorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mentorsInclude<ExtArgs> | null
    /**
     * Filter which mentors to delete.
     */
    where: mentorsWhereUniqueInput
  }

  /**
   * mentors deleteMany
   */
  export type mentorsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mentors to delete
     */
    where?: mentorsWhereInput
  }

  /**
   * mentors.reviews
   */
  export type mentors$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mentorReviews
     */
    select?: mentorReviewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mentorReviewsInclude<ExtArgs> | null
    where?: mentorReviewsWhereInput
    orderBy?: mentorReviewsOrderByWithRelationInput | mentorReviewsOrderByWithRelationInput[]
    cursor?: mentorReviewsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MentorReviewsScalarFieldEnum | MentorReviewsScalarFieldEnum[]
  }

  /**
   * mentors.sessions
   */
  export type mentors$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mentorSessions
     */
    select?: mentorSessionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mentorSessionsInclude<ExtArgs> | null
    where?: mentorSessionsWhereInput
    orderBy?: mentorSessionsOrderByWithRelationInput | mentorSessionsOrderByWithRelationInput[]
    cursor?: mentorSessionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MentorSessionsScalarFieldEnum | MentorSessionsScalarFieldEnum[]
  }

  /**
   * mentors without action
   */
  export type mentorsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mentors
     */
    select?: mentorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mentorsInclude<ExtArgs> | null
  }


  /**
   * Model mentorSessions
   */

  export type AggregateMentorSessions = {
    _count: MentorSessionsCountAggregateOutputType | null
    _min: MentorSessionsMinAggregateOutputType | null
    _max: MentorSessionsMaxAggregateOutputType | null
  }

  export type MentorSessionsMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    mentorId: string | null
    scheduled_at: Date | null
    status: $Enums.MentorSessionStatus | null
    meeting_link: string | null
  }

  export type MentorSessionsMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    mentorId: string | null
    scheduled_at: Date | null
    status: $Enums.MentorSessionStatus | null
    meeting_link: string | null
  }

  export type MentorSessionsCountAggregateOutputType = {
    id: number
    studentId: number
    mentorId: number
    scheduled_at: number
    status: number
    meeting_link: number
    _all: number
  }


  export type MentorSessionsMinAggregateInputType = {
    id?: true
    studentId?: true
    mentorId?: true
    scheduled_at?: true
    status?: true
    meeting_link?: true
  }

  export type MentorSessionsMaxAggregateInputType = {
    id?: true
    studentId?: true
    mentorId?: true
    scheduled_at?: true
    status?: true
    meeting_link?: true
  }

  export type MentorSessionsCountAggregateInputType = {
    id?: true
    studentId?: true
    mentorId?: true
    scheduled_at?: true
    status?: true
    meeting_link?: true
    _all?: true
  }

  export type MentorSessionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mentorSessions to aggregate.
     */
    where?: mentorSessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mentorSessions to fetch.
     */
    orderBy?: mentorSessionsOrderByWithRelationInput | mentorSessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: mentorSessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mentorSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mentorSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mentorSessions
    **/
    _count?: true | MentorSessionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MentorSessionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MentorSessionsMaxAggregateInputType
  }

  export type GetMentorSessionsAggregateType<T extends MentorSessionsAggregateArgs> = {
        [P in keyof T & keyof AggregateMentorSessions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMentorSessions[P]>
      : GetScalarType<T[P], AggregateMentorSessions[P]>
  }




  export type mentorSessionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mentorSessionsWhereInput
    orderBy?: mentorSessionsOrderByWithAggregationInput | mentorSessionsOrderByWithAggregationInput[]
    by: MentorSessionsScalarFieldEnum[] | MentorSessionsScalarFieldEnum
    having?: mentorSessionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MentorSessionsCountAggregateInputType | true
    _min?: MentorSessionsMinAggregateInputType
    _max?: MentorSessionsMaxAggregateInputType
  }

  export type MentorSessionsGroupByOutputType = {
    id: string
    studentId: string
    mentorId: string
    scheduled_at: Date
    status: $Enums.MentorSessionStatus
    meeting_link: string | null
    _count: MentorSessionsCountAggregateOutputType | null
    _min: MentorSessionsMinAggregateOutputType | null
    _max: MentorSessionsMaxAggregateOutputType | null
  }

  type GetMentorSessionsGroupByPayload<T extends mentorSessionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MentorSessionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MentorSessionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MentorSessionsGroupByOutputType[P]>
            : GetScalarType<T[P], MentorSessionsGroupByOutputType[P]>
        }
      >
    >


  export type mentorSessionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    mentorId?: boolean
    scheduled_at?: boolean
    status?: boolean
    meeting_link?: boolean
    mentor?: boolean | mentorsDefaultArgs<ExtArgs>
    student?: boolean | profileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentorSessions"]>

  export type mentorSessionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    mentorId?: boolean
    scheduled_at?: boolean
    status?: boolean
    meeting_link?: boolean
    mentor?: boolean | mentorsDefaultArgs<ExtArgs>
    student?: boolean | profileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentorSessions"]>

  export type mentorSessionsSelectScalar = {
    id?: boolean
    studentId?: boolean
    mentorId?: boolean
    scheduled_at?: boolean
    status?: boolean
    meeting_link?: boolean
  }

  export type mentorSessionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentor?: boolean | mentorsDefaultArgs<ExtArgs>
    student?: boolean | profileDefaultArgs<ExtArgs>
  }
  export type mentorSessionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentor?: boolean | mentorsDefaultArgs<ExtArgs>
    student?: boolean | profileDefaultArgs<ExtArgs>
  }

  export type $mentorSessionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "mentorSessions"
    objects: {
      mentor: Prisma.$mentorsPayload<ExtArgs>
      student: Prisma.$profilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      mentorId: string
      scheduled_at: Date
      status: $Enums.MentorSessionStatus
      meeting_link: string | null
    }, ExtArgs["result"]["mentorSessions"]>
    composites: {}
  }

  type mentorSessionsGetPayload<S extends boolean | null | undefined | mentorSessionsDefaultArgs> = $Result.GetResult<Prisma.$mentorSessionsPayload, S>

  type mentorSessionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<mentorSessionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MentorSessionsCountAggregateInputType | true
    }

  export interface mentorSessionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['mentorSessions'], meta: { name: 'mentorSessions' } }
    /**
     * Find zero or one MentorSessions that matches the filter.
     * @param {mentorSessionsFindUniqueArgs} args - Arguments to find a MentorSessions
     * @example
     * // Get one MentorSessions
     * const mentorSessions = await prisma.mentorSessions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends mentorSessionsFindUniqueArgs>(args: SelectSubset<T, mentorSessionsFindUniqueArgs<ExtArgs>>): Prisma__mentorSessionsClient<$Result.GetResult<Prisma.$mentorSessionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MentorSessions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {mentorSessionsFindUniqueOrThrowArgs} args - Arguments to find a MentorSessions
     * @example
     * // Get one MentorSessions
     * const mentorSessions = await prisma.mentorSessions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends mentorSessionsFindUniqueOrThrowArgs>(args: SelectSubset<T, mentorSessionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__mentorSessionsClient<$Result.GetResult<Prisma.$mentorSessionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MentorSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mentorSessionsFindFirstArgs} args - Arguments to find a MentorSessions
     * @example
     * // Get one MentorSessions
     * const mentorSessions = await prisma.mentorSessions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends mentorSessionsFindFirstArgs>(args?: SelectSubset<T, mentorSessionsFindFirstArgs<ExtArgs>>): Prisma__mentorSessionsClient<$Result.GetResult<Prisma.$mentorSessionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MentorSessions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mentorSessionsFindFirstOrThrowArgs} args - Arguments to find a MentorSessions
     * @example
     * // Get one MentorSessions
     * const mentorSessions = await prisma.mentorSessions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends mentorSessionsFindFirstOrThrowArgs>(args?: SelectSubset<T, mentorSessionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__mentorSessionsClient<$Result.GetResult<Prisma.$mentorSessionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MentorSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mentorSessionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MentorSessions
     * const mentorSessions = await prisma.mentorSessions.findMany()
     * 
     * // Get first 10 MentorSessions
     * const mentorSessions = await prisma.mentorSessions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mentorSessionsWithIdOnly = await prisma.mentorSessions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends mentorSessionsFindManyArgs>(args?: SelectSubset<T, mentorSessionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mentorSessionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MentorSessions.
     * @param {mentorSessionsCreateArgs} args - Arguments to create a MentorSessions.
     * @example
     * // Create one MentorSessions
     * const MentorSessions = await prisma.mentorSessions.create({
     *   data: {
     *     // ... data to create a MentorSessions
     *   }
     * })
     * 
     */
    create<T extends mentorSessionsCreateArgs>(args: SelectSubset<T, mentorSessionsCreateArgs<ExtArgs>>): Prisma__mentorSessionsClient<$Result.GetResult<Prisma.$mentorSessionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MentorSessions.
     * @param {mentorSessionsCreateManyArgs} args - Arguments to create many MentorSessions.
     * @example
     * // Create many MentorSessions
     * const mentorSessions = await prisma.mentorSessions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends mentorSessionsCreateManyArgs>(args?: SelectSubset<T, mentorSessionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MentorSessions and returns the data saved in the database.
     * @param {mentorSessionsCreateManyAndReturnArgs} args - Arguments to create many MentorSessions.
     * @example
     * // Create many MentorSessions
     * const mentorSessions = await prisma.mentorSessions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MentorSessions and only return the `id`
     * const mentorSessionsWithIdOnly = await prisma.mentorSessions.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends mentorSessionsCreateManyAndReturnArgs>(args?: SelectSubset<T, mentorSessionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mentorSessionsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MentorSessions.
     * @param {mentorSessionsDeleteArgs} args - Arguments to delete one MentorSessions.
     * @example
     * // Delete one MentorSessions
     * const MentorSessions = await prisma.mentorSessions.delete({
     *   where: {
     *     // ... filter to delete one MentorSessions
     *   }
     * })
     * 
     */
    delete<T extends mentorSessionsDeleteArgs>(args: SelectSubset<T, mentorSessionsDeleteArgs<ExtArgs>>): Prisma__mentorSessionsClient<$Result.GetResult<Prisma.$mentorSessionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MentorSessions.
     * @param {mentorSessionsUpdateArgs} args - Arguments to update one MentorSessions.
     * @example
     * // Update one MentorSessions
     * const mentorSessions = await prisma.mentorSessions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends mentorSessionsUpdateArgs>(args: SelectSubset<T, mentorSessionsUpdateArgs<ExtArgs>>): Prisma__mentorSessionsClient<$Result.GetResult<Prisma.$mentorSessionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MentorSessions.
     * @param {mentorSessionsDeleteManyArgs} args - Arguments to filter MentorSessions to delete.
     * @example
     * // Delete a few MentorSessions
     * const { count } = await prisma.mentorSessions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends mentorSessionsDeleteManyArgs>(args?: SelectSubset<T, mentorSessionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MentorSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mentorSessionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MentorSessions
     * const mentorSessions = await prisma.mentorSessions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends mentorSessionsUpdateManyArgs>(args: SelectSubset<T, mentorSessionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MentorSessions.
     * @param {mentorSessionsUpsertArgs} args - Arguments to update or create a MentorSessions.
     * @example
     * // Update or create a MentorSessions
     * const mentorSessions = await prisma.mentorSessions.upsert({
     *   create: {
     *     // ... data to create a MentorSessions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MentorSessions we want to update
     *   }
     * })
     */
    upsert<T extends mentorSessionsUpsertArgs>(args: SelectSubset<T, mentorSessionsUpsertArgs<ExtArgs>>): Prisma__mentorSessionsClient<$Result.GetResult<Prisma.$mentorSessionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MentorSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mentorSessionsCountArgs} args - Arguments to filter MentorSessions to count.
     * @example
     * // Count the number of MentorSessions
     * const count = await prisma.mentorSessions.count({
     *   where: {
     *     // ... the filter for the MentorSessions we want to count
     *   }
     * })
    **/
    count<T extends mentorSessionsCountArgs>(
      args?: Subset<T, mentorSessionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MentorSessionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MentorSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorSessionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MentorSessionsAggregateArgs>(args: Subset<T, MentorSessionsAggregateArgs>): Prisma.PrismaPromise<GetMentorSessionsAggregateType<T>>

    /**
     * Group by MentorSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mentorSessionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends mentorSessionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: mentorSessionsGroupByArgs['orderBy'] }
        : { orderBy?: mentorSessionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, mentorSessionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMentorSessionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the mentorSessions model
   */
  readonly fields: mentorSessionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for mentorSessions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__mentorSessionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mentor<T extends mentorsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, mentorsDefaultArgs<ExtArgs>>): Prisma__mentorsClient<$Result.GetResult<Prisma.$mentorsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    student<T extends profileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, profileDefaultArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the mentorSessions model
   */ 
  interface mentorSessionsFieldRefs {
    readonly id: FieldRef<"mentorSessions", 'String'>
    readonly studentId: FieldRef<"mentorSessions", 'String'>
    readonly mentorId: FieldRef<"mentorSessions", 'String'>
    readonly scheduled_at: FieldRef<"mentorSessions", 'DateTime'>
    readonly status: FieldRef<"mentorSessions", 'MentorSessionStatus'>
    readonly meeting_link: FieldRef<"mentorSessions", 'String'>
  }
    

  // Custom InputTypes
  /**
   * mentorSessions findUnique
   */
  export type mentorSessionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mentorSessions
     */
    select?: mentorSessionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mentorSessionsInclude<ExtArgs> | null
    /**
     * Filter, which mentorSessions to fetch.
     */
    where: mentorSessionsWhereUniqueInput
  }

  /**
   * mentorSessions findUniqueOrThrow
   */
  export type mentorSessionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mentorSessions
     */
    select?: mentorSessionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mentorSessionsInclude<ExtArgs> | null
    /**
     * Filter, which mentorSessions to fetch.
     */
    where: mentorSessionsWhereUniqueInput
  }

  /**
   * mentorSessions findFirst
   */
  export type mentorSessionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mentorSessions
     */
    select?: mentorSessionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mentorSessionsInclude<ExtArgs> | null
    /**
     * Filter, which mentorSessions to fetch.
     */
    where?: mentorSessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mentorSessions to fetch.
     */
    orderBy?: mentorSessionsOrderByWithRelationInput | mentorSessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mentorSessions.
     */
    cursor?: mentorSessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mentorSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mentorSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mentorSessions.
     */
    distinct?: MentorSessionsScalarFieldEnum | MentorSessionsScalarFieldEnum[]
  }

  /**
   * mentorSessions findFirstOrThrow
   */
  export type mentorSessionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mentorSessions
     */
    select?: mentorSessionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mentorSessionsInclude<ExtArgs> | null
    /**
     * Filter, which mentorSessions to fetch.
     */
    where?: mentorSessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mentorSessions to fetch.
     */
    orderBy?: mentorSessionsOrderByWithRelationInput | mentorSessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mentorSessions.
     */
    cursor?: mentorSessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mentorSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mentorSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mentorSessions.
     */
    distinct?: MentorSessionsScalarFieldEnum | MentorSessionsScalarFieldEnum[]
  }

  /**
   * mentorSessions findMany
   */
  export type mentorSessionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mentorSessions
     */
    select?: mentorSessionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mentorSessionsInclude<ExtArgs> | null
    /**
     * Filter, which mentorSessions to fetch.
     */
    where?: mentorSessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mentorSessions to fetch.
     */
    orderBy?: mentorSessionsOrderByWithRelationInput | mentorSessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mentorSessions.
     */
    cursor?: mentorSessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mentorSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mentorSessions.
     */
    skip?: number
    distinct?: MentorSessionsScalarFieldEnum | MentorSessionsScalarFieldEnum[]
  }

  /**
   * mentorSessions create
   */
  export type mentorSessionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mentorSessions
     */
    select?: mentorSessionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mentorSessionsInclude<ExtArgs> | null
    /**
     * The data needed to create a mentorSessions.
     */
    data: XOR<mentorSessionsCreateInput, mentorSessionsUncheckedCreateInput>
  }

  /**
   * mentorSessions createMany
   */
  export type mentorSessionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many mentorSessions.
     */
    data: mentorSessionsCreateManyInput | mentorSessionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * mentorSessions createManyAndReturn
   */
  export type mentorSessionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mentorSessions
     */
    select?: mentorSessionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many mentorSessions.
     */
    data: mentorSessionsCreateManyInput | mentorSessionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mentorSessionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * mentorSessions update
   */
  export type mentorSessionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mentorSessions
     */
    select?: mentorSessionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mentorSessionsInclude<ExtArgs> | null
    /**
     * The data needed to update a mentorSessions.
     */
    data: XOR<mentorSessionsUpdateInput, mentorSessionsUncheckedUpdateInput>
    /**
     * Choose, which mentorSessions to update.
     */
    where: mentorSessionsWhereUniqueInput
  }

  /**
   * mentorSessions updateMany
   */
  export type mentorSessionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update mentorSessions.
     */
    data: XOR<mentorSessionsUpdateManyMutationInput, mentorSessionsUncheckedUpdateManyInput>
    /**
     * Filter which mentorSessions to update
     */
    where?: mentorSessionsWhereInput
  }

  /**
   * mentorSessions upsert
   */
  export type mentorSessionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mentorSessions
     */
    select?: mentorSessionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mentorSessionsInclude<ExtArgs> | null
    /**
     * The filter to search for the mentorSessions to update in case it exists.
     */
    where: mentorSessionsWhereUniqueInput
    /**
     * In case the mentorSessions found by the `where` argument doesn't exist, create a new mentorSessions with this data.
     */
    create: XOR<mentorSessionsCreateInput, mentorSessionsUncheckedCreateInput>
    /**
     * In case the mentorSessions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mentorSessionsUpdateInput, mentorSessionsUncheckedUpdateInput>
  }

  /**
   * mentorSessions delete
   */
  export type mentorSessionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mentorSessions
     */
    select?: mentorSessionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mentorSessionsInclude<ExtArgs> | null
    /**
     * Filter which mentorSessions to delete.
     */
    where: mentorSessionsWhereUniqueInput
  }

  /**
   * mentorSessions deleteMany
   */
  export type mentorSessionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mentorSessions to delete
     */
    where?: mentorSessionsWhereInput
  }

  /**
   * mentorSessions without action
   */
  export type mentorSessionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mentorSessions
     */
    select?: mentorSessionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mentorSessionsInclude<ExtArgs> | null
  }


  /**
   * Model mentorReviews
   */

  export type AggregateMentorReviews = {
    _count: MentorReviewsCountAggregateOutputType | null
    _avg: MentorReviewsAvgAggregateOutputType | null
    _sum: MentorReviewsSumAggregateOutputType | null
    _min: MentorReviewsMinAggregateOutputType | null
    _max: MentorReviewsMaxAggregateOutputType | null
  }

  export type MentorReviewsAvgAggregateOutputType = {
    rating: number | null
  }

  export type MentorReviewsSumAggregateOutputType = {
    rating: number | null
  }

  export type MentorReviewsMinAggregateOutputType = {
    id: string | null
    mentorId: string | null
    rating: number | null
    reviews: string | null
    studentId: string | null
  }

  export type MentorReviewsMaxAggregateOutputType = {
    id: string | null
    mentorId: string | null
    rating: number | null
    reviews: string | null
    studentId: string | null
  }

  export type MentorReviewsCountAggregateOutputType = {
    id: number
    mentorId: number
    rating: number
    reviews: number
    studentId: number
    _all: number
  }


  export type MentorReviewsAvgAggregateInputType = {
    rating?: true
  }

  export type MentorReviewsSumAggregateInputType = {
    rating?: true
  }

  export type MentorReviewsMinAggregateInputType = {
    id?: true
    mentorId?: true
    rating?: true
    reviews?: true
    studentId?: true
  }

  export type MentorReviewsMaxAggregateInputType = {
    id?: true
    mentorId?: true
    rating?: true
    reviews?: true
    studentId?: true
  }

  export type MentorReviewsCountAggregateInputType = {
    id?: true
    mentorId?: true
    rating?: true
    reviews?: true
    studentId?: true
    _all?: true
  }

  export type MentorReviewsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mentorReviews to aggregate.
     */
    where?: mentorReviewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mentorReviews to fetch.
     */
    orderBy?: mentorReviewsOrderByWithRelationInput | mentorReviewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: mentorReviewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mentorReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mentorReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mentorReviews
    **/
    _count?: true | MentorReviewsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MentorReviewsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MentorReviewsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MentorReviewsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MentorReviewsMaxAggregateInputType
  }

  export type GetMentorReviewsAggregateType<T extends MentorReviewsAggregateArgs> = {
        [P in keyof T & keyof AggregateMentorReviews]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMentorReviews[P]>
      : GetScalarType<T[P], AggregateMentorReviews[P]>
  }




  export type mentorReviewsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mentorReviewsWhereInput
    orderBy?: mentorReviewsOrderByWithAggregationInput | mentorReviewsOrderByWithAggregationInput[]
    by: MentorReviewsScalarFieldEnum[] | MentorReviewsScalarFieldEnum
    having?: mentorReviewsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MentorReviewsCountAggregateInputType | true
    _avg?: MentorReviewsAvgAggregateInputType
    _sum?: MentorReviewsSumAggregateInputType
    _min?: MentorReviewsMinAggregateInputType
    _max?: MentorReviewsMaxAggregateInputType
  }

  export type MentorReviewsGroupByOutputType = {
    id: string
    mentorId: string
    rating: number
    reviews: string | null
    studentId: string
    _count: MentorReviewsCountAggregateOutputType | null
    _avg: MentorReviewsAvgAggregateOutputType | null
    _sum: MentorReviewsSumAggregateOutputType | null
    _min: MentorReviewsMinAggregateOutputType | null
    _max: MentorReviewsMaxAggregateOutputType | null
  }

  type GetMentorReviewsGroupByPayload<T extends mentorReviewsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MentorReviewsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MentorReviewsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MentorReviewsGroupByOutputType[P]>
            : GetScalarType<T[P], MentorReviewsGroupByOutputType[P]>
        }
      >
    >


  export type mentorReviewsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mentorId?: boolean
    rating?: boolean
    reviews?: boolean
    studentId?: boolean
    mentor?: boolean | mentorsDefaultArgs<ExtArgs>
    student?: boolean | profileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentorReviews"]>

  export type mentorReviewsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mentorId?: boolean
    rating?: boolean
    reviews?: boolean
    studentId?: boolean
    mentor?: boolean | mentorsDefaultArgs<ExtArgs>
    student?: boolean | profileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentorReviews"]>

  export type mentorReviewsSelectScalar = {
    id?: boolean
    mentorId?: boolean
    rating?: boolean
    reviews?: boolean
    studentId?: boolean
  }

  export type mentorReviewsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentor?: boolean | mentorsDefaultArgs<ExtArgs>
    student?: boolean | profileDefaultArgs<ExtArgs>
  }
  export type mentorReviewsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mentor?: boolean | mentorsDefaultArgs<ExtArgs>
    student?: boolean | profileDefaultArgs<ExtArgs>
  }

  export type $mentorReviewsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "mentorReviews"
    objects: {
      mentor: Prisma.$mentorsPayload<ExtArgs>
      student: Prisma.$profilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mentorId: string
      rating: number
      reviews: string | null
      studentId: string
    }, ExtArgs["result"]["mentorReviews"]>
    composites: {}
  }

  type mentorReviewsGetPayload<S extends boolean | null | undefined | mentorReviewsDefaultArgs> = $Result.GetResult<Prisma.$mentorReviewsPayload, S>

  type mentorReviewsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<mentorReviewsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MentorReviewsCountAggregateInputType | true
    }

  export interface mentorReviewsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['mentorReviews'], meta: { name: 'mentorReviews' } }
    /**
     * Find zero or one MentorReviews that matches the filter.
     * @param {mentorReviewsFindUniqueArgs} args - Arguments to find a MentorReviews
     * @example
     * // Get one MentorReviews
     * const mentorReviews = await prisma.mentorReviews.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends mentorReviewsFindUniqueArgs>(args: SelectSubset<T, mentorReviewsFindUniqueArgs<ExtArgs>>): Prisma__mentorReviewsClient<$Result.GetResult<Prisma.$mentorReviewsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MentorReviews that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {mentorReviewsFindUniqueOrThrowArgs} args - Arguments to find a MentorReviews
     * @example
     * // Get one MentorReviews
     * const mentorReviews = await prisma.mentorReviews.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends mentorReviewsFindUniqueOrThrowArgs>(args: SelectSubset<T, mentorReviewsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__mentorReviewsClient<$Result.GetResult<Prisma.$mentorReviewsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MentorReviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mentorReviewsFindFirstArgs} args - Arguments to find a MentorReviews
     * @example
     * // Get one MentorReviews
     * const mentorReviews = await prisma.mentorReviews.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends mentorReviewsFindFirstArgs>(args?: SelectSubset<T, mentorReviewsFindFirstArgs<ExtArgs>>): Prisma__mentorReviewsClient<$Result.GetResult<Prisma.$mentorReviewsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MentorReviews that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mentorReviewsFindFirstOrThrowArgs} args - Arguments to find a MentorReviews
     * @example
     * // Get one MentorReviews
     * const mentorReviews = await prisma.mentorReviews.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends mentorReviewsFindFirstOrThrowArgs>(args?: SelectSubset<T, mentorReviewsFindFirstOrThrowArgs<ExtArgs>>): Prisma__mentorReviewsClient<$Result.GetResult<Prisma.$mentorReviewsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MentorReviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mentorReviewsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MentorReviews
     * const mentorReviews = await prisma.mentorReviews.findMany()
     * 
     * // Get first 10 MentorReviews
     * const mentorReviews = await prisma.mentorReviews.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mentorReviewsWithIdOnly = await prisma.mentorReviews.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends mentorReviewsFindManyArgs>(args?: SelectSubset<T, mentorReviewsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mentorReviewsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MentorReviews.
     * @param {mentorReviewsCreateArgs} args - Arguments to create a MentorReviews.
     * @example
     * // Create one MentorReviews
     * const MentorReviews = await prisma.mentorReviews.create({
     *   data: {
     *     // ... data to create a MentorReviews
     *   }
     * })
     * 
     */
    create<T extends mentorReviewsCreateArgs>(args: SelectSubset<T, mentorReviewsCreateArgs<ExtArgs>>): Prisma__mentorReviewsClient<$Result.GetResult<Prisma.$mentorReviewsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MentorReviews.
     * @param {mentorReviewsCreateManyArgs} args - Arguments to create many MentorReviews.
     * @example
     * // Create many MentorReviews
     * const mentorReviews = await prisma.mentorReviews.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends mentorReviewsCreateManyArgs>(args?: SelectSubset<T, mentorReviewsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MentorReviews and returns the data saved in the database.
     * @param {mentorReviewsCreateManyAndReturnArgs} args - Arguments to create many MentorReviews.
     * @example
     * // Create many MentorReviews
     * const mentorReviews = await prisma.mentorReviews.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MentorReviews and only return the `id`
     * const mentorReviewsWithIdOnly = await prisma.mentorReviews.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends mentorReviewsCreateManyAndReturnArgs>(args?: SelectSubset<T, mentorReviewsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mentorReviewsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MentorReviews.
     * @param {mentorReviewsDeleteArgs} args - Arguments to delete one MentorReviews.
     * @example
     * // Delete one MentorReviews
     * const MentorReviews = await prisma.mentorReviews.delete({
     *   where: {
     *     // ... filter to delete one MentorReviews
     *   }
     * })
     * 
     */
    delete<T extends mentorReviewsDeleteArgs>(args: SelectSubset<T, mentorReviewsDeleteArgs<ExtArgs>>): Prisma__mentorReviewsClient<$Result.GetResult<Prisma.$mentorReviewsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MentorReviews.
     * @param {mentorReviewsUpdateArgs} args - Arguments to update one MentorReviews.
     * @example
     * // Update one MentorReviews
     * const mentorReviews = await prisma.mentorReviews.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends mentorReviewsUpdateArgs>(args: SelectSubset<T, mentorReviewsUpdateArgs<ExtArgs>>): Prisma__mentorReviewsClient<$Result.GetResult<Prisma.$mentorReviewsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MentorReviews.
     * @param {mentorReviewsDeleteManyArgs} args - Arguments to filter MentorReviews to delete.
     * @example
     * // Delete a few MentorReviews
     * const { count } = await prisma.mentorReviews.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends mentorReviewsDeleteManyArgs>(args?: SelectSubset<T, mentorReviewsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MentorReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mentorReviewsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MentorReviews
     * const mentorReviews = await prisma.mentorReviews.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends mentorReviewsUpdateManyArgs>(args: SelectSubset<T, mentorReviewsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MentorReviews.
     * @param {mentorReviewsUpsertArgs} args - Arguments to update or create a MentorReviews.
     * @example
     * // Update or create a MentorReviews
     * const mentorReviews = await prisma.mentorReviews.upsert({
     *   create: {
     *     // ... data to create a MentorReviews
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MentorReviews we want to update
     *   }
     * })
     */
    upsert<T extends mentorReviewsUpsertArgs>(args: SelectSubset<T, mentorReviewsUpsertArgs<ExtArgs>>): Prisma__mentorReviewsClient<$Result.GetResult<Prisma.$mentorReviewsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MentorReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mentorReviewsCountArgs} args - Arguments to filter MentorReviews to count.
     * @example
     * // Count the number of MentorReviews
     * const count = await prisma.mentorReviews.count({
     *   where: {
     *     // ... the filter for the MentorReviews we want to count
     *   }
     * })
    **/
    count<T extends mentorReviewsCountArgs>(
      args?: Subset<T, mentorReviewsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MentorReviewsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MentorReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorReviewsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MentorReviewsAggregateArgs>(args: Subset<T, MentorReviewsAggregateArgs>): Prisma.PrismaPromise<GetMentorReviewsAggregateType<T>>

    /**
     * Group by MentorReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mentorReviewsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends mentorReviewsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: mentorReviewsGroupByArgs['orderBy'] }
        : { orderBy?: mentorReviewsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, mentorReviewsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMentorReviewsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the mentorReviews model
   */
  readonly fields: mentorReviewsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for mentorReviews.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__mentorReviewsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mentor<T extends mentorsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, mentorsDefaultArgs<ExtArgs>>): Prisma__mentorsClient<$Result.GetResult<Prisma.$mentorsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    student<T extends profileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, profileDefaultArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the mentorReviews model
   */ 
  interface mentorReviewsFieldRefs {
    readonly id: FieldRef<"mentorReviews", 'String'>
    readonly mentorId: FieldRef<"mentorReviews", 'String'>
    readonly rating: FieldRef<"mentorReviews", 'Float'>
    readonly reviews: FieldRef<"mentorReviews", 'String'>
    readonly studentId: FieldRef<"mentorReviews", 'String'>
  }
    

  // Custom InputTypes
  /**
   * mentorReviews findUnique
   */
  export type mentorReviewsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mentorReviews
     */
    select?: mentorReviewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mentorReviewsInclude<ExtArgs> | null
    /**
     * Filter, which mentorReviews to fetch.
     */
    where: mentorReviewsWhereUniqueInput
  }

  /**
   * mentorReviews findUniqueOrThrow
   */
  export type mentorReviewsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mentorReviews
     */
    select?: mentorReviewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mentorReviewsInclude<ExtArgs> | null
    /**
     * Filter, which mentorReviews to fetch.
     */
    where: mentorReviewsWhereUniqueInput
  }

  /**
   * mentorReviews findFirst
   */
  export type mentorReviewsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mentorReviews
     */
    select?: mentorReviewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mentorReviewsInclude<ExtArgs> | null
    /**
     * Filter, which mentorReviews to fetch.
     */
    where?: mentorReviewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mentorReviews to fetch.
     */
    orderBy?: mentorReviewsOrderByWithRelationInput | mentorReviewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mentorReviews.
     */
    cursor?: mentorReviewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mentorReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mentorReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mentorReviews.
     */
    distinct?: MentorReviewsScalarFieldEnum | MentorReviewsScalarFieldEnum[]
  }

  /**
   * mentorReviews findFirstOrThrow
   */
  export type mentorReviewsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mentorReviews
     */
    select?: mentorReviewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mentorReviewsInclude<ExtArgs> | null
    /**
     * Filter, which mentorReviews to fetch.
     */
    where?: mentorReviewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mentorReviews to fetch.
     */
    orderBy?: mentorReviewsOrderByWithRelationInput | mentorReviewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mentorReviews.
     */
    cursor?: mentorReviewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mentorReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mentorReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mentorReviews.
     */
    distinct?: MentorReviewsScalarFieldEnum | MentorReviewsScalarFieldEnum[]
  }

  /**
   * mentorReviews findMany
   */
  export type mentorReviewsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mentorReviews
     */
    select?: mentorReviewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mentorReviewsInclude<ExtArgs> | null
    /**
     * Filter, which mentorReviews to fetch.
     */
    where?: mentorReviewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mentorReviews to fetch.
     */
    orderBy?: mentorReviewsOrderByWithRelationInput | mentorReviewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mentorReviews.
     */
    cursor?: mentorReviewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mentorReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mentorReviews.
     */
    skip?: number
    distinct?: MentorReviewsScalarFieldEnum | MentorReviewsScalarFieldEnum[]
  }

  /**
   * mentorReviews create
   */
  export type mentorReviewsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mentorReviews
     */
    select?: mentorReviewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mentorReviewsInclude<ExtArgs> | null
    /**
     * The data needed to create a mentorReviews.
     */
    data: XOR<mentorReviewsCreateInput, mentorReviewsUncheckedCreateInput>
  }

  /**
   * mentorReviews createMany
   */
  export type mentorReviewsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many mentorReviews.
     */
    data: mentorReviewsCreateManyInput | mentorReviewsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * mentorReviews createManyAndReturn
   */
  export type mentorReviewsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mentorReviews
     */
    select?: mentorReviewsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many mentorReviews.
     */
    data: mentorReviewsCreateManyInput | mentorReviewsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mentorReviewsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * mentorReviews update
   */
  export type mentorReviewsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mentorReviews
     */
    select?: mentorReviewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mentorReviewsInclude<ExtArgs> | null
    /**
     * The data needed to update a mentorReviews.
     */
    data: XOR<mentorReviewsUpdateInput, mentorReviewsUncheckedUpdateInput>
    /**
     * Choose, which mentorReviews to update.
     */
    where: mentorReviewsWhereUniqueInput
  }

  /**
   * mentorReviews updateMany
   */
  export type mentorReviewsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update mentorReviews.
     */
    data: XOR<mentorReviewsUpdateManyMutationInput, mentorReviewsUncheckedUpdateManyInput>
    /**
     * Filter which mentorReviews to update
     */
    where?: mentorReviewsWhereInput
  }

  /**
   * mentorReviews upsert
   */
  export type mentorReviewsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mentorReviews
     */
    select?: mentorReviewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mentorReviewsInclude<ExtArgs> | null
    /**
     * The filter to search for the mentorReviews to update in case it exists.
     */
    where: mentorReviewsWhereUniqueInput
    /**
     * In case the mentorReviews found by the `where` argument doesn't exist, create a new mentorReviews with this data.
     */
    create: XOR<mentorReviewsCreateInput, mentorReviewsUncheckedCreateInput>
    /**
     * In case the mentorReviews was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mentorReviewsUpdateInput, mentorReviewsUncheckedUpdateInput>
  }

  /**
   * mentorReviews delete
   */
  export type mentorReviewsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mentorReviews
     */
    select?: mentorReviewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mentorReviewsInclude<ExtArgs> | null
    /**
     * Filter which mentorReviews to delete.
     */
    where: mentorReviewsWhereUniqueInput
  }

  /**
   * mentorReviews deleteMany
   */
  export type mentorReviewsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mentorReviews to delete
     */
    where?: mentorReviewsWhereInput
  }

  /**
   * mentorReviews without action
   */
  export type mentorReviewsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mentorReviews
     */
    select?: mentorReviewsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mentorReviewsInclude<ExtArgs> | null
  }


  /**
   * Model portfolioProjects
   */

  export type AggregatePortfolioProjects = {
    _count: PortfolioProjectsCountAggregateOutputType | null
    _min: PortfolioProjectsMinAggregateOutputType | null
    _max: PortfolioProjectsMaxAggregateOutputType | null
  }

  export type PortfolioProjectsMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    title: string | null
    description: string | null
    github_url: string | null
    live_url: string | null
  }

  export type PortfolioProjectsMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    title: string | null
    description: string | null
    github_url: string | null
    live_url: string | null
  }

  export type PortfolioProjectsCountAggregateOutputType = {
    id: number
    user_id: number
    title: number
    description: number
    github_url: number
    live_url: number
    tags: number
    _all: number
  }


  export type PortfolioProjectsMinAggregateInputType = {
    id?: true
    user_id?: true
    title?: true
    description?: true
    github_url?: true
    live_url?: true
  }

  export type PortfolioProjectsMaxAggregateInputType = {
    id?: true
    user_id?: true
    title?: true
    description?: true
    github_url?: true
    live_url?: true
  }

  export type PortfolioProjectsCountAggregateInputType = {
    id?: true
    user_id?: true
    title?: true
    description?: true
    github_url?: true
    live_url?: true
    tags?: true
    _all?: true
  }

  export type PortfolioProjectsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which portfolioProjects to aggregate.
     */
    where?: portfolioProjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of portfolioProjects to fetch.
     */
    orderBy?: portfolioProjectsOrderByWithRelationInput | portfolioProjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: portfolioProjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` portfolioProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` portfolioProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned portfolioProjects
    **/
    _count?: true | PortfolioProjectsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PortfolioProjectsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PortfolioProjectsMaxAggregateInputType
  }

  export type GetPortfolioProjectsAggregateType<T extends PortfolioProjectsAggregateArgs> = {
        [P in keyof T & keyof AggregatePortfolioProjects]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePortfolioProjects[P]>
      : GetScalarType<T[P], AggregatePortfolioProjects[P]>
  }




  export type portfolioProjectsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: portfolioProjectsWhereInput
    orderBy?: portfolioProjectsOrderByWithAggregationInput | portfolioProjectsOrderByWithAggregationInput[]
    by: PortfolioProjectsScalarFieldEnum[] | PortfolioProjectsScalarFieldEnum
    having?: portfolioProjectsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PortfolioProjectsCountAggregateInputType | true
    _min?: PortfolioProjectsMinAggregateInputType
    _max?: PortfolioProjectsMaxAggregateInputType
  }

  export type PortfolioProjectsGroupByOutputType = {
    id: string
    user_id: string
    title: string
    description: string | null
    github_url: string | null
    live_url: string | null
    tags: string[]
    _count: PortfolioProjectsCountAggregateOutputType | null
    _min: PortfolioProjectsMinAggregateOutputType | null
    _max: PortfolioProjectsMaxAggregateOutputType | null
  }

  type GetPortfolioProjectsGroupByPayload<T extends portfolioProjectsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PortfolioProjectsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PortfolioProjectsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PortfolioProjectsGroupByOutputType[P]>
            : GetScalarType<T[P], PortfolioProjectsGroupByOutputType[P]>
        }
      >
    >


  export type portfolioProjectsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    title?: boolean
    description?: boolean
    github_url?: boolean
    live_url?: boolean
    tags?: boolean
    user?: boolean | profileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["portfolioProjects"]>

  export type portfolioProjectsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    title?: boolean
    description?: boolean
    github_url?: boolean
    live_url?: boolean
    tags?: boolean
    user?: boolean | profileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["portfolioProjects"]>

  export type portfolioProjectsSelectScalar = {
    id?: boolean
    user_id?: boolean
    title?: boolean
    description?: boolean
    github_url?: boolean
    live_url?: boolean
    tags?: boolean
  }

  export type portfolioProjectsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | profileDefaultArgs<ExtArgs>
  }
  export type portfolioProjectsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | profileDefaultArgs<ExtArgs>
  }

  export type $portfolioProjectsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "portfolioProjects"
    objects: {
      user: Prisma.$profilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      title: string
      description: string | null
      github_url: string | null
      live_url: string | null
      tags: string[]
    }, ExtArgs["result"]["portfolioProjects"]>
    composites: {}
  }

  type portfolioProjectsGetPayload<S extends boolean | null | undefined | portfolioProjectsDefaultArgs> = $Result.GetResult<Prisma.$portfolioProjectsPayload, S>

  type portfolioProjectsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<portfolioProjectsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PortfolioProjectsCountAggregateInputType | true
    }

  export interface portfolioProjectsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['portfolioProjects'], meta: { name: 'portfolioProjects' } }
    /**
     * Find zero or one PortfolioProjects that matches the filter.
     * @param {portfolioProjectsFindUniqueArgs} args - Arguments to find a PortfolioProjects
     * @example
     * // Get one PortfolioProjects
     * const portfolioProjects = await prisma.portfolioProjects.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends portfolioProjectsFindUniqueArgs>(args: SelectSubset<T, portfolioProjectsFindUniqueArgs<ExtArgs>>): Prisma__portfolioProjectsClient<$Result.GetResult<Prisma.$portfolioProjectsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PortfolioProjects that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {portfolioProjectsFindUniqueOrThrowArgs} args - Arguments to find a PortfolioProjects
     * @example
     * // Get one PortfolioProjects
     * const portfolioProjects = await prisma.portfolioProjects.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends portfolioProjectsFindUniqueOrThrowArgs>(args: SelectSubset<T, portfolioProjectsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__portfolioProjectsClient<$Result.GetResult<Prisma.$portfolioProjectsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PortfolioProjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {portfolioProjectsFindFirstArgs} args - Arguments to find a PortfolioProjects
     * @example
     * // Get one PortfolioProjects
     * const portfolioProjects = await prisma.portfolioProjects.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends portfolioProjectsFindFirstArgs>(args?: SelectSubset<T, portfolioProjectsFindFirstArgs<ExtArgs>>): Prisma__portfolioProjectsClient<$Result.GetResult<Prisma.$portfolioProjectsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PortfolioProjects that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {portfolioProjectsFindFirstOrThrowArgs} args - Arguments to find a PortfolioProjects
     * @example
     * // Get one PortfolioProjects
     * const portfolioProjects = await prisma.portfolioProjects.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends portfolioProjectsFindFirstOrThrowArgs>(args?: SelectSubset<T, portfolioProjectsFindFirstOrThrowArgs<ExtArgs>>): Prisma__portfolioProjectsClient<$Result.GetResult<Prisma.$portfolioProjectsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PortfolioProjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {portfolioProjectsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PortfolioProjects
     * const portfolioProjects = await prisma.portfolioProjects.findMany()
     * 
     * // Get first 10 PortfolioProjects
     * const portfolioProjects = await prisma.portfolioProjects.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const portfolioProjectsWithIdOnly = await prisma.portfolioProjects.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends portfolioProjectsFindManyArgs>(args?: SelectSubset<T, portfolioProjectsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$portfolioProjectsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PortfolioProjects.
     * @param {portfolioProjectsCreateArgs} args - Arguments to create a PortfolioProjects.
     * @example
     * // Create one PortfolioProjects
     * const PortfolioProjects = await prisma.portfolioProjects.create({
     *   data: {
     *     // ... data to create a PortfolioProjects
     *   }
     * })
     * 
     */
    create<T extends portfolioProjectsCreateArgs>(args: SelectSubset<T, portfolioProjectsCreateArgs<ExtArgs>>): Prisma__portfolioProjectsClient<$Result.GetResult<Prisma.$portfolioProjectsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PortfolioProjects.
     * @param {portfolioProjectsCreateManyArgs} args - Arguments to create many PortfolioProjects.
     * @example
     * // Create many PortfolioProjects
     * const portfolioProjects = await prisma.portfolioProjects.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends portfolioProjectsCreateManyArgs>(args?: SelectSubset<T, portfolioProjectsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PortfolioProjects and returns the data saved in the database.
     * @param {portfolioProjectsCreateManyAndReturnArgs} args - Arguments to create many PortfolioProjects.
     * @example
     * // Create many PortfolioProjects
     * const portfolioProjects = await prisma.portfolioProjects.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PortfolioProjects and only return the `id`
     * const portfolioProjectsWithIdOnly = await prisma.portfolioProjects.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends portfolioProjectsCreateManyAndReturnArgs>(args?: SelectSubset<T, portfolioProjectsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$portfolioProjectsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PortfolioProjects.
     * @param {portfolioProjectsDeleteArgs} args - Arguments to delete one PortfolioProjects.
     * @example
     * // Delete one PortfolioProjects
     * const PortfolioProjects = await prisma.portfolioProjects.delete({
     *   where: {
     *     // ... filter to delete one PortfolioProjects
     *   }
     * })
     * 
     */
    delete<T extends portfolioProjectsDeleteArgs>(args: SelectSubset<T, portfolioProjectsDeleteArgs<ExtArgs>>): Prisma__portfolioProjectsClient<$Result.GetResult<Prisma.$portfolioProjectsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PortfolioProjects.
     * @param {portfolioProjectsUpdateArgs} args - Arguments to update one PortfolioProjects.
     * @example
     * // Update one PortfolioProjects
     * const portfolioProjects = await prisma.portfolioProjects.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends portfolioProjectsUpdateArgs>(args: SelectSubset<T, portfolioProjectsUpdateArgs<ExtArgs>>): Prisma__portfolioProjectsClient<$Result.GetResult<Prisma.$portfolioProjectsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PortfolioProjects.
     * @param {portfolioProjectsDeleteManyArgs} args - Arguments to filter PortfolioProjects to delete.
     * @example
     * // Delete a few PortfolioProjects
     * const { count } = await prisma.portfolioProjects.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends portfolioProjectsDeleteManyArgs>(args?: SelectSubset<T, portfolioProjectsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PortfolioProjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {portfolioProjectsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PortfolioProjects
     * const portfolioProjects = await prisma.portfolioProjects.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends portfolioProjectsUpdateManyArgs>(args: SelectSubset<T, portfolioProjectsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PortfolioProjects.
     * @param {portfolioProjectsUpsertArgs} args - Arguments to update or create a PortfolioProjects.
     * @example
     * // Update or create a PortfolioProjects
     * const portfolioProjects = await prisma.portfolioProjects.upsert({
     *   create: {
     *     // ... data to create a PortfolioProjects
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PortfolioProjects we want to update
     *   }
     * })
     */
    upsert<T extends portfolioProjectsUpsertArgs>(args: SelectSubset<T, portfolioProjectsUpsertArgs<ExtArgs>>): Prisma__portfolioProjectsClient<$Result.GetResult<Prisma.$portfolioProjectsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PortfolioProjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {portfolioProjectsCountArgs} args - Arguments to filter PortfolioProjects to count.
     * @example
     * // Count the number of PortfolioProjects
     * const count = await prisma.portfolioProjects.count({
     *   where: {
     *     // ... the filter for the PortfolioProjects we want to count
     *   }
     * })
    **/
    count<T extends portfolioProjectsCountArgs>(
      args?: Subset<T, portfolioProjectsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PortfolioProjectsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PortfolioProjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioProjectsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PortfolioProjectsAggregateArgs>(args: Subset<T, PortfolioProjectsAggregateArgs>): Prisma.PrismaPromise<GetPortfolioProjectsAggregateType<T>>

    /**
     * Group by PortfolioProjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {portfolioProjectsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends portfolioProjectsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: portfolioProjectsGroupByArgs['orderBy'] }
        : { orderBy?: portfolioProjectsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, portfolioProjectsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPortfolioProjectsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the portfolioProjects model
   */
  readonly fields: portfolioProjectsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for portfolioProjects.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__portfolioProjectsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends profileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, profileDefaultArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the portfolioProjects model
   */ 
  interface portfolioProjectsFieldRefs {
    readonly id: FieldRef<"portfolioProjects", 'String'>
    readonly user_id: FieldRef<"portfolioProjects", 'String'>
    readonly title: FieldRef<"portfolioProjects", 'String'>
    readonly description: FieldRef<"portfolioProjects", 'String'>
    readonly github_url: FieldRef<"portfolioProjects", 'String'>
    readonly live_url: FieldRef<"portfolioProjects", 'String'>
    readonly tags: FieldRef<"portfolioProjects", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * portfolioProjects findUnique
   */
  export type portfolioProjectsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the portfolioProjects
     */
    select?: portfolioProjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: portfolioProjectsInclude<ExtArgs> | null
    /**
     * Filter, which portfolioProjects to fetch.
     */
    where: portfolioProjectsWhereUniqueInput
  }

  /**
   * portfolioProjects findUniqueOrThrow
   */
  export type portfolioProjectsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the portfolioProjects
     */
    select?: portfolioProjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: portfolioProjectsInclude<ExtArgs> | null
    /**
     * Filter, which portfolioProjects to fetch.
     */
    where: portfolioProjectsWhereUniqueInput
  }

  /**
   * portfolioProjects findFirst
   */
  export type portfolioProjectsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the portfolioProjects
     */
    select?: portfolioProjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: portfolioProjectsInclude<ExtArgs> | null
    /**
     * Filter, which portfolioProjects to fetch.
     */
    where?: portfolioProjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of portfolioProjects to fetch.
     */
    orderBy?: portfolioProjectsOrderByWithRelationInput | portfolioProjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for portfolioProjects.
     */
    cursor?: portfolioProjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` portfolioProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` portfolioProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of portfolioProjects.
     */
    distinct?: PortfolioProjectsScalarFieldEnum | PortfolioProjectsScalarFieldEnum[]
  }

  /**
   * portfolioProjects findFirstOrThrow
   */
  export type portfolioProjectsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the portfolioProjects
     */
    select?: portfolioProjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: portfolioProjectsInclude<ExtArgs> | null
    /**
     * Filter, which portfolioProjects to fetch.
     */
    where?: portfolioProjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of portfolioProjects to fetch.
     */
    orderBy?: portfolioProjectsOrderByWithRelationInput | portfolioProjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for portfolioProjects.
     */
    cursor?: portfolioProjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` portfolioProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` portfolioProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of portfolioProjects.
     */
    distinct?: PortfolioProjectsScalarFieldEnum | PortfolioProjectsScalarFieldEnum[]
  }

  /**
   * portfolioProjects findMany
   */
  export type portfolioProjectsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the portfolioProjects
     */
    select?: portfolioProjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: portfolioProjectsInclude<ExtArgs> | null
    /**
     * Filter, which portfolioProjects to fetch.
     */
    where?: portfolioProjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of portfolioProjects to fetch.
     */
    orderBy?: portfolioProjectsOrderByWithRelationInput | portfolioProjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing portfolioProjects.
     */
    cursor?: portfolioProjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` portfolioProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` portfolioProjects.
     */
    skip?: number
    distinct?: PortfolioProjectsScalarFieldEnum | PortfolioProjectsScalarFieldEnum[]
  }

  /**
   * portfolioProjects create
   */
  export type portfolioProjectsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the portfolioProjects
     */
    select?: portfolioProjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: portfolioProjectsInclude<ExtArgs> | null
    /**
     * The data needed to create a portfolioProjects.
     */
    data: XOR<portfolioProjectsCreateInput, portfolioProjectsUncheckedCreateInput>
  }

  /**
   * portfolioProjects createMany
   */
  export type portfolioProjectsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many portfolioProjects.
     */
    data: portfolioProjectsCreateManyInput | portfolioProjectsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * portfolioProjects createManyAndReturn
   */
  export type portfolioProjectsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the portfolioProjects
     */
    select?: portfolioProjectsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many portfolioProjects.
     */
    data: portfolioProjectsCreateManyInput | portfolioProjectsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: portfolioProjectsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * portfolioProjects update
   */
  export type portfolioProjectsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the portfolioProjects
     */
    select?: portfolioProjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: portfolioProjectsInclude<ExtArgs> | null
    /**
     * The data needed to update a portfolioProjects.
     */
    data: XOR<portfolioProjectsUpdateInput, portfolioProjectsUncheckedUpdateInput>
    /**
     * Choose, which portfolioProjects to update.
     */
    where: portfolioProjectsWhereUniqueInput
  }

  /**
   * portfolioProjects updateMany
   */
  export type portfolioProjectsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update portfolioProjects.
     */
    data: XOR<portfolioProjectsUpdateManyMutationInput, portfolioProjectsUncheckedUpdateManyInput>
    /**
     * Filter which portfolioProjects to update
     */
    where?: portfolioProjectsWhereInput
  }

  /**
   * portfolioProjects upsert
   */
  export type portfolioProjectsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the portfolioProjects
     */
    select?: portfolioProjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: portfolioProjectsInclude<ExtArgs> | null
    /**
     * The filter to search for the portfolioProjects to update in case it exists.
     */
    where: portfolioProjectsWhereUniqueInput
    /**
     * In case the portfolioProjects found by the `where` argument doesn't exist, create a new portfolioProjects with this data.
     */
    create: XOR<portfolioProjectsCreateInput, portfolioProjectsUncheckedCreateInput>
    /**
     * In case the portfolioProjects was found with the provided `where` argument, update it with this data.
     */
    update: XOR<portfolioProjectsUpdateInput, portfolioProjectsUncheckedUpdateInput>
  }

  /**
   * portfolioProjects delete
   */
  export type portfolioProjectsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the portfolioProjects
     */
    select?: portfolioProjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: portfolioProjectsInclude<ExtArgs> | null
    /**
     * Filter which portfolioProjects to delete.
     */
    where: portfolioProjectsWhereUniqueInput
  }

  /**
   * portfolioProjects deleteMany
   */
  export type portfolioProjectsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which portfolioProjects to delete
     */
    where?: portfolioProjectsWhereInput
  }

  /**
   * portfolioProjects without action
   */
  export type portfolioProjectsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the portfolioProjects
     */
    select?: portfolioProjectsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: portfolioProjectsInclude<ExtArgs> | null
  }


  /**
   * Model internships
   */

  export type AggregateInternships = {
    _count: InternshipsCountAggregateOutputType | null
    _avg: InternshipsAvgAggregateOutputType | null
    _sum: InternshipsSumAggregateOutputType | null
    _min: InternshipsMinAggregateOutputType | null
    _max: InternshipsMaxAggregateOutputType | null
  }

  export type InternshipsAvgAggregateOutputType = {
    stipend: number | null
    duration_weeks: number | null
  }

  export type InternshipsSumAggregateOutputType = {
    stipend: number | null
    duration_weeks: number | null
  }

  export type InternshipsMinAggregateOutputType = {
    id: string | null
    industry_user_id: string | null
    title: string | null
    description: string | null
    type: string | null
    stipend: number | null
    location: string | null
    duration_weeks: number | null
    created_at: Date | null
  }

  export type InternshipsMaxAggregateOutputType = {
    id: string | null
    industry_user_id: string | null
    title: string | null
    description: string | null
    type: string | null
    stipend: number | null
    location: string | null
    duration_weeks: number | null
    created_at: Date | null
  }

  export type InternshipsCountAggregateOutputType = {
    id: number
    industry_user_id: number
    title: number
    description: number
    type: number
    stipend: number
    location: number
    required_skills: number
    duration_weeks: number
    created_at: number
    _all: number
  }


  export type InternshipsAvgAggregateInputType = {
    stipend?: true
    duration_weeks?: true
  }

  export type InternshipsSumAggregateInputType = {
    stipend?: true
    duration_weeks?: true
  }

  export type InternshipsMinAggregateInputType = {
    id?: true
    industry_user_id?: true
    title?: true
    description?: true
    type?: true
    stipend?: true
    location?: true
    duration_weeks?: true
    created_at?: true
  }

  export type InternshipsMaxAggregateInputType = {
    id?: true
    industry_user_id?: true
    title?: true
    description?: true
    type?: true
    stipend?: true
    location?: true
    duration_weeks?: true
    created_at?: true
  }

  export type InternshipsCountAggregateInputType = {
    id?: true
    industry_user_id?: true
    title?: true
    description?: true
    type?: true
    stipend?: true
    location?: true
    required_skills?: true
    duration_weeks?: true
    created_at?: true
    _all?: true
  }

  export type InternshipsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which internships to aggregate.
     */
    where?: internshipsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of internships to fetch.
     */
    orderBy?: internshipsOrderByWithRelationInput | internshipsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: internshipsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` internships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` internships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned internships
    **/
    _count?: true | InternshipsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InternshipsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InternshipsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InternshipsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InternshipsMaxAggregateInputType
  }

  export type GetInternshipsAggregateType<T extends InternshipsAggregateArgs> = {
        [P in keyof T & keyof AggregateInternships]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInternships[P]>
      : GetScalarType<T[P], AggregateInternships[P]>
  }




  export type internshipsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: internshipsWhereInput
    orderBy?: internshipsOrderByWithAggregationInput | internshipsOrderByWithAggregationInput[]
    by: InternshipsScalarFieldEnum[] | InternshipsScalarFieldEnum
    having?: internshipsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InternshipsCountAggregateInputType | true
    _avg?: InternshipsAvgAggregateInputType
    _sum?: InternshipsSumAggregateInputType
    _min?: InternshipsMinAggregateInputType
    _max?: InternshipsMaxAggregateInputType
  }

  export type InternshipsGroupByOutputType = {
    id: string
    industry_user_id: string
    title: string
    description: string
    type: string
    stipend: number | null
    location: string
    required_skills: JsonValue
    duration_weeks: number
    created_at: Date
    _count: InternshipsCountAggregateOutputType | null
    _avg: InternshipsAvgAggregateOutputType | null
    _sum: InternshipsSumAggregateOutputType | null
    _min: InternshipsMinAggregateOutputType | null
    _max: InternshipsMaxAggregateOutputType | null
  }

  type GetInternshipsGroupByPayload<T extends internshipsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InternshipsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InternshipsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InternshipsGroupByOutputType[P]>
            : GetScalarType<T[P], InternshipsGroupByOutputType[P]>
        }
      >
    >


  export type internshipsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    industry_user_id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    stipend?: boolean
    location?: boolean
    required_skills?: boolean
    duration_weeks?: boolean
    created_at?: boolean
    applications?: boolean | internships$applicationsArgs<ExtArgs>
    industryUser?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | InternshipsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["internships"]>

  export type internshipsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    industry_user_id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    stipend?: boolean
    location?: boolean
    required_skills?: boolean
    duration_weeks?: boolean
    created_at?: boolean
    industryUser?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["internships"]>

  export type internshipsSelectScalar = {
    id?: boolean
    industry_user_id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    stipend?: boolean
    location?: boolean
    required_skills?: boolean
    duration_weeks?: boolean
    created_at?: boolean
  }

  export type internshipsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applications?: boolean | internships$applicationsArgs<ExtArgs>
    industryUser?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | InternshipsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type internshipsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    industryUser?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $internshipsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "internships"
    objects: {
      applications: Prisma.$internship_applicationsPayload<ExtArgs>[]
      industryUser: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      industry_user_id: string
      title: string
      description: string
      type: string
      stipend: number | null
      location: string
      required_skills: Prisma.JsonValue
      duration_weeks: number
      created_at: Date
    }, ExtArgs["result"]["internships"]>
    composites: {}
  }

  type internshipsGetPayload<S extends boolean | null | undefined | internshipsDefaultArgs> = $Result.GetResult<Prisma.$internshipsPayload, S>

  type internshipsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<internshipsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InternshipsCountAggregateInputType | true
    }

  export interface internshipsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['internships'], meta: { name: 'internships' } }
    /**
     * Find zero or one Internships that matches the filter.
     * @param {internshipsFindUniqueArgs} args - Arguments to find a Internships
     * @example
     * // Get one Internships
     * const internships = await prisma.internships.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends internshipsFindUniqueArgs>(args: SelectSubset<T, internshipsFindUniqueArgs<ExtArgs>>): Prisma__internshipsClient<$Result.GetResult<Prisma.$internshipsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Internships that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {internshipsFindUniqueOrThrowArgs} args - Arguments to find a Internships
     * @example
     * // Get one Internships
     * const internships = await prisma.internships.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends internshipsFindUniqueOrThrowArgs>(args: SelectSubset<T, internshipsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__internshipsClient<$Result.GetResult<Prisma.$internshipsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Internships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {internshipsFindFirstArgs} args - Arguments to find a Internships
     * @example
     * // Get one Internships
     * const internships = await prisma.internships.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends internshipsFindFirstArgs>(args?: SelectSubset<T, internshipsFindFirstArgs<ExtArgs>>): Prisma__internshipsClient<$Result.GetResult<Prisma.$internshipsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Internships that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {internshipsFindFirstOrThrowArgs} args - Arguments to find a Internships
     * @example
     * // Get one Internships
     * const internships = await prisma.internships.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends internshipsFindFirstOrThrowArgs>(args?: SelectSubset<T, internshipsFindFirstOrThrowArgs<ExtArgs>>): Prisma__internshipsClient<$Result.GetResult<Prisma.$internshipsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Internships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {internshipsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Internships
     * const internships = await prisma.internships.findMany()
     * 
     * // Get first 10 Internships
     * const internships = await prisma.internships.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const internshipsWithIdOnly = await prisma.internships.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends internshipsFindManyArgs>(args?: SelectSubset<T, internshipsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$internshipsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Internships.
     * @param {internshipsCreateArgs} args - Arguments to create a Internships.
     * @example
     * // Create one Internships
     * const Internships = await prisma.internships.create({
     *   data: {
     *     // ... data to create a Internships
     *   }
     * })
     * 
     */
    create<T extends internshipsCreateArgs>(args: SelectSubset<T, internshipsCreateArgs<ExtArgs>>): Prisma__internshipsClient<$Result.GetResult<Prisma.$internshipsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Internships.
     * @param {internshipsCreateManyArgs} args - Arguments to create many Internships.
     * @example
     * // Create many Internships
     * const internships = await prisma.internships.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends internshipsCreateManyArgs>(args?: SelectSubset<T, internshipsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Internships and returns the data saved in the database.
     * @param {internshipsCreateManyAndReturnArgs} args - Arguments to create many Internships.
     * @example
     * // Create many Internships
     * const internships = await prisma.internships.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Internships and only return the `id`
     * const internshipsWithIdOnly = await prisma.internships.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends internshipsCreateManyAndReturnArgs>(args?: SelectSubset<T, internshipsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$internshipsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Internships.
     * @param {internshipsDeleteArgs} args - Arguments to delete one Internships.
     * @example
     * // Delete one Internships
     * const Internships = await prisma.internships.delete({
     *   where: {
     *     // ... filter to delete one Internships
     *   }
     * })
     * 
     */
    delete<T extends internshipsDeleteArgs>(args: SelectSubset<T, internshipsDeleteArgs<ExtArgs>>): Prisma__internshipsClient<$Result.GetResult<Prisma.$internshipsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Internships.
     * @param {internshipsUpdateArgs} args - Arguments to update one Internships.
     * @example
     * // Update one Internships
     * const internships = await prisma.internships.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends internshipsUpdateArgs>(args: SelectSubset<T, internshipsUpdateArgs<ExtArgs>>): Prisma__internshipsClient<$Result.GetResult<Prisma.$internshipsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Internships.
     * @param {internshipsDeleteManyArgs} args - Arguments to filter Internships to delete.
     * @example
     * // Delete a few Internships
     * const { count } = await prisma.internships.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends internshipsDeleteManyArgs>(args?: SelectSubset<T, internshipsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Internships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {internshipsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Internships
     * const internships = await prisma.internships.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends internshipsUpdateManyArgs>(args: SelectSubset<T, internshipsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Internships.
     * @param {internshipsUpsertArgs} args - Arguments to update or create a Internships.
     * @example
     * // Update or create a Internships
     * const internships = await prisma.internships.upsert({
     *   create: {
     *     // ... data to create a Internships
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Internships we want to update
     *   }
     * })
     */
    upsert<T extends internshipsUpsertArgs>(args: SelectSubset<T, internshipsUpsertArgs<ExtArgs>>): Prisma__internshipsClient<$Result.GetResult<Prisma.$internshipsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Internships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {internshipsCountArgs} args - Arguments to filter Internships to count.
     * @example
     * // Count the number of Internships
     * const count = await prisma.internships.count({
     *   where: {
     *     // ... the filter for the Internships we want to count
     *   }
     * })
    **/
    count<T extends internshipsCountArgs>(
      args?: Subset<T, internshipsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InternshipsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Internships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternshipsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InternshipsAggregateArgs>(args: Subset<T, InternshipsAggregateArgs>): Prisma.PrismaPromise<GetInternshipsAggregateType<T>>

    /**
     * Group by Internships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {internshipsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends internshipsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: internshipsGroupByArgs['orderBy'] }
        : { orderBy?: internshipsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, internshipsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInternshipsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the internships model
   */
  readonly fields: internshipsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for internships.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__internshipsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    applications<T extends internships$applicationsArgs<ExtArgs> = {}>(args?: Subset<T, internships$applicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$internship_applicationsPayload<ExtArgs>, T, "findMany"> | Null>
    industryUser<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the internships model
   */ 
  interface internshipsFieldRefs {
    readonly id: FieldRef<"internships", 'String'>
    readonly industry_user_id: FieldRef<"internships", 'String'>
    readonly title: FieldRef<"internships", 'String'>
    readonly description: FieldRef<"internships", 'String'>
    readonly type: FieldRef<"internships", 'String'>
    readonly stipend: FieldRef<"internships", 'Float'>
    readonly location: FieldRef<"internships", 'String'>
    readonly required_skills: FieldRef<"internships", 'Json'>
    readonly duration_weeks: FieldRef<"internships", 'Int'>
    readonly created_at: FieldRef<"internships", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * internships findUnique
   */
  export type internshipsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internships
     */
    select?: internshipsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internshipsInclude<ExtArgs> | null
    /**
     * Filter, which internships to fetch.
     */
    where: internshipsWhereUniqueInput
  }

  /**
   * internships findUniqueOrThrow
   */
  export type internshipsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internships
     */
    select?: internshipsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internshipsInclude<ExtArgs> | null
    /**
     * Filter, which internships to fetch.
     */
    where: internshipsWhereUniqueInput
  }

  /**
   * internships findFirst
   */
  export type internshipsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internships
     */
    select?: internshipsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internshipsInclude<ExtArgs> | null
    /**
     * Filter, which internships to fetch.
     */
    where?: internshipsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of internships to fetch.
     */
    orderBy?: internshipsOrderByWithRelationInput | internshipsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for internships.
     */
    cursor?: internshipsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` internships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` internships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of internships.
     */
    distinct?: InternshipsScalarFieldEnum | InternshipsScalarFieldEnum[]
  }

  /**
   * internships findFirstOrThrow
   */
  export type internshipsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internships
     */
    select?: internshipsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internshipsInclude<ExtArgs> | null
    /**
     * Filter, which internships to fetch.
     */
    where?: internshipsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of internships to fetch.
     */
    orderBy?: internshipsOrderByWithRelationInput | internshipsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for internships.
     */
    cursor?: internshipsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` internships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` internships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of internships.
     */
    distinct?: InternshipsScalarFieldEnum | InternshipsScalarFieldEnum[]
  }

  /**
   * internships findMany
   */
  export type internshipsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internships
     */
    select?: internshipsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internshipsInclude<ExtArgs> | null
    /**
     * Filter, which internships to fetch.
     */
    where?: internshipsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of internships to fetch.
     */
    orderBy?: internshipsOrderByWithRelationInput | internshipsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing internships.
     */
    cursor?: internshipsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` internships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` internships.
     */
    skip?: number
    distinct?: InternshipsScalarFieldEnum | InternshipsScalarFieldEnum[]
  }

  /**
   * internships create
   */
  export type internshipsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internships
     */
    select?: internshipsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internshipsInclude<ExtArgs> | null
    /**
     * The data needed to create a internships.
     */
    data: XOR<internshipsCreateInput, internshipsUncheckedCreateInput>
  }

  /**
   * internships createMany
   */
  export type internshipsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many internships.
     */
    data: internshipsCreateManyInput | internshipsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * internships createManyAndReturn
   */
  export type internshipsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internships
     */
    select?: internshipsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many internships.
     */
    data: internshipsCreateManyInput | internshipsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internshipsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * internships update
   */
  export type internshipsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internships
     */
    select?: internshipsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internshipsInclude<ExtArgs> | null
    /**
     * The data needed to update a internships.
     */
    data: XOR<internshipsUpdateInput, internshipsUncheckedUpdateInput>
    /**
     * Choose, which internships to update.
     */
    where: internshipsWhereUniqueInput
  }

  /**
   * internships updateMany
   */
  export type internshipsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update internships.
     */
    data: XOR<internshipsUpdateManyMutationInput, internshipsUncheckedUpdateManyInput>
    /**
     * Filter which internships to update
     */
    where?: internshipsWhereInput
  }

  /**
   * internships upsert
   */
  export type internshipsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internships
     */
    select?: internshipsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internshipsInclude<ExtArgs> | null
    /**
     * The filter to search for the internships to update in case it exists.
     */
    where: internshipsWhereUniqueInput
    /**
     * In case the internships found by the `where` argument doesn't exist, create a new internships with this data.
     */
    create: XOR<internshipsCreateInput, internshipsUncheckedCreateInput>
    /**
     * In case the internships was found with the provided `where` argument, update it with this data.
     */
    update: XOR<internshipsUpdateInput, internshipsUncheckedUpdateInput>
  }

  /**
   * internships delete
   */
  export type internshipsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internships
     */
    select?: internshipsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internshipsInclude<ExtArgs> | null
    /**
     * Filter which internships to delete.
     */
    where: internshipsWhereUniqueInput
  }

  /**
   * internships deleteMany
   */
  export type internshipsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which internships to delete
     */
    where?: internshipsWhereInput
  }

  /**
   * internships.applications
   */
  export type internships$applicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internship_applications
     */
    select?: internship_applicationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internship_applicationsInclude<ExtArgs> | null
    where?: internship_applicationsWhereInput
    orderBy?: internship_applicationsOrderByWithRelationInput | internship_applicationsOrderByWithRelationInput[]
    cursor?: internship_applicationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Internship_applicationsScalarFieldEnum | Internship_applicationsScalarFieldEnum[]
  }

  /**
   * internships without action
   */
  export type internshipsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internships
     */
    select?: internshipsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internshipsInclude<ExtArgs> | null
  }


  /**
   * Model internship_applications
   */

  export type AggregateInternship_applications = {
    _count: Internship_applicationsCountAggregateOutputType | null
    _avg: Internship_applicationsAvgAggregateOutputType | null
    _sum: Internship_applicationsSumAggregateOutputType | null
    _min: Internship_applicationsMinAggregateOutputType | null
    _max: Internship_applicationsMaxAggregateOutputType | null
  }

  export type Internship_applicationsAvgAggregateOutputType = {
    score: number | null
  }

  export type Internship_applicationsSumAggregateOutputType = {
    score: number | null
  }

  export type Internship_applicationsMinAggregateOutputType = {
    id: string | null
    internship_id: string | null
    student_id: string | null
    status: $Enums.InternshipStatus | null
    submission_url: string | null
    score: number | null
    applied_at: Date | null
  }

  export type Internship_applicationsMaxAggregateOutputType = {
    id: string | null
    internship_id: string | null
    student_id: string | null
    status: $Enums.InternshipStatus | null
    submission_url: string | null
    score: number | null
    applied_at: Date | null
  }

  export type Internship_applicationsCountAggregateOutputType = {
    id: number
    internship_id: number
    student_id: number
    status: number
    submission_url: number
    score: number
    applied_at: number
    _all: number
  }


  export type Internship_applicationsAvgAggregateInputType = {
    score?: true
  }

  export type Internship_applicationsSumAggregateInputType = {
    score?: true
  }

  export type Internship_applicationsMinAggregateInputType = {
    id?: true
    internship_id?: true
    student_id?: true
    status?: true
    submission_url?: true
    score?: true
    applied_at?: true
  }

  export type Internship_applicationsMaxAggregateInputType = {
    id?: true
    internship_id?: true
    student_id?: true
    status?: true
    submission_url?: true
    score?: true
    applied_at?: true
  }

  export type Internship_applicationsCountAggregateInputType = {
    id?: true
    internship_id?: true
    student_id?: true
    status?: true
    submission_url?: true
    score?: true
    applied_at?: true
    _all?: true
  }

  export type Internship_applicationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which internship_applications to aggregate.
     */
    where?: internship_applicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of internship_applications to fetch.
     */
    orderBy?: internship_applicationsOrderByWithRelationInput | internship_applicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: internship_applicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` internship_applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` internship_applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned internship_applications
    **/
    _count?: true | Internship_applicationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Internship_applicationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Internship_applicationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Internship_applicationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Internship_applicationsMaxAggregateInputType
  }

  export type GetInternship_applicationsAggregateType<T extends Internship_applicationsAggregateArgs> = {
        [P in keyof T & keyof AggregateInternship_applications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInternship_applications[P]>
      : GetScalarType<T[P], AggregateInternship_applications[P]>
  }




  export type internship_applicationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: internship_applicationsWhereInput
    orderBy?: internship_applicationsOrderByWithAggregationInput | internship_applicationsOrderByWithAggregationInput[]
    by: Internship_applicationsScalarFieldEnum[] | Internship_applicationsScalarFieldEnum
    having?: internship_applicationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Internship_applicationsCountAggregateInputType | true
    _avg?: Internship_applicationsAvgAggregateInputType
    _sum?: Internship_applicationsSumAggregateInputType
    _min?: Internship_applicationsMinAggregateInputType
    _max?: Internship_applicationsMaxAggregateInputType
  }

  export type Internship_applicationsGroupByOutputType = {
    id: string
    internship_id: string
    student_id: string
    status: $Enums.InternshipStatus
    submission_url: string | null
    score: number | null
    applied_at: Date
    _count: Internship_applicationsCountAggregateOutputType | null
    _avg: Internship_applicationsAvgAggregateOutputType | null
    _sum: Internship_applicationsSumAggregateOutputType | null
    _min: Internship_applicationsMinAggregateOutputType | null
    _max: Internship_applicationsMaxAggregateOutputType | null
  }

  type GetInternship_applicationsGroupByPayload<T extends internship_applicationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Internship_applicationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Internship_applicationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Internship_applicationsGroupByOutputType[P]>
            : GetScalarType<T[P], Internship_applicationsGroupByOutputType[P]>
        }
      >
    >


  export type internship_applicationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    internship_id?: boolean
    student_id?: boolean
    status?: boolean
    submission_url?: boolean
    score?: boolean
    applied_at?: boolean
    internship?: boolean | internshipsDefaultArgs<ExtArgs>
    student?: boolean | profileDefaultArgs<ExtArgs>
    evaluations?: boolean | internship_applications$evaluationsArgs<ExtArgs>
    logbookEntries?: boolean | internship_applications$logbookEntriesArgs<ExtArgs>
    _count?: boolean | Internship_applicationsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["internship_applications"]>

  export type internship_applicationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    internship_id?: boolean
    student_id?: boolean
    status?: boolean
    submission_url?: boolean
    score?: boolean
    applied_at?: boolean
    internship?: boolean | internshipsDefaultArgs<ExtArgs>
    student?: boolean | profileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["internship_applications"]>

  export type internship_applicationsSelectScalar = {
    id?: boolean
    internship_id?: boolean
    student_id?: boolean
    status?: boolean
    submission_url?: boolean
    score?: boolean
    applied_at?: boolean
  }

  export type internship_applicationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    internship?: boolean | internshipsDefaultArgs<ExtArgs>
    student?: boolean | profileDefaultArgs<ExtArgs>
    evaluations?: boolean | internship_applications$evaluationsArgs<ExtArgs>
    logbookEntries?: boolean | internship_applications$logbookEntriesArgs<ExtArgs>
    _count?: boolean | Internship_applicationsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type internship_applicationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    internship?: boolean | internshipsDefaultArgs<ExtArgs>
    student?: boolean | profileDefaultArgs<ExtArgs>
  }

  export type $internship_applicationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "internship_applications"
    objects: {
      internship: Prisma.$internshipsPayload<ExtArgs>
      student: Prisma.$profilePayload<ExtArgs>
      evaluations: Prisma.$internship_evaluationPayload<ExtArgs>[]
      logbookEntries: Prisma.$logbook_entriesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      internship_id: string
      student_id: string
      status: $Enums.InternshipStatus
      submission_url: string | null
      score: number | null
      applied_at: Date
    }, ExtArgs["result"]["internship_applications"]>
    composites: {}
  }

  type internship_applicationsGetPayload<S extends boolean | null | undefined | internship_applicationsDefaultArgs> = $Result.GetResult<Prisma.$internship_applicationsPayload, S>

  type internship_applicationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<internship_applicationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Internship_applicationsCountAggregateInputType | true
    }

  export interface internship_applicationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['internship_applications'], meta: { name: 'internship_applications' } }
    /**
     * Find zero or one Internship_applications that matches the filter.
     * @param {internship_applicationsFindUniqueArgs} args - Arguments to find a Internship_applications
     * @example
     * // Get one Internship_applications
     * const internship_applications = await prisma.internship_applications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends internship_applicationsFindUniqueArgs>(args: SelectSubset<T, internship_applicationsFindUniqueArgs<ExtArgs>>): Prisma__internship_applicationsClient<$Result.GetResult<Prisma.$internship_applicationsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Internship_applications that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {internship_applicationsFindUniqueOrThrowArgs} args - Arguments to find a Internship_applications
     * @example
     * // Get one Internship_applications
     * const internship_applications = await prisma.internship_applications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends internship_applicationsFindUniqueOrThrowArgs>(args: SelectSubset<T, internship_applicationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__internship_applicationsClient<$Result.GetResult<Prisma.$internship_applicationsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Internship_applications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {internship_applicationsFindFirstArgs} args - Arguments to find a Internship_applications
     * @example
     * // Get one Internship_applications
     * const internship_applications = await prisma.internship_applications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends internship_applicationsFindFirstArgs>(args?: SelectSubset<T, internship_applicationsFindFirstArgs<ExtArgs>>): Prisma__internship_applicationsClient<$Result.GetResult<Prisma.$internship_applicationsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Internship_applications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {internship_applicationsFindFirstOrThrowArgs} args - Arguments to find a Internship_applications
     * @example
     * // Get one Internship_applications
     * const internship_applications = await prisma.internship_applications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends internship_applicationsFindFirstOrThrowArgs>(args?: SelectSubset<T, internship_applicationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__internship_applicationsClient<$Result.GetResult<Prisma.$internship_applicationsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Internship_applications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {internship_applicationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Internship_applications
     * const internship_applications = await prisma.internship_applications.findMany()
     * 
     * // Get first 10 Internship_applications
     * const internship_applications = await prisma.internship_applications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const internship_applicationsWithIdOnly = await prisma.internship_applications.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends internship_applicationsFindManyArgs>(args?: SelectSubset<T, internship_applicationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$internship_applicationsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Internship_applications.
     * @param {internship_applicationsCreateArgs} args - Arguments to create a Internship_applications.
     * @example
     * // Create one Internship_applications
     * const Internship_applications = await prisma.internship_applications.create({
     *   data: {
     *     // ... data to create a Internship_applications
     *   }
     * })
     * 
     */
    create<T extends internship_applicationsCreateArgs>(args: SelectSubset<T, internship_applicationsCreateArgs<ExtArgs>>): Prisma__internship_applicationsClient<$Result.GetResult<Prisma.$internship_applicationsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Internship_applications.
     * @param {internship_applicationsCreateManyArgs} args - Arguments to create many Internship_applications.
     * @example
     * // Create many Internship_applications
     * const internship_applications = await prisma.internship_applications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends internship_applicationsCreateManyArgs>(args?: SelectSubset<T, internship_applicationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Internship_applications and returns the data saved in the database.
     * @param {internship_applicationsCreateManyAndReturnArgs} args - Arguments to create many Internship_applications.
     * @example
     * // Create many Internship_applications
     * const internship_applications = await prisma.internship_applications.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Internship_applications and only return the `id`
     * const internship_applicationsWithIdOnly = await prisma.internship_applications.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends internship_applicationsCreateManyAndReturnArgs>(args?: SelectSubset<T, internship_applicationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$internship_applicationsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Internship_applications.
     * @param {internship_applicationsDeleteArgs} args - Arguments to delete one Internship_applications.
     * @example
     * // Delete one Internship_applications
     * const Internship_applications = await prisma.internship_applications.delete({
     *   where: {
     *     // ... filter to delete one Internship_applications
     *   }
     * })
     * 
     */
    delete<T extends internship_applicationsDeleteArgs>(args: SelectSubset<T, internship_applicationsDeleteArgs<ExtArgs>>): Prisma__internship_applicationsClient<$Result.GetResult<Prisma.$internship_applicationsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Internship_applications.
     * @param {internship_applicationsUpdateArgs} args - Arguments to update one Internship_applications.
     * @example
     * // Update one Internship_applications
     * const internship_applications = await prisma.internship_applications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends internship_applicationsUpdateArgs>(args: SelectSubset<T, internship_applicationsUpdateArgs<ExtArgs>>): Prisma__internship_applicationsClient<$Result.GetResult<Prisma.$internship_applicationsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Internship_applications.
     * @param {internship_applicationsDeleteManyArgs} args - Arguments to filter Internship_applications to delete.
     * @example
     * // Delete a few Internship_applications
     * const { count } = await prisma.internship_applications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends internship_applicationsDeleteManyArgs>(args?: SelectSubset<T, internship_applicationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Internship_applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {internship_applicationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Internship_applications
     * const internship_applications = await prisma.internship_applications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends internship_applicationsUpdateManyArgs>(args: SelectSubset<T, internship_applicationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Internship_applications.
     * @param {internship_applicationsUpsertArgs} args - Arguments to update or create a Internship_applications.
     * @example
     * // Update or create a Internship_applications
     * const internship_applications = await prisma.internship_applications.upsert({
     *   create: {
     *     // ... data to create a Internship_applications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Internship_applications we want to update
     *   }
     * })
     */
    upsert<T extends internship_applicationsUpsertArgs>(args: SelectSubset<T, internship_applicationsUpsertArgs<ExtArgs>>): Prisma__internship_applicationsClient<$Result.GetResult<Prisma.$internship_applicationsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Internship_applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {internship_applicationsCountArgs} args - Arguments to filter Internship_applications to count.
     * @example
     * // Count the number of Internship_applications
     * const count = await prisma.internship_applications.count({
     *   where: {
     *     // ... the filter for the Internship_applications we want to count
     *   }
     * })
    **/
    count<T extends internship_applicationsCountArgs>(
      args?: Subset<T, internship_applicationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Internship_applicationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Internship_applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Internship_applicationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Internship_applicationsAggregateArgs>(args: Subset<T, Internship_applicationsAggregateArgs>): Prisma.PrismaPromise<GetInternship_applicationsAggregateType<T>>

    /**
     * Group by Internship_applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {internship_applicationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends internship_applicationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: internship_applicationsGroupByArgs['orderBy'] }
        : { orderBy?: internship_applicationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, internship_applicationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInternship_applicationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the internship_applications model
   */
  readonly fields: internship_applicationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for internship_applications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__internship_applicationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    internship<T extends internshipsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, internshipsDefaultArgs<ExtArgs>>): Prisma__internshipsClient<$Result.GetResult<Prisma.$internshipsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    student<T extends profileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, profileDefaultArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    evaluations<T extends internship_applications$evaluationsArgs<ExtArgs> = {}>(args?: Subset<T, internship_applications$evaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$internship_evaluationPayload<ExtArgs>, T, "findMany"> | Null>
    logbookEntries<T extends internship_applications$logbookEntriesArgs<ExtArgs> = {}>(args?: Subset<T, internship_applications$logbookEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$logbook_entriesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the internship_applications model
   */ 
  interface internship_applicationsFieldRefs {
    readonly id: FieldRef<"internship_applications", 'String'>
    readonly internship_id: FieldRef<"internship_applications", 'String'>
    readonly student_id: FieldRef<"internship_applications", 'String'>
    readonly status: FieldRef<"internship_applications", 'InternshipStatus'>
    readonly submission_url: FieldRef<"internship_applications", 'String'>
    readonly score: FieldRef<"internship_applications", 'Float'>
    readonly applied_at: FieldRef<"internship_applications", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * internship_applications findUnique
   */
  export type internship_applicationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internship_applications
     */
    select?: internship_applicationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internship_applicationsInclude<ExtArgs> | null
    /**
     * Filter, which internship_applications to fetch.
     */
    where: internship_applicationsWhereUniqueInput
  }

  /**
   * internship_applications findUniqueOrThrow
   */
  export type internship_applicationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internship_applications
     */
    select?: internship_applicationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internship_applicationsInclude<ExtArgs> | null
    /**
     * Filter, which internship_applications to fetch.
     */
    where: internship_applicationsWhereUniqueInput
  }

  /**
   * internship_applications findFirst
   */
  export type internship_applicationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internship_applications
     */
    select?: internship_applicationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internship_applicationsInclude<ExtArgs> | null
    /**
     * Filter, which internship_applications to fetch.
     */
    where?: internship_applicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of internship_applications to fetch.
     */
    orderBy?: internship_applicationsOrderByWithRelationInput | internship_applicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for internship_applications.
     */
    cursor?: internship_applicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` internship_applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` internship_applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of internship_applications.
     */
    distinct?: Internship_applicationsScalarFieldEnum | Internship_applicationsScalarFieldEnum[]
  }

  /**
   * internship_applications findFirstOrThrow
   */
  export type internship_applicationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internship_applications
     */
    select?: internship_applicationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internship_applicationsInclude<ExtArgs> | null
    /**
     * Filter, which internship_applications to fetch.
     */
    where?: internship_applicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of internship_applications to fetch.
     */
    orderBy?: internship_applicationsOrderByWithRelationInput | internship_applicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for internship_applications.
     */
    cursor?: internship_applicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` internship_applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` internship_applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of internship_applications.
     */
    distinct?: Internship_applicationsScalarFieldEnum | Internship_applicationsScalarFieldEnum[]
  }

  /**
   * internship_applications findMany
   */
  export type internship_applicationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internship_applications
     */
    select?: internship_applicationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internship_applicationsInclude<ExtArgs> | null
    /**
     * Filter, which internship_applications to fetch.
     */
    where?: internship_applicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of internship_applications to fetch.
     */
    orderBy?: internship_applicationsOrderByWithRelationInput | internship_applicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing internship_applications.
     */
    cursor?: internship_applicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` internship_applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` internship_applications.
     */
    skip?: number
    distinct?: Internship_applicationsScalarFieldEnum | Internship_applicationsScalarFieldEnum[]
  }

  /**
   * internship_applications create
   */
  export type internship_applicationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internship_applications
     */
    select?: internship_applicationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internship_applicationsInclude<ExtArgs> | null
    /**
     * The data needed to create a internship_applications.
     */
    data: XOR<internship_applicationsCreateInput, internship_applicationsUncheckedCreateInput>
  }

  /**
   * internship_applications createMany
   */
  export type internship_applicationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many internship_applications.
     */
    data: internship_applicationsCreateManyInput | internship_applicationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * internship_applications createManyAndReturn
   */
  export type internship_applicationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internship_applications
     */
    select?: internship_applicationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many internship_applications.
     */
    data: internship_applicationsCreateManyInput | internship_applicationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internship_applicationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * internship_applications update
   */
  export type internship_applicationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internship_applications
     */
    select?: internship_applicationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internship_applicationsInclude<ExtArgs> | null
    /**
     * The data needed to update a internship_applications.
     */
    data: XOR<internship_applicationsUpdateInput, internship_applicationsUncheckedUpdateInput>
    /**
     * Choose, which internship_applications to update.
     */
    where: internship_applicationsWhereUniqueInput
  }

  /**
   * internship_applications updateMany
   */
  export type internship_applicationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update internship_applications.
     */
    data: XOR<internship_applicationsUpdateManyMutationInput, internship_applicationsUncheckedUpdateManyInput>
    /**
     * Filter which internship_applications to update
     */
    where?: internship_applicationsWhereInput
  }

  /**
   * internship_applications upsert
   */
  export type internship_applicationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internship_applications
     */
    select?: internship_applicationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internship_applicationsInclude<ExtArgs> | null
    /**
     * The filter to search for the internship_applications to update in case it exists.
     */
    where: internship_applicationsWhereUniqueInput
    /**
     * In case the internship_applications found by the `where` argument doesn't exist, create a new internship_applications with this data.
     */
    create: XOR<internship_applicationsCreateInput, internship_applicationsUncheckedCreateInput>
    /**
     * In case the internship_applications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<internship_applicationsUpdateInput, internship_applicationsUncheckedUpdateInput>
  }

  /**
   * internship_applications delete
   */
  export type internship_applicationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internship_applications
     */
    select?: internship_applicationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internship_applicationsInclude<ExtArgs> | null
    /**
     * Filter which internship_applications to delete.
     */
    where: internship_applicationsWhereUniqueInput
  }

  /**
   * internship_applications deleteMany
   */
  export type internship_applicationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which internship_applications to delete
     */
    where?: internship_applicationsWhereInput
  }

  /**
   * internship_applications.evaluations
   */
  export type internship_applications$evaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internship_evaluation
     */
    select?: internship_evaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internship_evaluationInclude<ExtArgs> | null
    where?: internship_evaluationWhereInput
    orderBy?: internship_evaluationOrderByWithRelationInput | internship_evaluationOrderByWithRelationInput[]
    cursor?: internship_evaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Internship_evaluationScalarFieldEnum | Internship_evaluationScalarFieldEnum[]
  }

  /**
   * internship_applications.logbookEntries
   */
  export type internship_applications$logbookEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logbook_entries
     */
    select?: logbook_entriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: logbook_entriesInclude<ExtArgs> | null
    where?: logbook_entriesWhereInput
    orderBy?: logbook_entriesOrderByWithRelationInput | logbook_entriesOrderByWithRelationInput[]
    cursor?: logbook_entriesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Logbook_entriesScalarFieldEnum | Logbook_entriesScalarFieldEnum[]
  }

  /**
   * internship_applications without action
   */
  export type internship_applicationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internship_applications
     */
    select?: internship_applicationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internship_applicationsInclude<ExtArgs> | null
  }


  /**
   * Model logbook_entries
   */

  export type AggregateLogbook_entries = {
    _count: Logbook_entriesCountAggregateOutputType | null
    _avg: Logbook_entriesAvgAggregateOutputType | null
    _sum: Logbook_entriesSumAggregateOutputType | null
    _min: Logbook_entriesMinAggregateOutputType | null
    _max: Logbook_entriesMaxAggregateOutputType | null
  }

  export type Logbook_entriesAvgAggregateOutputType = {
    hours_spent: number | null
  }

  export type Logbook_entriesSumAggregateOutputType = {
    hours_spent: number | null
  }

  export type Logbook_entriesMinAggregateOutputType = {
    id: string | null
    applicationId: string | null
    date: Date | null
    taskDone: string | null
    proofUrl: string | null
    hours_spent: number | null
  }

  export type Logbook_entriesMaxAggregateOutputType = {
    id: string | null
    applicationId: string | null
    date: Date | null
    taskDone: string | null
    proofUrl: string | null
    hours_spent: number | null
  }

  export type Logbook_entriesCountAggregateOutputType = {
    id: number
    applicationId: number
    date: number
    taskDone: number
    proofUrl: number
    hours_spent: number
    _all: number
  }


  export type Logbook_entriesAvgAggregateInputType = {
    hours_spent?: true
  }

  export type Logbook_entriesSumAggregateInputType = {
    hours_spent?: true
  }

  export type Logbook_entriesMinAggregateInputType = {
    id?: true
    applicationId?: true
    date?: true
    taskDone?: true
    proofUrl?: true
    hours_spent?: true
  }

  export type Logbook_entriesMaxAggregateInputType = {
    id?: true
    applicationId?: true
    date?: true
    taskDone?: true
    proofUrl?: true
    hours_spent?: true
  }

  export type Logbook_entriesCountAggregateInputType = {
    id?: true
    applicationId?: true
    date?: true
    taskDone?: true
    proofUrl?: true
    hours_spent?: true
    _all?: true
  }

  export type Logbook_entriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which logbook_entries to aggregate.
     */
    where?: logbook_entriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logbook_entries to fetch.
     */
    orderBy?: logbook_entriesOrderByWithRelationInput | logbook_entriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: logbook_entriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logbook_entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logbook_entries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned logbook_entries
    **/
    _count?: true | Logbook_entriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Logbook_entriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Logbook_entriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Logbook_entriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Logbook_entriesMaxAggregateInputType
  }

  export type GetLogbook_entriesAggregateType<T extends Logbook_entriesAggregateArgs> = {
        [P in keyof T & keyof AggregateLogbook_entries]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogbook_entries[P]>
      : GetScalarType<T[P], AggregateLogbook_entries[P]>
  }




  export type logbook_entriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: logbook_entriesWhereInput
    orderBy?: logbook_entriesOrderByWithAggregationInput | logbook_entriesOrderByWithAggregationInput[]
    by: Logbook_entriesScalarFieldEnum[] | Logbook_entriesScalarFieldEnum
    having?: logbook_entriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Logbook_entriesCountAggregateInputType | true
    _avg?: Logbook_entriesAvgAggregateInputType
    _sum?: Logbook_entriesSumAggregateInputType
    _min?: Logbook_entriesMinAggregateInputType
    _max?: Logbook_entriesMaxAggregateInputType
  }

  export type Logbook_entriesGroupByOutputType = {
    id: string
    applicationId: string
    date: Date
    taskDone: string
    proofUrl: string | null
    hours_spent: number
    _count: Logbook_entriesCountAggregateOutputType | null
    _avg: Logbook_entriesAvgAggregateOutputType | null
    _sum: Logbook_entriesSumAggregateOutputType | null
    _min: Logbook_entriesMinAggregateOutputType | null
    _max: Logbook_entriesMaxAggregateOutputType | null
  }

  type GetLogbook_entriesGroupByPayload<T extends logbook_entriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Logbook_entriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Logbook_entriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Logbook_entriesGroupByOutputType[P]>
            : GetScalarType<T[P], Logbook_entriesGroupByOutputType[P]>
        }
      >
    >


  export type logbook_entriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    date?: boolean
    taskDone?: boolean
    proofUrl?: boolean
    hours_spent?: boolean
    application?: boolean | internship_applicationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["logbook_entries"]>

  export type logbook_entriesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    date?: boolean
    taskDone?: boolean
    proofUrl?: boolean
    hours_spent?: boolean
    application?: boolean | internship_applicationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["logbook_entries"]>

  export type logbook_entriesSelectScalar = {
    id?: boolean
    applicationId?: boolean
    date?: boolean
    taskDone?: boolean
    proofUrl?: boolean
    hours_spent?: boolean
  }

  export type logbook_entriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | internship_applicationsDefaultArgs<ExtArgs>
  }
  export type logbook_entriesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | internship_applicationsDefaultArgs<ExtArgs>
  }

  export type $logbook_entriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "logbook_entries"
    objects: {
      application: Prisma.$internship_applicationsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      applicationId: string
      date: Date
      taskDone: string
      proofUrl: string | null
      hours_spent: number
    }, ExtArgs["result"]["logbook_entries"]>
    composites: {}
  }

  type logbook_entriesGetPayload<S extends boolean | null | undefined | logbook_entriesDefaultArgs> = $Result.GetResult<Prisma.$logbook_entriesPayload, S>

  type logbook_entriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<logbook_entriesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Logbook_entriesCountAggregateInputType | true
    }

  export interface logbook_entriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['logbook_entries'], meta: { name: 'logbook_entries' } }
    /**
     * Find zero or one Logbook_entries that matches the filter.
     * @param {logbook_entriesFindUniqueArgs} args - Arguments to find a Logbook_entries
     * @example
     * // Get one Logbook_entries
     * const logbook_entries = await prisma.logbook_entries.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends logbook_entriesFindUniqueArgs>(args: SelectSubset<T, logbook_entriesFindUniqueArgs<ExtArgs>>): Prisma__logbook_entriesClient<$Result.GetResult<Prisma.$logbook_entriesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Logbook_entries that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {logbook_entriesFindUniqueOrThrowArgs} args - Arguments to find a Logbook_entries
     * @example
     * // Get one Logbook_entries
     * const logbook_entries = await prisma.logbook_entries.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends logbook_entriesFindUniqueOrThrowArgs>(args: SelectSubset<T, logbook_entriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__logbook_entriesClient<$Result.GetResult<Prisma.$logbook_entriesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Logbook_entries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logbook_entriesFindFirstArgs} args - Arguments to find a Logbook_entries
     * @example
     * // Get one Logbook_entries
     * const logbook_entries = await prisma.logbook_entries.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends logbook_entriesFindFirstArgs>(args?: SelectSubset<T, logbook_entriesFindFirstArgs<ExtArgs>>): Prisma__logbook_entriesClient<$Result.GetResult<Prisma.$logbook_entriesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Logbook_entries that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logbook_entriesFindFirstOrThrowArgs} args - Arguments to find a Logbook_entries
     * @example
     * // Get one Logbook_entries
     * const logbook_entries = await prisma.logbook_entries.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends logbook_entriesFindFirstOrThrowArgs>(args?: SelectSubset<T, logbook_entriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__logbook_entriesClient<$Result.GetResult<Prisma.$logbook_entriesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Logbook_entries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logbook_entriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Logbook_entries
     * const logbook_entries = await prisma.logbook_entries.findMany()
     * 
     * // Get first 10 Logbook_entries
     * const logbook_entries = await prisma.logbook_entries.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logbook_entriesWithIdOnly = await prisma.logbook_entries.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends logbook_entriesFindManyArgs>(args?: SelectSubset<T, logbook_entriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$logbook_entriesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Logbook_entries.
     * @param {logbook_entriesCreateArgs} args - Arguments to create a Logbook_entries.
     * @example
     * // Create one Logbook_entries
     * const Logbook_entries = await prisma.logbook_entries.create({
     *   data: {
     *     // ... data to create a Logbook_entries
     *   }
     * })
     * 
     */
    create<T extends logbook_entriesCreateArgs>(args: SelectSubset<T, logbook_entriesCreateArgs<ExtArgs>>): Prisma__logbook_entriesClient<$Result.GetResult<Prisma.$logbook_entriesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Logbook_entries.
     * @param {logbook_entriesCreateManyArgs} args - Arguments to create many Logbook_entries.
     * @example
     * // Create many Logbook_entries
     * const logbook_entries = await prisma.logbook_entries.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends logbook_entriesCreateManyArgs>(args?: SelectSubset<T, logbook_entriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Logbook_entries and returns the data saved in the database.
     * @param {logbook_entriesCreateManyAndReturnArgs} args - Arguments to create many Logbook_entries.
     * @example
     * // Create many Logbook_entries
     * const logbook_entries = await prisma.logbook_entries.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Logbook_entries and only return the `id`
     * const logbook_entriesWithIdOnly = await prisma.logbook_entries.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends logbook_entriesCreateManyAndReturnArgs>(args?: SelectSubset<T, logbook_entriesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$logbook_entriesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Logbook_entries.
     * @param {logbook_entriesDeleteArgs} args - Arguments to delete one Logbook_entries.
     * @example
     * // Delete one Logbook_entries
     * const Logbook_entries = await prisma.logbook_entries.delete({
     *   where: {
     *     // ... filter to delete one Logbook_entries
     *   }
     * })
     * 
     */
    delete<T extends logbook_entriesDeleteArgs>(args: SelectSubset<T, logbook_entriesDeleteArgs<ExtArgs>>): Prisma__logbook_entriesClient<$Result.GetResult<Prisma.$logbook_entriesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Logbook_entries.
     * @param {logbook_entriesUpdateArgs} args - Arguments to update one Logbook_entries.
     * @example
     * // Update one Logbook_entries
     * const logbook_entries = await prisma.logbook_entries.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends logbook_entriesUpdateArgs>(args: SelectSubset<T, logbook_entriesUpdateArgs<ExtArgs>>): Prisma__logbook_entriesClient<$Result.GetResult<Prisma.$logbook_entriesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Logbook_entries.
     * @param {logbook_entriesDeleteManyArgs} args - Arguments to filter Logbook_entries to delete.
     * @example
     * // Delete a few Logbook_entries
     * const { count } = await prisma.logbook_entries.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends logbook_entriesDeleteManyArgs>(args?: SelectSubset<T, logbook_entriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logbook_entries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logbook_entriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Logbook_entries
     * const logbook_entries = await prisma.logbook_entries.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends logbook_entriesUpdateManyArgs>(args: SelectSubset<T, logbook_entriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Logbook_entries.
     * @param {logbook_entriesUpsertArgs} args - Arguments to update or create a Logbook_entries.
     * @example
     * // Update or create a Logbook_entries
     * const logbook_entries = await prisma.logbook_entries.upsert({
     *   create: {
     *     // ... data to create a Logbook_entries
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Logbook_entries we want to update
     *   }
     * })
     */
    upsert<T extends logbook_entriesUpsertArgs>(args: SelectSubset<T, logbook_entriesUpsertArgs<ExtArgs>>): Prisma__logbook_entriesClient<$Result.GetResult<Prisma.$logbook_entriesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Logbook_entries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logbook_entriesCountArgs} args - Arguments to filter Logbook_entries to count.
     * @example
     * // Count the number of Logbook_entries
     * const count = await prisma.logbook_entries.count({
     *   where: {
     *     // ... the filter for the Logbook_entries we want to count
     *   }
     * })
    **/
    count<T extends logbook_entriesCountArgs>(
      args?: Subset<T, logbook_entriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Logbook_entriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Logbook_entries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Logbook_entriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Logbook_entriesAggregateArgs>(args: Subset<T, Logbook_entriesAggregateArgs>): Prisma.PrismaPromise<GetLogbook_entriesAggregateType<T>>

    /**
     * Group by Logbook_entries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logbook_entriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends logbook_entriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: logbook_entriesGroupByArgs['orderBy'] }
        : { orderBy?: logbook_entriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, logbook_entriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogbook_entriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the logbook_entries model
   */
  readonly fields: logbook_entriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for logbook_entries.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__logbook_entriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    application<T extends internship_applicationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, internship_applicationsDefaultArgs<ExtArgs>>): Prisma__internship_applicationsClient<$Result.GetResult<Prisma.$internship_applicationsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the logbook_entries model
   */ 
  interface logbook_entriesFieldRefs {
    readonly id: FieldRef<"logbook_entries", 'String'>
    readonly applicationId: FieldRef<"logbook_entries", 'String'>
    readonly date: FieldRef<"logbook_entries", 'DateTime'>
    readonly taskDone: FieldRef<"logbook_entries", 'String'>
    readonly proofUrl: FieldRef<"logbook_entries", 'String'>
    readonly hours_spent: FieldRef<"logbook_entries", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * logbook_entries findUnique
   */
  export type logbook_entriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logbook_entries
     */
    select?: logbook_entriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: logbook_entriesInclude<ExtArgs> | null
    /**
     * Filter, which logbook_entries to fetch.
     */
    where: logbook_entriesWhereUniqueInput
  }

  /**
   * logbook_entries findUniqueOrThrow
   */
  export type logbook_entriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logbook_entries
     */
    select?: logbook_entriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: logbook_entriesInclude<ExtArgs> | null
    /**
     * Filter, which logbook_entries to fetch.
     */
    where: logbook_entriesWhereUniqueInput
  }

  /**
   * logbook_entries findFirst
   */
  export type logbook_entriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logbook_entries
     */
    select?: logbook_entriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: logbook_entriesInclude<ExtArgs> | null
    /**
     * Filter, which logbook_entries to fetch.
     */
    where?: logbook_entriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logbook_entries to fetch.
     */
    orderBy?: logbook_entriesOrderByWithRelationInput | logbook_entriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for logbook_entries.
     */
    cursor?: logbook_entriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logbook_entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logbook_entries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of logbook_entries.
     */
    distinct?: Logbook_entriesScalarFieldEnum | Logbook_entriesScalarFieldEnum[]
  }

  /**
   * logbook_entries findFirstOrThrow
   */
  export type logbook_entriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logbook_entries
     */
    select?: logbook_entriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: logbook_entriesInclude<ExtArgs> | null
    /**
     * Filter, which logbook_entries to fetch.
     */
    where?: logbook_entriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logbook_entries to fetch.
     */
    orderBy?: logbook_entriesOrderByWithRelationInput | logbook_entriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for logbook_entries.
     */
    cursor?: logbook_entriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logbook_entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logbook_entries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of logbook_entries.
     */
    distinct?: Logbook_entriesScalarFieldEnum | Logbook_entriesScalarFieldEnum[]
  }

  /**
   * logbook_entries findMany
   */
  export type logbook_entriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logbook_entries
     */
    select?: logbook_entriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: logbook_entriesInclude<ExtArgs> | null
    /**
     * Filter, which logbook_entries to fetch.
     */
    where?: logbook_entriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logbook_entries to fetch.
     */
    orderBy?: logbook_entriesOrderByWithRelationInput | logbook_entriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing logbook_entries.
     */
    cursor?: logbook_entriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logbook_entries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logbook_entries.
     */
    skip?: number
    distinct?: Logbook_entriesScalarFieldEnum | Logbook_entriesScalarFieldEnum[]
  }

  /**
   * logbook_entries create
   */
  export type logbook_entriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logbook_entries
     */
    select?: logbook_entriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: logbook_entriesInclude<ExtArgs> | null
    /**
     * The data needed to create a logbook_entries.
     */
    data: XOR<logbook_entriesCreateInput, logbook_entriesUncheckedCreateInput>
  }

  /**
   * logbook_entries createMany
   */
  export type logbook_entriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many logbook_entries.
     */
    data: logbook_entriesCreateManyInput | logbook_entriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * logbook_entries createManyAndReturn
   */
  export type logbook_entriesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logbook_entries
     */
    select?: logbook_entriesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many logbook_entries.
     */
    data: logbook_entriesCreateManyInput | logbook_entriesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: logbook_entriesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * logbook_entries update
   */
  export type logbook_entriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logbook_entries
     */
    select?: logbook_entriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: logbook_entriesInclude<ExtArgs> | null
    /**
     * The data needed to update a logbook_entries.
     */
    data: XOR<logbook_entriesUpdateInput, logbook_entriesUncheckedUpdateInput>
    /**
     * Choose, which logbook_entries to update.
     */
    where: logbook_entriesWhereUniqueInput
  }

  /**
   * logbook_entries updateMany
   */
  export type logbook_entriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update logbook_entries.
     */
    data: XOR<logbook_entriesUpdateManyMutationInput, logbook_entriesUncheckedUpdateManyInput>
    /**
     * Filter which logbook_entries to update
     */
    where?: logbook_entriesWhereInput
  }

  /**
   * logbook_entries upsert
   */
  export type logbook_entriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logbook_entries
     */
    select?: logbook_entriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: logbook_entriesInclude<ExtArgs> | null
    /**
     * The filter to search for the logbook_entries to update in case it exists.
     */
    where: logbook_entriesWhereUniqueInput
    /**
     * In case the logbook_entries found by the `where` argument doesn't exist, create a new logbook_entries with this data.
     */
    create: XOR<logbook_entriesCreateInput, logbook_entriesUncheckedCreateInput>
    /**
     * In case the logbook_entries was found with the provided `where` argument, update it with this data.
     */
    update: XOR<logbook_entriesUpdateInput, logbook_entriesUncheckedUpdateInput>
  }

  /**
   * logbook_entries delete
   */
  export type logbook_entriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logbook_entries
     */
    select?: logbook_entriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: logbook_entriesInclude<ExtArgs> | null
    /**
     * Filter which logbook_entries to delete.
     */
    where: logbook_entriesWhereUniqueInput
  }

  /**
   * logbook_entries deleteMany
   */
  export type logbook_entriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which logbook_entries to delete
     */
    where?: logbook_entriesWhereInput
  }

  /**
   * logbook_entries without action
   */
  export type logbook_entriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logbook_entries
     */
    select?: logbook_entriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: logbook_entriesInclude<ExtArgs> | null
  }


  /**
   * Model internship_evaluation
   */

  export type AggregateInternship_evaluation = {
    _count: Internship_evaluationCountAggregateOutputType | null
    _avg: Internship_evaluationAvgAggregateOutputType | null
    _sum: Internship_evaluationSumAggregateOutputType | null
    _min: Internship_evaluationMinAggregateOutputType | null
    _max: Internship_evaluationMaxAggregateOutputType | null
  }

  export type Internship_evaluationAvgAggregateOutputType = {
    final_score: number | null
  }

  export type Internship_evaluationSumAggregateOutputType = {
    final_score: number | null
  }

  export type Internship_evaluationMinAggregateOutputType = {
    id: string | null
    application_id: string | null
    faculty_id: string | null
    comments: string | null
    final_score: number | null
  }

  export type Internship_evaluationMaxAggregateOutputType = {
    id: string | null
    application_id: string | null
    faculty_id: string | null
    comments: string | null
    final_score: number | null
  }

  export type Internship_evaluationCountAggregateOutputType = {
    id: number
    application_id: number
    faculty_id: number
    rubric_json: number
    comments: number
    final_score: number
    _all: number
  }


  export type Internship_evaluationAvgAggregateInputType = {
    final_score?: true
  }

  export type Internship_evaluationSumAggregateInputType = {
    final_score?: true
  }

  export type Internship_evaluationMinAggregateInputType = {
    id?: true
    application_id?: true
    faculty_id?: true
    comments?: true
    final_score?: true
  }

  export type Internship_evaluationMaxAggregateInputType = {
    id?: true
    application_id?: true
    faculty_id?: true
    comments?: true
    final_score?: true
  }

  export type Internship_evaluationCountAggregateInputType = {
    id?: true
    application_id?: true
    faculty_id?: true
    rubric_json?: true
    comments?: true
    final_score?: true
    _all?: true
  }

  export type Internship_evaluationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which internship_evaluation to aggregate.
     */
    where?: internship_evaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of internship_evaluations to fetch.
     */
    orderBy?: internship_evaluationOrderByWithRelationInput | internship_evaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: internship_evaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` internship_evaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` internship_evaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned internship_evaluations
    **/
    _count?: true | Internship_evaluationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Internship_evaluationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Internship_evaluationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Internship_evaluationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Internship_evaluationMaxAggregateInputType
  }

  export type GetInternship_evaluationAggregateType<T extends Internship_evaluationAggregateArgs> = {
        [P in keyof T & keyof AggregateInternship_evaluation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInternship_evaluation[P]>
      : GetScalarType<T[P], AggregateInternship_evaluation[P]>
  }




  export type internship_evaluationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: internship_evaluationWhereInput
    orderBy?: internship_evaluationOrderByWithAggregationInput | internship_evaluationOrderByWithAggregationInput[]
    by: Internship_evaluationScalarFieldEnum[] | Internship_evaluationScalarFieldEnum
    having?: internship_evaluationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Internship_evaluationCountAggregateInputType | true
    _avg?: Internship_evaluationAvgAggregateInputType
    _sum?: Internship_evaluationSumAggregateInputType
    _min?: Internship_evaluationMinAggregateInputType
    _max?: Internship_evaluationMaxAggregateInputType
  }

  export type Internship_evaluationGroupByOutputType = {
    id: string
    application_id: string
    faculty_id: string
    rubric_json: JsonValue | null
    comments: string | null
    final_score: number | null
    _count: Internship_evaluationCountAggregateOutputType | null
    _avg: Internship_evaluationAvgAggregateOutputType | null
    _sum: Internship_evaluationSumAggregateOutputType | null
    _min: Internship_evaluationMinAggregateOutputType | null
    _max: Internship_evaluationMaxAggregateOutputType | null
  }

  type GetInternship_evaluationGroupByPayload<T extends internship_evaluationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Internship_evaluationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Internship_evaluationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Internship_evaluationGroupByOutputType[P]>
            : GetScalarType<T[P], Internship_evaluationGroupByOutputType[P]>
        }
      >
    >


  export type internship_evaluationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    application_id?: boolean
    faculty_id?: boolean
    rubric_json?: boolean
    comments?: boolean
    final_score?: boolean
    application?: boolean | internship_applicationsDefaultArgs<ExtArgs>
    faculty?: boolean | facultyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["internship_evaluation"]>

  export type internship_evaluationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    application_id?: boolean
    faculty_id?: boolean
    rubric_json?: boolean
    comments?: boolean
    final_score?: boolean
    application?: boolean | internship_applicationsDefaultArgs<ExtArgs>
    faculty?: boolean | facultyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["internship_evaluation"]>

  export type internship_evaluationSelectScalar = {
    id?: boolean
    application_id?: boolean
    faculty_id?: boolean
    rubric_json?: boolean
    comments?: boolean
    final_score?: boolean
  }

  export type internship_evaluationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | internship_applicationsDefaultArgs<ExtArgs>
    faculty?: boolean | facultyDefaultArgs<ExtArgs>
  }
  export type internship_evaluationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | internship_applicationsDefaultArgs<ExtArgs>
    faculty?: boolean | facultyDefaultArgs<ExtArgs>
  }

  export type $internship_evaluationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "internship_evaluation"
    objects: {
      application: Prisma.$internship_applicationsPayload<ExtArgs>
      faculty: Prisma.$facultyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      application_id: string
      faculty_id: string
      rubric_json: Prisma.JsonValue | null
      comments: string | null
      final_score: number | null
    }, ExtArgs["result"]["internship_evaluation"]>
    composites: {}
  }

  type internship_evaluationGetPayload<S extends boolean | null | undefined | internship_evaluationDefaultArgs> = $Result.GetResult<Prisma.$internship_evaluationPayload, S>

  type internship_evaluationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<internship_evaluationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Internship_evaluationCountAggregateInputType | true
    }

  export interface internship_evaluationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['internship_evaluation'], meta: { name: 'internship_evaluation' } }
    /**
     * Find zero or one Internship_evaluation that matches the filter.
     * @param {internship_evaluationFindUniqueArgs} args - Arguments to find a Internship_evaluation
     * @example
     * // Get one Internship_evaluation
     * const internship_evaluation = await prisma.internship_evaluation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends internship_evaluationFindUniqueArgs>(args: SelectSubset<T, internship_evaluationFindUniqueArgs<ExtArgs>>): Prisma__internship_evaluationClient<$Result.GetResult<Prisma.$internship_evaluationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Internship_evaluation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {internship_evaluationFindUniqueOrThrowArgs} args - Arguments to find a Internship_evaluation
     * @example
     * // Get one Internship_evaluation
     * const internship_evaluation = await prisma.internship_evaluation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends internship_evaluationFindUniqueOrThrowArgs>(args: SelectSubset<T, internship_evaluationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__internship_evaluationClient<$Result.GetResult<Prisma.$internship_evaluationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Internship_evaluation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {internship_evaluationFindFirstArgs} args - Arguments to find a Internship_evaluation
     * @example
     * // Get one Internship_evaluation
     * const internship_evaluation = await prisma.internship_evaluation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends internship_evaluationFindFirstArgs>(args?: SelectSubset<T, internship_evaluationFindFirstArgs<ExtArgs>>): Prisma__internship_evaluationClient<$Result.GetResult<Prisma.$internship_evaluationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Internship_evaluation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {internship_evaluationFindFirstOrThrowArgs} args - Arguments to find a Internship_evaluation
     * @example
     * // Get one Internship_evaluation
     * const internship_evaluation = await prisma.internship_evaluation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends internship_evaluationFindFirstOrThrowArgs>(args?: SelectSubset<T, internship_evaluationFindFirstOrThrowArgs<ExtArgs>>): Prisma__internship_evaluationClient<$Result.GetResult<Prisma.$internship_evaluationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Internship_evaluations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {internship_evaluationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Internship_evaluations
     * const internship_evaluations = await prisma.internship_evaluation.findMany()
     * 
     * // Get first 10 Internship_evaluations
     * const internship_evaluations = await prisma.internship_evaluation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const internship_evaluationWithIdOnly = await prisma.internship_evaluation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends internship_evaluationFindManyArgs>(args?: SelectSubset<T, internship_evaluationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$internship_evaluationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Internship_evaluation.
     * @param {internship_evaluationCreateArgs} args - Arguments to create a Internship_evaluation.
     * @example
     * // Create one Internship_evaluation
     * const Internship_evaluation = await prisma.internship_evaluation.create({
     *   data: {
     *     // ... data to create a Internship_evaluation
     *   }
     * })
     * 
     */
    create<T extends internship_evaluationCreateArgs>(args: SelectSubset<T, internship_evaluationCreateArgs<ExtArgs>>): Prisma__internship_evaluationClient<$Result.GetResult<Prisma.$internship_evaluationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Internship_evaluations.
     * @param {internship_evaluationCreateManyArgs} args - Arguments to create many Internship_evaluations.
     * @example
     * // Create many Internship_evaluations
     * const internship_evaluation = await prisma.internship_evaluation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends internship_evaluationCreateManyArgs>(args?: SelectSubset<T, internship_evaluationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Internship_evaluations and returns the data saved in the database.
     * @param {internship_evaluationCreateManyAndReturnArgs} args - Arguments to create many Internship_evaluations.
     * @example
     * // Create many Internship_evaluations
     * const internship_evaluation = await prisma.internship_evaluation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Internship_evaluations and only return the `id`
     * const internship_evaluationWithIdOnly = await prisma.internship_evaluation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends internship_evaluationCreateManyAndReturnArgs>(args?: SelectSubset<T, internship_evaluationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$internship_evaluationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Internship_evaluation.
     * @param {internship_evaluationDeleteArgs} args - Arguments to delete one Internship_evaluation.
     * @example
     * // Delete one Internship_evaluation
     * const Internship_evaluation = await prisma.internship_evaluation.delete({
     *   where: {
     *     // ... filter to delete one Internship_evaluation
     *   }
     * })
     * 
     */
    delete<T extends internship_evaluationDeleteArgs>(args: SelectSubset<T, internship_evaluationDeleteArgs<ExtArgs>>): Prisma__internship_evaluationClient<$Result.GetResult<Prisma.$internship_evaluationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Internship_evaluation.
     * @param {internship_evaluationUpdateArgs} args - Arguments to update one Internship_evaluation.
     * @example
     * // Update one Internship_evaluation
     * const internship_evaluation = await prisma.internship_evaluation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends internship_evaluationUpdateArgs>(args: SelectSubset<T, internship_evaluationUpdateArgs<ExtArgs>>): Prisma__internship_evaluationClient<$Result.GetResult<Prisma.$internship_evaluationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Internship_evaluations.
     * @param {internship_evaluationDeleteManyArgs} args - Arguments to filter Internship_evaluations to delete.
     * @example
     * // Delete a few Internship_evaluations
     * const { count } = await prisma.internship_evaluation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends internship_evaluationDeleteManyArgs>(args?: SelectSubset<T, internship_evaluationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Internship_evaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {internship_evaluationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Internship_evaluations
     * const internship_evaluation = await prisma.internship_evaluation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends internship_evaluationUpdateManyArgs>(args: SelectSubset<T, internship_evaluationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Internship_evaluation.
     * @param {internship_evaluationUpsertArgs} args - Arguments to update or create a Internship_evaluation.
     * @example
     * // Update or create a Internship_evaluation
     * const internship_evaluation = await prisma.internship_evaluation.upsert({
     *   create: {
     *     // ... data to create a Internship_evaluation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Internship_evaluation we want to update
     *   }
     * })
     */
    upsert<T extends internship_evaluationUpsertArgs>(args: SelectSubset<T, internship_evaluationUpsertArgs<ExtArgs>>): Prisma__internship_evaluationClient<$Result.GetResult<Prisma.$internship_evaluationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Internship_evaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {internship_evaluationCountArgs} args - Arguments to filter Internship_evaluations to count.
     * @example
     * // Count the number of Internship_evaluations
     * const count = await prisma.internship_evaluation.count({
     *   where: {
     *     // ... the filter for the Internship_evaluations we want to count
     *   }
     * })
    **/
    count<T extends internship_evaluationCountArgs>(
      args?: Subset<T, internship_evaluationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Internship_evaluationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Internship_evaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Internship_evaluationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Internship_evaluationAggregateArgs>(args: Subset<T, Internship_evaluationAggregateArgs>): Prisma.PrismaPromise<GetInternship_evaluationAggregateType<T>>

    /**
     * Group by Internship_evaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {internship_evaluationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends internship_evaluationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: internship_evaluationGroupByArgs['orderBy'] }
        : { orderBy?: internship_evaluationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, internship_evaluationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInternship_evaluationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the internship_evaluation model
   */
  readonly fields: internship_evaluationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for internship_evaluation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__internship_evaluationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    application<T extends internship_applicationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, internship_applicationsDefaultArgs<ExtArgs>>): Prisma__internship_applicationsClient<$Result.GetResult<Prisma.$internship_applicationsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    faculty<T extends facultyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, facultyDefaultArgs<ExtArgs>>): Prisma__facultyClient<$Result.GetResult<Prisma.$facultyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the internship_evaluation model
   */ 
  interface internship_evaluationFieldRefs {
    readonly id: FieldRef<"internship_evaluation", 'String'>
    readonly application_id: FieldRef<"internship_evaluation", 'String'>
    readonly faculty_id: FieldRef<"internship_evaluation", 'String'>
    readonly rubric_json: FieldRef<"internship_evaluation", 'Json'>
    readonly comments: FieldRef<"internship_evaluation", 'String'>
    readonly final_score: FieldRef<"internship_evaluation", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * internship_evaluation findUnique
   */
  export type internship_evaluationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internship_evaluation
     */
    select?: internship_evaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internship_evaluationInclude<ExtArgs> | null
    /**
     * Filter, which internship_evaluation to fetch.
     */
    where: internship_evaluationWhereUniqueInput
  }

  /**
   * internship_evaluation findUniqueOrThrow
   */
  export type internship_evaluationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internship_evaluation
     */
    select?: internship_evaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internship_evaluationInclude<ExtArgs> | null
    /**
     * Filter, which internship_evaluation to fetch.
     */
    where: internship_evaluationWhereUniqueInput
  }

  /**
   * internship_evaluation findFirst
   */
  export type internship_evaluationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internship_evaluation
     */
    select?: internship_evaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internship_evaluationInclude<ExtArgs> | null
    /**
     * Filter, which internship_evaluation to fetch.
     */
    where?: internship_evaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of internship_evaluations to fetch.
     */
    orderBy?: internship_evaluationOrderByWithRelationInput | internship_evaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for internship_evaluations.
     */
    cursor?: internship_evaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` internship_evaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` internship_evaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of internship_evaluations.
     */
    distinct?: Internship_evaluationScalarFieldEnum | Internship_evaluationScalarFieldEnum[]
  }

  /**
   * internship_evaluation findFirstOrThrow
   */
  export type internship_evaluationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internship_evaluation
     */
    select?: internship_evaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internship_evaluationInclude<ExtArgs> | null
    /**
     * Filter, which internship_evaluation to fetch.
     */
    where?: internship_evaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of internship_evaluations to fetch.
     */
    orderBy?: internship_evaluationOrderByWithRelationInput | internship_evaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for internship_evaluations.
     */
    cursor?: internship_evaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` internship_evaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` internship_evaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of internship_evaluations.
     */
    distinct?: Internship_evaluationScalarFieldEnum | Internship_evaluationScalarFieldEnum[]
  }

  /**
   * internship_evaluation findMany
   */
  export type internship_evaluationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internship_evaluation
     */
    select?: internship_evaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internship_evaluationInclude<ExtArgs> | null
    /**
     * Filter, which internship_evaluations to fetch.
     */
    where?: internship_evaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of internship_evaluations to fetch.
     */
    orderBy?: internship_evaluationOrderByWithRelationInput | internship_evaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing internship_evaluations.
     */
    cursor?: internship_evaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` internship_evaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` internship_evaluations.
     */
    skip?: number
    distinct?: Internship_evaluationScalarFieldEnum | Internship_evaluationScalarFieldEnum[]
  }

  /**
   * internship_evaluation create
   */
  export type internship_evaluationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internship_evaluation
     */
    select?: internship_evaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internship_evaluationInclude<ExtArgs> | null
    /**
     * The data needed to create a internship_evaluation.
     */
    data: XOR<internship_evaluationCreateInput, internship_evaluationUncheckedCreateInput>
  }

  /**
   * internship_evaluation createMany
   */
  export type internship_evaluationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many internship_evaluations.
     */
    data: internship_evaluationCreateManyInput | internship_evaluationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * internship_evaluation createManyAndReturn
   */
  export type internship_evaluationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internship_evaluation
     */
    select?: internship_evaluationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many internship_evaluations.
     */
    data: internship_evaluationCreateManyInput | internship_evaluationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internship_evaluationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * internship_evaluation update
   */
  export type internship_evaluationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internship_evaluation
     */
    select?: internship_evaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internship_evaluationInclude<ExtArgs> | null
    /**
     * The data needed to update a internship_evaluation.
     */
    data: XOR<internship_evaluationUpdateInput, internship_evaluationUncheckedUpdateInput>
    /**
     * Choose, which internship_evaluation to update.
     */
    where: internship_evaluationWhereUniqueInput
  }

  /**
   * internship_evaluation updateMany
   */
  export type internship_evaluationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update internship_evaluations.
     */
    data: XOR<internship_evaluationUpdateManyMutationInput, internship_evaluationUncheckedUpdateManyInput>
    /**
     * Filter which internship_evaluations to update
     */
    where?: internship_evaluationWhereInput
  }

  /**
   * internship_evaluation upsert
   */
  export type internship_evaluationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internship_evaluation
     */
    select?: internship_evaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internship_evaluationInclude<ExtArgs> | null
    /**
     * The filter to search for the internship_evaluation to update in case it exists.
     */
    where: internship_evaluationWhereUniqueInput
    /**
     * In case the internship_evaluation found by the `where` argument doesn't exist, create a new internship_evaluation with this data.
     */
    create: XOR<internship_evaluationCreateInput, internship_evaluationUncheckedCreateInput>
    /**
     * In case the internship_evaluation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<internship_evaluationUpdateInput, internship_evaluationUncheckedUpdateInput>
  }

  /**
   * internship_evaluation delete
   */
  export type internship_evaluationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internship_evaluation
     */
    select?: internship_evaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internship_evaluationInclude<ExtArgs> | null
    /**
     * Filter which internship_evaluation to delete.
     */
    where: internship_evaluationWhereUniqueInput
  }

  /**
   * internship_evaluation deleteMany
   */
  export type internship_evaluationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which internship_evaluations to delete
     */
    where?: internship_evaluationWhereInput
  }

  /**
   * internship_evaluation without action
   */
  export type internship_evaluationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internship_evaluation
     */
    select?: internship_evaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internship_evaluationInclude<ExtArgs> | null
  }


  /**
   * Model faculty
   */

  export type AggregateFaculty = {
    _count: FacultyCountAggregateOutputType | null
    _min: FacultyMinAggregateOutputType | null
    _max: FacultyMaxAggregateOutputType | null
  }

  export type FacultyMinAggregateOutputType = {
    id: string | null
    instituteId: string | null
    userId: string | null
    name: string | null
    department: string | null
  }

  export type FacultyMaxAggregateOutputType = {
    id: string | null
    instituteId: string | null
    userId: string | null
    name: string | null
    department: string | null
  }

  export type FacultyCountAggregateOutputType = {
    id: number
    instituteId: number
    userId: number
    name: number
    department: number
    _all: number
  }


  export type FacultyMinAggregateInputType = {
    id?: true
    instituteId?: true
    userId?: true
    name?: true
    department?: true
  }

  export type FacultyMaxAggregateInputType = {
    id?: true
    instituteId?: true
    userId?: true
    name?: true
    department?: true
  }

  export type FacultyCountAggregateInputType = {
    id?: true
    instituteId?: true
    userId?: true
    name?: true
    department?: true
    _all?: true
  }

  export type FacultyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which faculty to aggregate.
     */
    where?: facultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of faculties to fetch.
     */
    orderBy?: facultyOrderByWithRelationInput | facultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: facultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` faculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` faculties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned faculties
    **/
    _count?: true | FacultyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FacultyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FacultyMaxAggregateInputType
  }

  export type GetFacultyAggregateType<T extends FacultyAggregateArgs> = {
        [P in keyof T & keyof AggregateFaculty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFaculty[P]>
      : GetScalarType<T[P], AggregateFaculty[P]>
  }




  export type facultyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: facultyWhereInput
    orderBy?: facultyOrderByWithAggregationInput | facultyOrderByWithAggregationInput[]
    by: FacultyScalarFieldEnum[] | FacultyScalarFieldEnum
    having?: facultyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FacultyCountAggregateInputType | true
    _min?: FacultyMinAggregateInputType
    _max?: FacultyMaxAggregateInputType
  }

  export type FacultyGroupByOutputType = {
    id: string
    instituteId: string
    userId: string
    name: string
    department: string
    _count: FacultyCountAggregateOutputType | null
    _min: FacultyMinAggregateOutputType | null
    _max: FacultyMaxAggregateOutputType | null
  }

  type GetFacultyGroupByPayload<T extends facultyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FacultyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FacultyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacultyGroupByOutputType[P]>
            : GetScalarType<T[P], FacultyGroupByOutputType[P]>
        }
      >
    >


  export type facultySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instituteId?: boolean
    userId?: boolean
    name?: boolean
    department?: boolean
    institution?: boolean | institutionsDefaultArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
    evaluations?: boolean | faculty$evaluationsArgs<ExtArgs>
    students?: boolean | faculty$studentsArgs<ExtArgs>
    _count?: boolean | FacultyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["faculty"]>

  export type facultySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instituteId?: boolean
    userId?: boolean
    name?: boolean
    department?: boolean
    institution?: boolean | institutionsDefaultArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["faculty"]>

  export type facultySelectScalar = {
    id?: boolean
    instituteId?: boolean
    userId?: boolean
    name?: boolean
    department?: boolean
  }

  export type facultyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | institutionsDefaultArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
    evaluations?: boolean | faculty$evaluationsArgs<ExtArgs>
    students?: boolean | faculty$studentsArgs<ExtArgs>
    _count?: boolean | FacultyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type facultyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    institution?: boolean | institutionsDefaultArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $facultyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "faculty"
    objects: {
      institution: Prisma.$institutionsPayload<ExtArgs>
      user: Prisma.$usersPayload<ExtArgs>
      evaluations: Prisma.$internship_evaluationPayload<ExtArgs>[]
      students: Prisma.$profilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      instituteId: string
      userId: string
      name: string
      department: string
    }, ExtArgs["result"]["faculty"]>
    composites: {}
  }

  type facultyGetPayload<S extends boolean | null | undefined | facultyDefaultArgs> = $Result.GetResult<Prisma.$facultyPayload, S>

  type facultyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<facultyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FacultyCountAggregateInputType | true
    }

  export interface facultyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['faculty'], meta: { name: 'faculty' } }
    /**
     * Find zero or one Faculty that matches the filter.
     * @param {facultyFindUniqueArgs} args - Arguments to find a Faculty
     * @example
     * // Get one Faculty
     * const faculty = await prisma.faculty.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends facultyFindUniqueArgs>(args: SelectSubset<T, facultyFindUniqueArgs<ExtArgs>>): Prisma__facultyClient<$Result.GetResult<Prisma.$facultyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Faculty that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {facultyFindUniqueOrThrowArgs} args - Arguments to find a Faculty
     * @example
     * // Get one Faculty
     * const faculty = await prisma.faculty.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends facultyFindUniqueOrThrowArgs>(args: SelectSubset<T, facultyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__facultyClient<$Result.GetResult<Prisma.$facultyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Faculty that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {facultyFindFirstArgs} args - Arguments to find a Faculty
     * @example
     * // Get one Faculty
     * const faculty = await prisma.faculty.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends facultyFindFirstArgs>(args?: SelectSubset<T, facultyFindFirstArgs<ExtArgs>>): Prisma__facultyClient<$Result.GetResult<Prisma.$facultyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Faculty that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {facultyFindFirstOrThrowArgs} args - Arguments to find a Faculty
     * @example
     * // Get one Faculty
     * const faculty = await prisma.faculty.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends facultyFindFirstOrThrowArgs>(args?: SelectSubset<T, facultyFindFirstOrThrowArgs<ExtArgs>>): Prisma__facultyClient<$Result.GetResult<Prisma.$facultyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Faculties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {facultyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Faculties
     * const faculties = await prisma.faculty.findMany()
     * 
     * // Get first 10 Faculties
     * const faculties = await prisma.faculty.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const facultyWithIdOnly = await prisma.faculty.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends facultyFindManyArgs>(args?: SelectSubset<T, facultyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$facultyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Faculty.
     * @param {facultyCreateArgs} args - Arguments to create a Faculty.
     * @example
     * // Create one Faculty
     * const Faculty = await prisma.faculty.create({
     *   data: {
     *     // ... data to create a Faculty
     *   }
     * })
     * 
     */
    create<T extends facultyCreateArgs>(args: SelectSubset<T, facultyCreateArgs<ExtArgs>>): Prisma__facultyClient<$Result.GetResult<Prisma.$facultyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Faculties.
     * @param {facultyCreateManyArgs} args - Arguments to create many Faculties.
     * @example
     * // Create many Faculties
     * const faculty = await prisma.faculty.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends facultyCreateManyArgs>(args?: SelectSubset<T, facultyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Faculties and returns the data saved in the database.
     * @param {facultyCreateManyAndReturnArgs} args - Arguments to create many Faculties.
     * @example
     * // Create many Faculties
     * const faculty = await prisma.faculty.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Faculties and only return the `id`
     * const facultyWithIdOnly = await prisma.faculty.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends facultyCreateManyAndReturnArgs>(args?: SelectSubset<T, facultyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$facultyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Faculty.
     * @param {facultyDeleteArgs} args - Arguments to delete one Faculty.
     * @example
     * // Delete one Faculty
     * const Faculty = await prisma.faculty.delete({
     *   where: {
     *     // ... filter to delete one Faculty
     *   }
     * })
     * 
     */
    delete<T extends facultyDeleteArgs>(args: SelectSubset<T, facultyDeleteArgs<ExtArgs>>): Prisma__facultyClient<$Result.GetResult<Prisma.$facultyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Faculty.
     * @param {facultyUpdateArgs} args - Arguments to update one Faculty.
     * @example
     * // Update one Faculty
     * const faculty = await prisma.faculty.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends facultyUpdateArgs>(args: SelectSubset<T, facultyUpdateArgs<ExtArgs>>): Prisma__facultyClient<$Result.GetResult<Prisma.$facultyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Faculties.
     * @param {facultyDeleteManyArgs} args - Arguments to filter Faculties to delete.
     * @example
     * // Delete a few Faculties
     * const { count } = await prisma.faculty.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends facultyDeleteManyArgs>(args?: SelectSubset<T, facultyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Faculties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {facultyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Faculties
     * const faculty = await prisma.faculty.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends facultyUpdateManyArgs>(args: SelectSubset<T, facultyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Faculty.
     * @param {facultyUpsertArgs} args - Arguments to update or create a Faculty.
     * @example
     * // Update or create a Faculty
     * const faculty = await prisma.faculty.upsert({
     *   create: {
     *     // ... data to create a Faculty
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Faculty we want to update
     *   }
     * })
     */
    upsert<T extends facultyUpsertArgs>(args: SelectSubset<T, facultyUpsertArgs<ExtArgs>>): Prisma__facultyClient<$Result.GetResult<Prisma.$facultyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Faculties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {facultyCountArgs} args - Arguments to filter Faculties to count.
     * @example
     * // Count the number of Faculties
     * const count = await prisma.faculty.count({
     *   where: {
     *     // ... the filter for the Faculties we want to count
     *   }
     * })
    **/
    count<T extends facultyCountArgs>(
      args?: Subset<T, facultyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacultyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Faculty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacultyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FacultyAggregateArgs>(args: Subset<T, FacultyAggregateArgs>): Prisma.PrismaPromise<GetFacultyAggregateType<T>>

    /**
     * Group by Faculty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {facultyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends facultyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: facultyGroupByArgs['orderBy'] }
        : { orderBy?: facultyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, facultyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFacultyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the faculty model
   */
  readonly fields: facultyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for faculty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__facultyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    institution<T extends institutionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, institutionsDefaultArgs<ExtArgs>>): Prisma__institutionsClient<$Result.GetResult<Prisma.$institutionsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    evaluations<T extends faculty$evaluationsArgs<ExtArgs> = {}>(args?: Subset<T, faculty$evaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$internship_evaluationPayload<ExtArgs>, T, "findMany"> | Null>
    students<T extends faculty$studentsArgs<ExtArgs> = {}>(args?: Subset<T, faculty$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the faculty model
   */ 
  interface facultyFieldRefs {
    readonly id: FieldRef<"faculty", 'String'>
    readonly instituteId: FieldRef<"faculty", 'String'>
    readonly userId: FieldRef<"faculty", 'String'>
    readonly name: FieldRef<"faculty", 'String'>
    readonly department: FieldRef<"faculty", 'String'>
  }
    

  // Custom InputTypes
  /**
   * faculty findUnique
   */
  export type facultyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faculty
     */
    select?: facultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facultyInclude<ExtArgs> | null
    /**
     * Filter, which faculty to fetch.
     */
    where: facultyWhereUniqueInput
  }

  /**
   * faculty findUniqueOrThrow
   */
  export type facultyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faculty
     */
    select?: facultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facultyInclude<ExtArgs> | null
    /**
     * Filter, which faculty to fetch.
     */
    where: facultyWhereUniqueInput
  }

  /**
   * faculty findFirst
   */
  export type facultyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faculty
     */
    select?: facultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facultyInclude<ExtArgs> | null
    /**
     * Filter, which faculty to fetch.
     */
    where?: facultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of faculties to fetch.
     */
    orderBy?: facultyOrderByWithRelationInput | facultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for faculties.
     */
    cursor?: facultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` faculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` faculties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of faculties.
     */
    distinct?: FacultyScalarFieldEnum | FacultyScalarFieldEnum[]
  }

  /**
   * faculty findFirstOrThrow
   */
  export type facultyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faculty
     */
    select?: facultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facultyInclude<ExtArgs> | null
    /**
     * Filter, which faculty to fetch.
     */
    where?: facultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of faculties to fetch.
     */
    orderBy?: facultyOrderByWithRelationInput | facultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for faculties.
     */
    cursor?: facultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` faculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` faculties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of faculties.
     */
    distinct?: FacultyScalarFieldEnum | FacultyScalarFieldEnum[]
  }

  /**
   * faculty findMany
   */
  export type facultyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faculty
     */
    select?: facultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facultyInclude<ExtArgs> | null
    /**
     * Filter, which faculties to fetch.
     */
    where?: facultyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of faculties to fetch.
     */
    orderBy?: facultyOrderByWithRelationInput | facultyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing faculties.
     */
    cursor?: facultyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` faculties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` faculties.
     */
    skip?: number
    distinct?: FacultyScalarFieldEnum | FacultyScalarFieldEnum[]
  }

  /**
   * faculty create
   */
  export type facultyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faculty
     */
    select?: facultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facultyInclude<ExtArgs> | null
    /**
     * The data needed to create a faculty.
     */
    data: XOR<facultyCreateInput, facultyUncheckedCreateInput>
  }

  /**
   * faculty createMany
   */
  export type facultyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many faculties.
     */
    data: facultyCreateManyInput | facultyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * faculty createManyAndReturn
   */
  export type facultyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faculty
     */
    select?: facultySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many faculties.
     */
    data: facultyCreateManyInput | facultyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facultyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * faculty update
   */
  export type facultyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faculty
     */
    select?: facultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facultyInclude<ExtArgs> | null
    /**
     * The data needed to update a faculty.
     */
    data: XOR<facultyUpdateInput, facultyUncheckedUpdateInput>
    /**
     * Choose, which faculty to update.
     */
    where: facultyWhereUniqueInput
  }

  /**
   * faculty updateMany
   */
  export type facultyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update faculties.
     */
    data: XOR<facultyUpdateManyMutationInput, facultyUncheckedUpdateManyInput>
    /**
     * Filter which faculties to update
     */
    where?: facultyWhereInput
  }

  /**
   * faculty upsert
   */
  export type facultyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faculty
     */
    select?: facultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facultyInclude<ExtArgs> | null
    /**
     * The filter to search for the faculty to update in case it exists.
     */
    where: facultyWhereUniqueInput
    /**
     * In case the faculty found by the `where` argument doesn't exist, create a new faculty with this data.
     */
    create: XOR<facultyCreateInput, facultyUncheckedCreateInput>
    /**
     * In case the faculty was found with the provided `where` argument, update it with this data.
     */
    update: XOR<facultyUpdateInput, facultyUncheckedUpdateInput>
  }

  /**
   * faculty delete
   */
  export type facultyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faculty
     */
    select?: facultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facultyInclude<ExtArgs> | null
    /**
     * Filter which faculty to delete.
     */
    where: facultyWhereUniqueInput
  }

  /**
   * faculty deleteMany
   */
  export type facultyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which faculties to delete
     */
    where?: facultyWhereInput
  }

  /**
   * faculty.evaluations
   */
  export type faculty$evaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the internship_evaluation
     */
    select?: internship_evaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: internship_evaluationInclude<ExtArgs> | null
    where?: internship_evaluationWhereInput
    orderBy?: internship_evaluationOrderByWithRelationInput | internship_evaluationOrderByWithRelationInput[]
    cursor?: internship_evaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Internship_evaluationScalarFieldEnum | Internship_evaluationScalarFieldEnum[]
  }

  /**
   * faculty.students
   */
  export type faculty$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: profileInclude<ExtArgs> | null
    where?: profileWhereInput
    orderBy?: profileOrderByWithRelationInput | profileOrderByWithRelationInput[]
    cursor?: profileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * faculty without action
   */
  export type facultyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the faculty
     */
    select?: facultySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: facultyInclude<ExtArgs> | null
  }


  /**
   * Model credits
   */

  export type AggregateCredits = {
    _count: CreditsCountAggregateOutputType | null
    _avg: CreditsAvgAggregateOutputType | null
    _sum: CreditsSumAggregateOutputType | null
    _min: CreditsMinAggregateOutputType | null
    _max: CreditsMaxAggregateOutputType | null
  }

  export type CreditsAvgAggregateOutputType = {
    credits_earned: number | null
  }

  export type CreditsSumAggregateOutputType = {
    credits_earned: number | null
  }

  export type CreditsMinAggregateOutputType = {
    id: string | null
    student_id: string | null
    credits_earned: number | null
  }

  export type CreditsMaxAggregateOutputType = {
    id: string | null
    student_id: string | null
    credits_earned: number | null
  }

  export type CreditsCountAggregateOutputType = {
    id: number
    student_id: number
    credits_earned: number
    _all: number
  }


  export type CreditsAvgAggregateInputType = {
    credits_earned?: true
  }

  export type CreditsSumAggregateInputType = {
    credits_earned?: true
  }

  export type CreditsMinAggregateInputType = {
    id?: true
    student_id?: true
    credits_earned?: true
  }

  export type CreditsMaxAggregateInputType = {
    id?: true
    student_id?: true
    credits_earned?: true
  }

  export type CreditsCountAggregateInputType = {
    id?: true
    student_id?: true
    credits_earned?: true
    _all?: true
  }

  export type CreditsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which credits to aggregate.
     */
    where?: creditsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of credits to fetch.
     */
    orderBy?: creditsOrderByWithRelationInput | creditsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: creditsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` credits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` credits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned credits
    **/
    _count?: true | CreditsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreditsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreditsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreditsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreditsMaxAggregateInputType
  }

  export type GetCreditsAggregateType<T extends CreditsAggregateArgs> = {
        [P in keyof T & keyof AggregateCredits]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCredits[P]>
      : GetScalarType<T[P], AggregateCredits[P]>
  }




  export type creditsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: creditsWhereInput
    orderBy?: creditsOrderByWithAggregationInput | creditsOrderByWithAggregationInput[]
    by: CreditsScalarFieldEnum[] | CreditsScalarFieldEnum
    having?: creditsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreditsCountAggregateInputType | true
    _avg?: CreditsAvgAggregateInputType
    _sum?: CreditsSumAggregateInputType
    _min?: CreditsMinAggregateInputType
    _max?: CreditsMaxAggregateInputType
  }

  export type CreditsGroupByOutputType = {
    id: string
    student_id: string
    credits_earned: number
    _count: CreditsCountAggregateOutputType | null
    _avg: CreditsAvgAggregateOutputType | null
    _sum: CreditsSumAggregateOutputType | null
    _min: CreditsMinAggregateOutputType | null
    _max: CreditsMaxAggregateOutputType | null
  }

  type GetCreditsGroupByPayload<T extends creditsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreditsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreditsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreditsGroupByOutputType[P]>
            : GetScalarType<T[P], CreditsGroupByOutputType[P]>
        }
      >
    >


  export type creditsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    student_id?: boolean
    credits_earned?: boolean
    student?: boolean | profileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["credits"]>

  export type creditsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    student_id?: boolean
    credits_earned?: boolean
    student?: boolean | profileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["credits"]>

  export type creditsSelectScalar = {
    id?: boolean
    student_id?: boolean
    credits_earned?: boolean
  }

  export type creditsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | profileDefaultArgs<ExtArgs>
  }
  export type creditsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | profileDefaultArgs<ExtArgs>
  }

  export type $creditsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "credits"
    objects: {
      student: Prisma.$profilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      student_id: string
      credits_earned: number
    }, ExtArgs["result"]["credits"]>
    composites: {}
  }

  type creditsGetPayload<S extends boolean | null | undefined | creditsDefaultArgs> = $Result.GetResult<Prisma.$creditsPayload, S>

  type creditsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<creditsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CreditsCountAggregateInputType | true
    }

  export interface creditsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['credits'], meta: { name: 'credits' } }
    /**
     * Find zero or one Credits that matches the filter.
     * @param {creditsFindUniqueArgs} args - Arguments to find a Credits
     * @example
     * // Get one Credits
     * const credits = await prisma.credits.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends creditsFindUniqueArgs>(args: SelectSubset<T, creditsFindUniqueArgs<ExtArgs>>): Prisma__creditsClient<$Result.GetResult<Prisma.$creditsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Credits that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {creditsFindUniqueOrThrowArgs} args - Arguments to find a Credits
     * @example
     * // Get one Credits
     * const credits = await prisma.credits.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends creditsFindUniqueOrThrowArgs>(args: SelectSubset<T, creditsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__creditsClient<$Result.GetResult<Prisma.$creditsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Credits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {creditsFindFirstArgs} args - Arguments to find a Credits
     * @example
     * // Get one Credits
     * const credits = await prisma.credits.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends creditsFindFirstArgs>(args?: SelectSubset<T, creditsFindFirstArgs<ExtArgs>>): Prisma__creditsClient<$Result.GetResult<Prisma.$creditsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Credits that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {creditsFindFirstOrThrowArgs} args - Arguments to find a Credits
     * @example
     * // Get one Credits
     * const credits = await prisma.credits.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends creditsFindFirstOrThrowArgs>(args?: SelectSubset<T, creditsFindFirstOrThrowArgs<ExtArgs>>): Prisma__creditsClient<$Result.GetResult<Prisma.$creditsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Credits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {creditsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Credits
     * const credits = await prisma.credits.findMany()
     * 
     * // Get first 10 Credits
     * const credits = await prisma.credits.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creditsWithIdOnly = await prisma.credits.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends creditsFindManyArgs>(args?: SelectSubset<T, creditsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$creditsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Credits.
     * @param {creditsCreateArgs} args - Arguments to create a Credits.
     * @example
     * // Create one Credits
     * const Credits = await prisma.credits.create({
     *   data: {
     *     // ... data to create a Credits
     *   }
     * })
     * 
     */
    create<T extends creditsCreateArgs>(args: SelectSubset<T, creditsCreateArgs<ExtArgs>>): Prisma__creditsClient<$Result.GetResult<Prisma.$creditsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Credits.
     * @param {creditsCreateManyArgs} args - Arguments to create many Credits.
     * @example
     * // Create many Credits
     * const credits = await prisma.credits.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends creditsCreateManyArgs>(args?: SelectSubset<T, creditsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Credits and returns the data saved in the database.
     * @param {creditsCreateManyAndReturnArgs} args - Arguments to create many Credits.
     * @example
     * // Create many Credits
     * const credits = await prisma.credits.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Credits and only return the `id`
     * const creditsWithIdOnly = await prisma.credits.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends creditsCreateManyAndReturnArgs>(args?: SelectSubset<T, creditsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$creditsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Credits.
     * @param {creditsDeleteArgs} args - Arguments to delete one Credits.
     * @example
     * // Delete one Credits
     * const Credits = await prisma.credits.delete({
     *   where: {
     *     // ... filter to delete one Credits
     *   }
     * })
     * 
     */
    delete<T extends creditsDeleteArgs>(args: SelectSubset<T, creditsDeleteArgs<ExtArgs>>): Prisma__creditsClient<$Result.GetResult<Prisma.$creditsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Credits.
     * @param {creditsUpdateArgs} args - Arguments to update one Credits.
     * @example
     * // Update one Credits
     * const credits = await prisma.credits.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends creditsUpdateArgs>(args: SelectSubset<T, creditsUpdateArgs<ExtArgs>>): Prisma__creditsClient<$Result.GetResult<Prisma.$creditsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Credits.
     * @param {creditsDeleteManyArgs} args - Arguments to filter Credits to delete.
     * @example
     * // Delete a few Credits
     * const { count } = await prisma.credits.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends creditsDeleteManyArgs>(args?: SelectSubset<T, creditsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Credits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {creditsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Credits
     * const credits = await prisma.credits.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends creditsUpdateManyArgs>(args: SelectSubset<T, creditsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Credits.
     * @param {creditsUpsertArgs} args - Arguments to update or create a Credits.
     * @example
     * // Update or create a Credits
     * const credits = await prisma.credits.upsert({
     *   create: {
     *     // ... data to create a Credits
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Credits we want to update
     *   }
     * })
     */
    upsert<T extends creditsUpsertArgs>(args: SelectSubset<T, creditsUpsertArgs<ExtArgs>>): Prisma__creditsClient<$Result.GetResult<Prisma.$creditsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Credits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {creditsCountArgs} args - Arguments to filter Credits to count.
     * @example
     * // Count the number of Credits
     * const count = await prisma.credits.count({
     *   where: {
     *     // ... the filter for the Credits we want to count
     *   }
     * })
    **/
    count<T extends creditsCountArgs>(
      args?: Subset<T, creditsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreditsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Credits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreditsAggregateArgs>(args: Subset<T, CreditsAggregateArgs>): Prisma.PrismaPromise<GetCreditsAggregateType<T>>

    /**
     * Group by Credits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {creditsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends creditsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: creditsGroupByArgs['orderBy'] }
        : { orderBy?: creditsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, creditsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreditsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the credits model
   */
  readonly fields: creditsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for credits.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__creditsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends profileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, profileDefaultArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the credits model
   */ 
  interface creditsFieldRefs {
    readonly id: FieldRef<"credits", 'String'>
    readonly student_id: FieldRef<"credits", 'String'>
    readonly credits_earned: FieldRef<"credits", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * credits findUnique
   */
  export type creditsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credits
     */
    select?: creditsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: creditsInclude<ExtArgs> | null
    /**
     * Filter, which credits to fetch.
     */
    where: creditsWhereUniqueInput
  }

  /**
   * credits findUniqueOrThrow
   */
  export type creditsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credits
     */
    select?: creditsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: creditsInclude<ExtArgs> | null
    /**
     * Filter, which credits to fetch.
     */
    where: creditsWhereUniqueInput
  }

  /**
   * credits findFirst
   */
  export type creditsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credits
     */
    select?: creditsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: creditsInclude<ExtArgs> | null
    /**
     * Filter, which credits to fetch.
     */
    where?: creditsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of credits to fetch.
     */
    orderBy?: creditsOrderByWithRelationInput | creditsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for credits.
     */
    cursor?: creditsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` credits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` credits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of credits.
     */
    distinct?: CreditsScalarFieldEnum | CreditsScalarFieldEnum[]
  }

  /**
   * credits findFirstOrThrow
   */
  export type creditsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credits
     */
    select?: creditsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: creditsInclude<ExtArgs> | null
    /**
     * Filter, which credits to fetch.
     */
    where?: creditsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of credits to fetch.
     */
    orderBy?: creditsOrderByWithRelationInput | creditsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for credits.
     */
    cursor?: creditsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` credits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` credits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of credits.
     */
    distinct?: CreditsScalarFieldEnum | CreditsScalarFieldEnum[]
  }

  /**
   * credits findMany
   */
  export type creditsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credits
     */
    select?: creditsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: creditsInclude<ExtArgs> | null
    /**
     * Filter, which credits to fetch.
     */
    where?: creditsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of credits to fetch.
     */
    orderBy?: creditsOrderByWithRelationInput | creditsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing credits.
     */
    cursor?: creditsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` credits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` credits.
     */
    skip?: number
    distinct?: CreditsScalarFieldEnum | CreditsScalarFieldEnum[]
  }

  /**
   * credits create
   */
  export type creditsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credits
     */
    select?: creditsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: creditsInclude<ExtArgs> | null
    /**
     * The data needed to create a credits.
     */
    data: XOR<creditsCreateInput, creditsUncheckedCreateInput>
  }

  /**
   * credits createMany
   */
  export type creditsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many credits.
     */
    data: creditsCreateManyInput | creditsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * credits createManyAndReturn
   */
  export type creditsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credits
     */
    select?: creditsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many credits.
     */
    data: creditsCreateManyInput | creditsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: creditsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * credits update
   */
  export type creditsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credits
     */
    select?: creditsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: creditsInclude<ExtArgs> | null
    /**
     * The data needed to update a credits.
     */
    data: XOR<creditsUpdateInput, creditsUncheckedUpdateInput>
    /**
     * Choose, which credits to update.
     */
    where: creditsWhereUniqueInput
  }

  /**
   * credits updateMany
   */
  export type creditsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update credits.
     */
    data: XOR<creditsUpdateManyMutationInput, creditsUncheckedUpdateManyInput>
    /**
     * Filter which credits to update
     */
    where?: creditsWhereInput
  }

  /**
   * credits upsert
   */
  export type creditsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credits
     */
    select?: creditsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: creditsInclude<ExtArgs> | null
    /**
     * The filter to search for the credits to update in case it exists.
     */
    where: creditsWhereUniqueInput
    /**
     * In case the credits found by the `where` argument doesn't exist, create a new credits with this data.
     */
    create: XOR<creditsCreateInput, creditsUncheckedCreateInput>
    /**
     * In case the credits was found with the provided `where` argument, update it with this data.
     */
    update: XOR<creditsUpdateInput, creditsUncheckedUpdateInput>
  }

  /**
   * credits delete
   */
  export type creditsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credits
     */
    select?: creditsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: creditsInclude<ExtArgs> | null
    /**
     * Filter which credits to delete.
     */
    where: creditsWhereUniqueInput
  }

  /**
   * credits deleteMany
   */
  export type creditsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which credits to delete
     */
    where?: creditsWhereInput
  }

  /**
   * credits without action
   */
  export type creditsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the credits
     */
    select?: creditsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: creditsInclude<ExtArgs> | null
  }


  /**
   * Model certificates
   */

  export type AggregateCertificates = {
    _count: CertificatesCountAggregateOutputType | null
    _min: CertificatesMinAggregateOutputType | null
    _max: CertificatesMaxAggregateOutputType | null
  }

  export type CertificatesMinAggregateOutputType = {
    id: string | null
    student_id: string | null
    title: string | null
    certificateUrl: string | null
    issuedAt: Date | null
  }

  export type CertificatesMaxAggregateOutputType = {
    id: string | null
    student_id: string | null
    title: string | null
    certificateUrl: string | null
    issuedAt: Date | null
  }

  export type CertificatesCountAggregateOutputType = {
    id: number
    student_id: number
    title: number
    certificateUrl: number
    issuedAt: number
    _all: number
  }


  export type CertificatesMinAggregateInputType = {
    id?: true
    student_id?: true
    title?: true
    certificateUrl?: true
    issuedAt?: true
  }

  export type CertificatesMaxAggregateInputType = {
    id?: true
    student_id?: true
    title?: true
    certificateUrl?: true
    issuedAt?: true
  }

  export type CertificatesCountAggregateInputType = {
    id?: true
    student_id?: true
    title?: true
    certificateUrl?: true
    issuedAt?: true
    _all?: true
  }

  export type CertificatesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which certificates to aggregate.
     */
    where?: certificatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of certificates to fetch.
     */
    orderBy?: certificatesOrderByWithRelationInput | certificatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: certificatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned certificates
    **/
    _count?: true | CertificatesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CertificatesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CertificatesMaxAggregateInputType
  }

  export type GetCertificatesAggregateType<T extends CertificatesAggregateArgs> = {
        [P in keyof T & keyof AggregateCertificates]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCertificates[P]>
      : GetScalarType<T[P], AggregateCertificates[P]>
  }




  export type certificatesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: certificatesWhereInput
    orderBy?: certificatesOrderByWithAggregationInput | certificatesOrderByWithAggregationInput[]
    by: CertificatesScalarFieldEnum[] | CertificatesScalarFieldEnum
    having?: certificatesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CertificatesCountAggregateInputType | true
    _min?: CertificatesMinAggregateInputType
    _max?: CertificatesMaxAggregateInputType
  }

  export type CertificatesGroupByOutputType = {
    id: string
    student_id: string
    title: string
    certificateUrl: string
    issuedAt: Date
    _count: CertificatesCountAggregateOutputType | null
    _min: CertificatesMinAggregateOutputType | null
    _max: CertificatesMaxAggregateOutputType | null
  }

  type GetCertificatesGroupByPayload<T extends certificatesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CertificatesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CertificatesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CertificatesGroupByOutputType[P]>
            : GetScalarType<T[P], CertificatesGroupByOutputType[P]>
        }
      >
    >


  export type certificatesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    student_id?: boolean
    title?: boolean
    certificateUrl?: boolean
    issuedAt?: boolean
    student?: boolean | profileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certificates"]>

  export type certificatesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    student_id?: boolean
    title?: boolean
    certificateUrl?: boolean
    issuedAt?: boolean
    student?: boolean | profileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certificates"]>

  export type certificatesSelectScalar = {
    id?: boolean
    student_id?: boolean
    title?: boolean
    certificateUrl?: boolean
    issuedAt?: boolean
  }

  export type certificatesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | profileDefaultArgs<ExtArgs>
  }
  export type certificatesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | profileDefaultArgs<ExtArgs>
  }

  export type $certificatesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "certificates"
    objects: {
      student: Prisma.$profilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      student_id: string
      title: string
      certificateUrl: string
      issuedAt: Date
    }, ExtArgs["result"]["certificates"]>
    composites: {}
  }

  type certificatesGetPayload<S extends boolean | null | undefined | certificatesDefaultArgs> = $Result.GetResult<Prisma.$certificatesPayload, S>

  type certificatesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<certificatesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CertificatesCountAggregateInputType | true
    }

  export interface certificatesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['certificates'], meta: { name: 'certificates' } }
    /**
     * Find zero or one Certificates that matches the filter.
     * @param {certificatesFindUniqueArgs} args - Arguments to find a Certificates
     * @example
     * // Get one Certificates
     * const certificates = await prisma.certificates.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends certificatesFindUniqueArgs>(args: SelectSubset<T, certificatesFindUniqueArgs<ExtArgs>>): Prisma__certificatesClient<$Result.GetResult<Prisma.$certificatesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Certificates that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {certificatesFindUniqueOrThrowArgs} args - Arguments to find a Certificates
     * @example
     * // Get one Certificates
     * const certificates = await prisma.certificates.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends certificatesFindUniqueOrThrowArgs>(args: SelectSubset<T, certificatesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__certificatesClient<$Result.GetResult<Prisma.$certificatesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Certificates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificatesFindFirstArgs} args - Arguments to find a Certificates
     * @example
     * // Get one Certificates
     * const certificates = await prisma.certificates.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends certificatesFindFirstArgs>(args?: SelectSubset<T, certificatesFindFirstArgs<ExtArgs>>): Prisma__certificatesClient<$Result.GetResult<Prisma.$certificatesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Certificates that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificatesFindFirstOrThrowArgs} args - Arguments to find a Certificates
     * @example
     * // Get one Certificates
     * const certificates = await prisma.certificates.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends certificatesFindFirstOrThrowArgs>(args?: SelectSubset<T, certificatesFindFirstOrThrowArgs<ExtArgs>>): Prisma__certificatesClient<$Result.GetResult<Prisma.$certificatesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Certificates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificatesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Certificates
     * const certificates = await prisma.certificates.findMany()
     * 
     * // Get first 10 Certificates
     * const certificates = await prisma.certificates.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const certificatesWithIdOnly = await prisma.certificates.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends certificatesFindManyArgs>(args?: SelectSubset<T, certificatesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$certificatesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Certificates.
     * @param {certificatesCreateArgs} args - Arguments to create a Certificates.
     * @example
     * // Create one Certificates
     * const Certificates = await prisma.certificates.create({
     *   data: {
     *     // ... data to create a Certificates
     *   }
     * })
     * 
     */
    create<T extends certificatesCreateArgs>(args: SelectSubset<T, certificatesCreateArgs<ExtArgs>>): Prisma__certificatesClient<$Result.GetResult<Prisma.$certificatesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Certificates.
     * @param {certificatesCreateManyArgs} args - Arguments to create many Certificates.
     * @example
     * // Create many Certificates
     * const certificates = await prisma.certificates.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends certificatesCreateManyArgs>(args?: SelectSubset<T, certificatesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Certificates and returns the data saved in the database.
     * @param {certificatesCreateManyAndReturnArgs} args - Arguments to create many Certificates.
     * @example
     * // Create many Certificates
     * const certificates = await prisma.certificates.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Certificates and only return the `id`
     * const certificatesWithIdOnly = await prisma.certificates.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends certificatesCreateManyAndReturnArgs>(args?: SelectSubset<T, certificatesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$certificatesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Certificates.
     * @param {certificatesDeleteArgs} args - Arguments to delete one Certificates.
     * @example
     * // Delete one Certificates
     * const Certificates = await prisma.certificates.delete({
     *   where: {
     *     // ... filter to delete one Certificates
     *   }
     * })
     * 
     */
    delete<T extends certificatesDeleteArgs>(args: SelectSubset<T, certificatesDeleteArgs<ExtArgs>>): Prisma__certificatesClient<$Result.GetResult<Prisma.$certificatesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Certificates.
     * @param {certificatesUpdateArgs} args - Arguments to update one Certificates.
     * @example
     * // Update one Certificates
     * const certificates = await prisma.certificates.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends certificatesUpdateArgs>(args: SelectSubset<T, certificatesUpdateArgs<ExtArgs>>): Prisma__certificatesClient<$Result.GetResult<Prisma.$certificatesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Certificates.
     * @param {certificatesDeleteManyArgs} args - Arguments to filter Certificates to delete.
     * @example
     * // Delete a few Certificates
     * const { count } = await prisma.certificates.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends certificatesDeleteManyArgs>(args?: SelectSubset<T, certificatesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificatesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Certificates
     * const certificates = await prisma.certificates.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends certificatesUpdateManyArgs>(args: SelectSubset<T, certificatesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Certificates.
     * @param {certificatesUpsertArgs} args - Arguments to update or create a Certificates.
     * @example
     * // Update or create a Certificates
     * const certificates = await prisma.certificates.upsert({
     *   create: {
     *     // ... data to create a Certificates
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Certificates we want to update
     *   }
     * })
     */
    upsert<T extends certificatesUpsertArgs>(args: SelectSubset<T, certificatesUpsertArgs<ExtArgs>>): Prisma__certificatesClient<$Result.GetResult<Prisma.$certificatesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificatesCountArgs} args - Arguments to filter Certificates to count.
     * @example
     * // Count the number of Certificates
     * const count = await prisma.certificates.count({
     *   where: {
     *     // ... the filter for the Certificates we want to count
     *   }
     * })
    **/
    count<T extends certificatesCountArgs>(
      args?: Subset<T, certificatesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CertificatesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificatesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CertificatesAggregateArgs>(args: Subset<T, CertificatesAggregateArgs>): Prisma.PrismaPromise<GetCertificatesAggregateType<T>>

    /**
     * Group by Certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificatesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends certificatesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: certificatesGroupByArgs['orderBy'] }
        : { orderBy?: certificatesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, certificatesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCertificatesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the certificates model
   */
  readonly fields: certificatesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for certificates.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__certificatesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends profileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, profileDefaultArgs<ExtArgs>>): Prisma__profileClient<$Result.GetResult<Prisma.$profilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the certificates model
   */ 
  interface certificatesFieldRefs {
    readonly id: FieldRef<"certificates", 'String'>
    readonly student_id: FieldRef<"certificates", 'String'>
    readonly title: FieldRef<"certificates", 'String'>
    readonly certificateUrl: FieldRef<"certificates", 'String'>
    readonly issuedAt: FieldRef<"certificates", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * certificates findUnique
   */
  export type certificatesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificates
     */
    select?: certificatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificatesInclude<ExtArgs> | null
    /**
     * Filter, which certificates to fetch.
     */
    where: certificatesWhereUniqueInput
  }

  /**
   * certificates findUniqueOrThrow
   */
  export type certificatesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificates
     */
    select?: certificatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificatesInclude<ExtArgs> | null
    /**
     * Filter, which certificates to fetch.
     */
    where: certificatesWhereUniqueInput
  }

  /**
   * certificates findFirst
   */
  export type certificatesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificates
     */
    select?: certificatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificatesInclude<ExtArgs> | null
    /**
     * Filter, which certificates to fetch.
     */
    where?: certificatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of certificates to fetch.
     */
    orderBy?: certificatesOrderByWithRelationInput | certificatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for certificates.
     */
    cursor?: certificatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of certificates.
     */
    distinct?: CertificatesScalarFieldEnum | CertificatesScalarFieldEnum[]
  }

  /**
   * certificates findFirstOrThrow
   */
  export type certificatesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificates
     */
    select?: certificatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificatesInclude<ExtArgs> | null
    /**
     * Filter, which certificates to fetch.
     */
    where?: certificatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of certificates to fetch.
     */
    orderBy?: certificatesOrderByWithRelationInput | certificatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for certificates.
     */
    cursor?: certificatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of certificates.
     */
    distinct?: CertificatesScalarFieldEnum | CertificatesScalarFieldEnum[]
  }

  /**
   * certificates findMany
   */
  export type certificatesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificates
     */
    select?: certificatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificatesInclude<ExtArgs> | null
    /**
     * Filter, which certificates to fetch.
     */
    where?: certificatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of certificates to fetch.
     */
    orderBy?: certificatesOrderByWithRelationInput | certificatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing certificates.
     */
    cursor?: certificatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` certificates.
     */
    skip?: number
    distinct?: CertificatesScalarFieldEnum | CertificatesScalarFieldEnum[]
  }

  /**
   * certificates create
   */
  export type certificatesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificates
     */
    select?: certificatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificatesInclude<ExtArgs> | null
    /**
     * The data needed to create a certificates.
     */
    data: XOR<certificatesCreateInput, certificatesUncheckedCreateInput>
  }

  /**
   * certificates createMany
   */
  export type certificatesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many certificates.
     */
    data: certificatesCreateManyInput | certificatesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * certificates createManyAndReturn
   */
  export type certificatesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificates
     */
    select?: certificatesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many certificates.
     */
    data: certificatesCreateManyInput | certificatesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificatesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * certificates update
   */
  export type certificatesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificates
     */
    select?: certificatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificatesInclude<ExtArgs> | null
    /**
     * The data needed to update a certificates.
     */
    data: XOR<certificatesUpdateInput, certificatesUncheckedUpdateInput>
    /**
     * Choose, which certificates to update.
     */
    where: certificatesWhereUniqueInput
  }

  /**
   * certificates updateMany
   */
  export type certificatesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update certificates.
     */
    data: XOR<certificatesUpdateManyMutationInput, certificatesUncheckedUpdateManyInput>
    /**
     * Filter which certificates to update
     */
    where?: certificatesWhereInput
  }

  /**
   * certificates upsert
   */
  export type certificatesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificates
     */
    select?: certificatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificatesInclude<ExtArgs> | null
    /**
     * The filter to search for the certificates to update in case it exists.
     */
    where: certificatesWhereUniqueInput
    /**
     * In case the certificates found by the `where` argument doesn't exist, create a new certificates with this data.
     */
    create: XOR<certificatesCreateInput, certificatesUncheckedCreateInput>
    /**
     * In case the certificates was found with the provided `where` argument, update it with this data.
     */
    update: XOR<certificatesUpdateInput, certificatesUncheckedUpdateInput>
  }

  /**
   * certificates delete
   */
  export type certificatesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificates
     */
    select?: certificatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificatesInclude<ExtArgs> | null
    /**
     * Filter which certificates to delete.
     */
    where: certificatesWhereUniqueInput
  }

  /**
   * certificates deleteMany
   */
  export type certificatesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which certificates to delete
     */
    where?: certificatesWhereInput
  }

  /**
   * certificates without action
   */
  export type certificatesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificates
     */
    select?: certificatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificatesInclude<ExtArgs> | null
  }


  /**
   * Model notifications
   */

  export type AggregateNotifications = {
    _count: NotificationsCountAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  export type NotificationsMinAggregateOutputType = {
    id: string | null
    title: string | null
    message: string | null
    created_at: Date | null
  }

  export type NotificationsMaxAggregateOutputType = {
    id: string | null
    title: string | null
    message: string | null
    created_at: Date | null
  }

  export type NotificationsCountAggregateOutputType = {
    id: number
    title: number
    message: number
    created_at: number
    _all: number
  }


  export type NotificationsMinAggregateInputType = {
    id?: true
    title?: true
    message?: true
    created_at?: true
  }

  export type NotificationsMaxAggregateInputType = {
    id?: true
    title?: true
    message?: true
    created_at?: true
  }

  export type NotificationsCountAggregateInputType = {
    id?: true
    title?: true
    message?: true
    created_at?: true
    _all?: true
  }

  export type NotificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to aggregate.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notifications
    **/
    _count?: true | NotificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationsMaxAggregateInputType
  }

  export type GetNotificationsAggregateType<T extends NotificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateNotifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotifications[P]>
      : GetScalarType<T[P], AggregateNotifications[P]>
  }




  export type notificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationsWhereInput
    orderBy?: notificationsOrderByWithAggregationInput | notificationsOrderByWithAggregationInput[]
    by: NotificationsScalarFieldEnum[] | NotificationsScalarFieldEnum
    having?: notificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationsCountAggregateInputType | true
    _min?: NotificationsMinAggregateInputType
    _max?: NotificationsMaxAggregateInputType
  }

  export type NotificationsGroupByOutputType = {
    id: string
    title: string
    message: string
    created_at: Date
    _count: NotificationsCountAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  type GetNotificationsGroupByPayload<T extends notificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
        }
      >
    >


  export type notificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    message?: boolean
    created_at?: boolean
    userNotifications?: boolean | notifications$userNotificationsArgs<ExtArgs>
    _count?: boolean | NotificationsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>

  export type notificationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    message?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["notifications"]>

  export type notificationsSelectScalar = {
    id?: boolean
    title?: boolean
    message?: boolean
    created_at?: boolean
  }

  export type notificationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userNotifications?: boolean | notifications$userNotificationsArgs<ExtArgs>
    _count?: boolean | NotificationsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type notificationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $notificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notifications"
    objects: {
      userNotifications: Prisma.$user_notificationsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      message: string
      created_at: Date
    }, ExtArgs["result"]["notifications"]>
    composites: {}
  }

  type notificationsGetPayload<S extends boolean | null | undefined | notificationsDefaultArgs> = $Result.GetResult<Prisma.$notificationsPayload, S>

  type notificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<notificationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationsCountAggregateInputType | true
    }

  export interface notificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notifications'], meta: { name: 'notifications' } }
    /**
     * Find zero or one Notifications that matches the filter.
     * @param {notificationsFindUniqueArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends notificationsFindUniqueArgs>(args: SelectSubset<T, notificationsFindUniqueArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notifications that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {notificationsFindUniqueOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends notificationsFindUniqueOrThrowArgs>(args: SelectSubset<T, notificationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindFirstArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends notificationsFindFirstArgs>(args?: SelectSubset<T, notificationsFindFirstArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindFirstOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends notificationsFindFirstOrThrowArgs>(args?: SelectSubset<T, notificationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notifications.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notifications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationsWithIdOnly = await prisma.notifications.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends notificationsFindManyArgs>(args?: SelectSubset<T, notificationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notifications.
     * @param {notificationsCreateArgs} args - Arguments to create a Notifications.
     * @example
     * // Create one Notifications
     * const Notifications = await prisma.notifications.create({
     *   data: {
     *     // ... data to create a Notifications
     *   }
     * })
     * 
     */
    create<T extends notificationsCreateArgs>(args: SelectSubset<T, notificationsCreateArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {notificationsCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notifications = await prisma.notifications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends notificationsCreateManyArgs>(args?: SelectSubset<T, notificationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {notificationsCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notifications = await prisma.notifications.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationsWithIdOnly = await prisma.notifications.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends notificationsCreateManyAndReturnArgs>(args?: SelectSubset<T, notificationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notifications.
     * @param {notificationsDeleteArgs} args - Arguments to delete one Notifications.
     * @example
     * // Delete one Notifications
     * const Notifications = await prisma.notifications.delete({
     *   where: {
     *     // ... filter to delete one Notifications
     *   }
     * })
     * 
     */
    delete<T extends notificationsDeleteArgs>(args: SelectSubset<T, notificationsDeleteArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notifications.
     * @param {notificationsUpdateArgs} args - Arguments to update one Notifications.
     * @example
     * // Update one Notifications
     * const notifications = await prisma.notifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends notificationsUpdateArgs>(args: SelectSubset<T, notificationsUpdateArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {notificationsDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends notificationsDeleteManyArgs>(args?: SelectSubset<T, notificationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notifications = await prisma.notifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends notificationsUpdateManyArgs>(args: SelectSubset<T, notificationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notifications.
     * @param {notificationsUpsertArgs} args - Arguments to update or create a Notifications.
     * @example
     * // Update or create a Notifications
     * const notifications = await prisma.notifications.upsert({
     *   create: {
     *     // ... data to create a Notifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notifications we want to update
     *   }
     * })
     */
    upsert<T extends notificationsUpsertArgs>(args: SelectSubset<T, notificationsUpsertArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notifications.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends notificationsCountArgs>(
      args?: Subset<T, notificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationsAggregateArgs>(args: Subset<T, NotificationsAggregateArgs>): Prisma.PrismaPromise<GetNotificationsAggregateType<T>>

    /**
     * Group by Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notificationsGroupByArgs['orderBy'] }
        : { orderBy?: notificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notifications model
   */
  readonly fields: notificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userNotifications<T extends notifications$userNotificationsArgs<ExtArgs> = {}>(args?: Subset<T, notifications$userNotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_notificationsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the notifications model
   */ 
  interface notificationsFieldRefs {
    readonly id: FieldRef<"notifications", 'String'>
    readonly title: FieldRef<"notifications", 'String'>
    readonly message: FieldRef<"notifications", 'String'>
    readonly created_at: FieldRef<"notifications", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * notifications findUnique
   */
  export type notificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications findUniqueOrThrow
   */
  export type notificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications findFirst
   */
  export type notificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications findFirstOrThrow
   */
  export type notificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications findMany
   */
  export type notificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications create
   */
  export type notificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * The data needed to create a notifications.
     */
    data: XOR<notificationsCreateInput, notificationsUncheckedCreateInput>
  }

  /**
   * notifications createMany
   */
  export type notificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notifications.
     */
    data: notificationsCreateManyInput | notificationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notifications createManyAndReturn
   */
  export type notificationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many notifications.
     */
    data: notificationsCreateManyInput | notificationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notifications update
   */
  export type notificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * The data needed to update a notifications.
     */
    data: XOR<notificationsUpdateInput, notificationsUncheckedUpdateInput>
    /**
     * Choose, which notifications to update.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications updateMany
   */
  export type notificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notifications.
     */
    data: XOR<notificationsUpdateManyMutationInput, notificationsUncheckedUpdateManyInput>
    /**
     * Filter which notifications to update
     */
    where?: notificationsWhereInput
  }

  /**
   * notifications upsert
   */
  export type notificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * The filter to search for the notifications to update in case it exists.
     */
    where: notificationsWhereUniqueInput
    /**
     * In case the notifications found by the `where` argument doesn't exist, create a new notifications with this data.
     */
    create: XOR<notificationsCreateInput, notificationsUncheckedCreateInput>
    /**
     * In case the notifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notificationsUpdateInput, notificationsUncheckedUpdateInput>
  }

  /**
   * notifications delete
   */
  export type notificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter which notifications to delete.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications deleteMany
   */
  export type notificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to delete
     */
    where?: notificationsWhereInput
  }

  /**
   * notifications.userNotifications
   */
  export type notifications$userNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_notifications
     */
    select?: user_notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_notificationsInclude<ExtArgs> | null
    where?: user_notificationsWhereInput
    orderBy?: user_notificationsOrderByWithRelationInput | user_notificationsOrderByWithRelationInput[]
    cursor?: user_notificationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_notificationsScalarFieldEnum | User_notificationsScalarFieldEnum[]
  }

  /**
   * notifications without action
   */
  export type notificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
  }


  /**
   * Model user_notifications
   */

  export type AggregateUser_notifications = {
    _count: User_notificationsCountAggregateOutputType | null
    _min: User_notificationsMinAggregateOutputType | null
    _max: User_notificationsMaxAggregateOutputType | null
  }

  export type User_notificationsMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    notification_id: string | null
    isRead: boolean | null
    read_at: Date | null
  }

  export type User_notificationsMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    notification_id: string | null
    isRead: boolean | null
    read_at: Date | null
  }

  export type User_notificationsCountAggregateOutputType = {
    id: number
    user_id: number
    notification_id: number
    isRead: number
    read_at: number
    _all: number
  }


  export type User_notificationsMinAggregateInputType = {
    id?: true
    user_id?: true
    notification_id?: true
    isRead?: true
    read_at?: true
  }

  export type User_notificationsMaxAggregateInputType = {
    id?: true
    user_id?: true
    notification_id?: true
    isRead?: true
    read_at?: true
  }

  export type User_notificationsCountAggregateInputType = {
    id?: true
    user_id?: true
    notification_id?: true
    isRead?: true
    read_at?: true
    _all?: true
  }

  export type User_notificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_notifications to aggregate.
     */
    where?: user_notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_notifications to fetch.
     */
    orderBy?: user_notificationsOrderByWithRelationInput | user_notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_notifications
    **/
    _count?: true | User_notificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_notificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_notificationsMaxAggregateInputType
  }

  export type GetUser_notificationsAggregateType<T extends User_notificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_notifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_notifications[P]>
      : GetScalarType<T[P], AggregateUser_notifications[P]>
  }




  export type user_notificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_notificationsWhereInput
    orderBy?: user_notificationsOrderByWithAggregationInput | user_notificationsOrderByWithAggregationInput[]
    by: User_notificationsScalarFieldEnum[] | User_notificationsScalarFieldEnum
    having?: user_notificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_notificationsCountAggregateInputType | true
    _min?: User_notificationsMinAggregateInputType
    _max?: User_notificationsMaxAggregateInputType
  }

  export type User_notificationsGroupByOutputType = {
    id: string
    user_id: string
    notification_id: string
    isRead: boolean
    read_at: Date | null
    _count: User_notificationsCountAggregateOutputType | null
    _min: User_notificationsMinAggregateOutputType | null
    _max: User_notificationsMaxAggregateOutputType | null
  }

  type GetUser_notificationsGroupByPayload<T extends user_notificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_notificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_notificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_notificationsGroupByOutputType[P]>
            : GetScalarType<T[P], User_notificationsGroupByOutputType[P]>
        }
      >
    >


  export type user_notificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    notification_id?: boolean
    isRead?: boolean
    read_at?: boolean
    notification?: boolean | notificationsDefaultArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_notifications"]>

  export type user_notificationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    notification_id?: boolean
    isRead?: boolean
    read_at?: boolean
    notification?: boolean | notificationsDefaultArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_notifications"]>

  export type user_notificationsSelectScalar = {
    id?: boolean
    user_id?: boolean
    notification_id?: boolean
    isRead?: boolean
    read_at?: boolean
  }

  export type user_notificationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notification?: boolean | notificationsDefaultArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type user_notificationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notification?: boolean | notificationsDefaultArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $user_notificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_notifications"
    objects: {
      notification: Prisma.$notificationsPayload<ExtArgs>
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      notification_id: string
      isRead: boolean
      read_at: Date | null
    }, ExtArgs["result"]["user_notifications"]>
    composites: {}
  }

  type user_notificationsGetPayload<S extends boolean | null | undefined | user_notificationsDefaultArgs> = $Result.GetResult<Prisma.$user_notificationsPayload, S>

  type user_notificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<user_notificationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: User_notificationsCountAggregateInputType | true
    }

  export interface user_notificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_notifications'], meta: { name: 'user_notifications' } }
    /**
     * Find zero or one User_notifications that matches the filter.
     * @param {user_notificationsFindUniqueArgs} args - Arguments to find a User_notifications
     * @example
     * // Get one User_notifications
     * const user_notifications = await prisma.user_notifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_notificationsFindUniqueArgs>(args: SelectSubset<T, user_notificationsFindUniqueArgs<ExtArgs>>): Prisma__user_notificationsClient<$Result.GetResult<Prisma.$user_notificationsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User_notifications that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {user_notificationsFindUniqueOrThrowArgs} args - Arguments to find a User_notifications
     * @example
     * // Get one User_notifications
     * const user_notifications = await prisma.user_notifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_notificationsFindUniqueOrThrowArgs>(args: SelectSubset<T, user_notificationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_notificationsClient<$Result.GetResult<Prisma.$user_notificationsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User_notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_notificationsFindFirstArgs} args - Arguments to find a User_notifications
     * @example
     * // Get one User_notifications
     * const user_notifications = await prisma.user_notifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_notificationsFindFirstArgs>(args?: SelectSubset<T, user_notificationsFindFirstArgs<ExtArgs>>): Prisma__user_notificationsClient<$Result.GetResult<Prisma.$user_notificationsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User_notifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_notificationsFindFirstOrThrowArgs} args - Arguments to find a User_notifications
     * @example
     * // Get one User_notifications
     * const user_notifications = await prisma.user_notifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_notificationsFindFirstOrThrowArgs>(args?: SelectSubset<T, user_notificationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_notificationsClient<$Result.GetResult<Prisma.$user_notificationsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more User_notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_notificationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_notifications
     * const user_notifications = await prisma.user_notifications.findMany()
     * 
     * // Get first 10 User_notifications
     * const user_notifications = await prisma.user_notifications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_notificationsWithIdOnly = await prisma.user_notifications.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends user_notificationsFindManyArgs>(args?: SelectSubset<T, user_notificationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_notificationsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User_notifications.
     * @param {user_notificationsCreateArgs} args - Arguments to create a User_notifications.
     * @example
     * // Create one User_notifications
     * const User_notifications = await prisma.user_notifications.create({
     *   data: {
     *     // ... data to create a User_notifications
     *   }
     * })
     * 
     */
    create<T extends user_notificationsCreateArgs>(args: SelectSubset<T, user_notificationsCreateArgs<ExtArgs>>): Prisma__user_notificationsClient<$Result.GetResult<Prisma.$user_notificationsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many User_notifications.
     * @param {user_notificationsCreateManyArgs} args - Arguments to create many User_notifications.
     * @example
     * // Create many User_notifications
     * const user_notifications = await prisma.user_notifications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_notificationsCreateManyArgs>(args?: SelectSubset<T, user_notificationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_notifications and returns the data saved in the database.
     * @param {user_notificationsCreateManyAndReturnArgs} args - Arguments to create many User_notifications.
     * @example
     * // Create many User_notifications
     * const user_notifications = await prisma.user_notifications.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_notifications and only return the `id`
     * const user_notificationsWithIdOnly = await prisma.user_notifications.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends user_notificationsCreateManyAndReturnArgs>(args?: SelectSubset<T, user_notificationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_notificationsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User_notifications.
     * @param {user_notificationsDeleteArgs} args - Arguments to delete one User_notifications.
     * @example
     * // Delete one User_notifications
     * const User_notifications = await prisma.user_notifications.delete({
     *   where: {
     *     // ... filter to delete one User_notifications
     *   }
     * })
     * 
     */
    delete<T extends user_notificationsDeleteArgs>(args: SelectSubset<T, user_notificationsDeleteArgs<ExtArgs>>): Prisma__user_notificationsClient<$Result.GetResult<Prisma.$user_notificationsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User_notifications.
     * @param {user_notificationsUpdateArgs} args - Arguments to update one User_notifications.
     * @example
     * // Update one User_notifications
     * const user_notifications = await prisma.user_notifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_notificationsUpdateArgs>(args: SelectSubset<T, user_notificationsUpdateArgs<ExtArgs>>): Prisma__user_notificationsClient<$Result.GetResult<Prisma.$user_notificationsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more User_notifications.
     * @param {user_notificationsDeleteManyArgs} args - Arguments to filter User_notifications to delete.
     * @example
     * // Delete a few User_notifications
     * const { count } = await prisma.user_notifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_notificationsDeleteManyArgs>(args?: SelectSubset<T, user_notificationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_notificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_notifications
     * const user_notifications = await prisma.user_notifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_notificationsUpdateManyArgs>(args: SelectSubset<T, user_notificationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User_notifications.
     * @param {user_notificationsUpsertArgs} args - Arguments to update or create a User_notifications.
     * @example
     * // Update or create a User_notifications
     * const user_notifications = await prisma.user_notifications.upsert({
     *   create: {
     *     // ... data to create a User_notifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_notifications we want to update
     *   }
     * })
     */
    upsert<T extends user_notificationsUpsertArgs>(args: SelectSubset<T, user_notificationsUpsertArgs<ExtArgs>>): Prisma__user_notificationsClient<$Result.GetResult<Prisma.$user_notificationsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of User_notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_notificationsCountArgs} args - Arguments to filter User_notifications to count.
     * @example
     * // Count the number of User_notifications
     * const count = await prisma.user_notifications.count({
     *   where: {
     *     // ... the filter for the User_notifications we want to count
     *   }
     * })
    **/
    count<T extends user_notificationsCountArgs>(
      args?: Subset<T, user_notificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_notificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_notificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_notificationsAggregateArgs>(args: Subset<T, User_notificationsAggregateArgs>): Prisma.PrismaPromise<GetUser_notificationsAggregateType<T>>

    /**
     * Group by User_notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_notificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_notificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_notificationsGroupByArgs['orderBy'] }
        : { orderBy?: user_notificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_notificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_notificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_notifications model
   */
  readonly fields: user_notificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_notifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_notificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    notification<T extends notificationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, notificationsDefaultArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_notifications model
   */ 
  interface user_notificationsFieldRefs {
    readonly id: FieldRef<"user_notifications", 'String'>
    readonly user_id: FieldRef<"user_notifications", 'String'>
    readonly notification_id: FieldRef<"user_notifications", 'String'>
    readonly isRead: FieldRef<"user_notifications", 'Boolean'>
    readonly read_at: FieldRef<"user_notifications", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user_notifications findUnique
   */
  export type user_notificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_notifications
     */
    select?: user_notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_notificationsInclude<ExtArgs> | null
    /**
     * Filter, which user_notifications to fetch.
     */
    where: user_notificationsWhereUniqueInput
  }

  /**
   * user_notifications findUniqueOrThrow
   */
  export type user_notificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_notifications
     */
    select?: user_notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_notificationsInclude<ExtArgs> | null
    /**
     * Filter, which user_notifications to fetch.
     */
    where: user_notificationsWhereUniqueInput
  }

  /**
   * user_notifications findFirst
   */
  export type user_notificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_notifications
     */
    select?: user_notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_notificationsInclude<ExtArgs> | null
    /**
     * Filter, which user_notifications to fetch.
     */
    where?: user_notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_notifications to fetch.
     */
    orderBy?: user_notificationsOrderByWithRelationInput | user_notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_notifications.
     */
    cursor?: user_notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_notifications.
     */
    distinct?: User_notificationsScalarFieldEnum | User_notificationsScalarFieldEnum[]
  }

  /**
   * user_notifications findFirstOrThrow
   */
  export type user_notificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_notifications
     */
    select?: user_notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_notificationsInclude<ExtArgs> | null
    /**
     * Filter, which user_notifications to fetch.
     */
    where?: user_notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_notifications to fetch.
     */
    orderBy?: user_notificationsOrderByWithRelationInput | user_notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_notifications.
     */
    cursor?: user_notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_notifications.
     */
    distinct?: User_notificationsScalarFieldEnum | User_notificationsScalarFieldEnum[]
  }

  /**
   * user_notifications findMany
   */
  export type user_notificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_notifications
     */
    select?: user_notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_notificationsInclude<ExtArgs> | null
    /**
     * Filter, which user_notifications to fetch.
     */
    where?: user_notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_notifications to fetch.
     */
    orderBy?: user_notificationsOrderByWithRelationInput | user_notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_notifications.
     */
    cursor?: user_notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_notifications.
     */
    skip?: number
    distinct?: User_notificationsScalarFieldEnum | User_notificationsScalarFieldEnum[]
  }

  /**
   * user_notifications create
   */
  export type user_notificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_notifications
     */
    select?: user_notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_notificationsInclude<ExtArgs> | null
    /**
     * The data needed to create a user_notifications.
     */
    data: XOR<user_notificationsCreateInput, user_notificationsUncheckedCreateInput>
  }

  /**
   * user_notifications createMany
   */
  export type user_notificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_notifications.
     */
    data: user_notificationsCreateManyInput | user_notificationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_notifications createManyAndReturn
   */
  export type user_notificationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_notifications
     */
    select?: user_notificationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many user_notifications.
     */
    data: user_notificationsCreateManyInput | user_notificationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_notificationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_notifications update
   */
  export type user_notificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_notifications
     */
    select?: user_notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_notificationsInclude<ExtArgs> | null
    /**
     * The data needed to update a user_notifications.
     */
    data: XOR<user_notificationsUpdateInput, user_notificationsUncheckedUpdateInput>
    /**
     * Choose, which user_notifications to update.
     */
    where: user_notificationsWhereUniqueInput
  }

  /**
   * user_notifications updateMany
   */
  export type user_notificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_notifications.
     */
    data: XOR<user_notificationsUpdateManyMutationInput, user_notificationsUncheckedUpdateManyInput>
    /**
     * Filter which user_notifications to update
     */
    where?: user_notificationsWhereInput
  }

  /**
   * user_notifications upsert
   */
  export type user_notificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_notifications
     */
    select?: user_notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_notificationsInclude<ExtArgs> | null
    /**
     * The filter to search for the user_notifications to update in case it exists.
     */
    where: user_notificationsWhereUniqueInput
    /**
     * In case the user_notifications found by the `where` argument doesn't exist, create a new user_notifications with this data.
     */
    create: XOR<user_notificationsCreateInput, user_notificationsUncheckedCreateInput>
    /**
     * In case the user_notifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_notificationsUpdateInput, user_notificationsUncheckedUpdateInput>
  }

  /**
   * user_notifications delete
   */
  export type user_notificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_notifications
     */
    select?: user_notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_notificationsInclude<ExtArgs> | null
    /**
     * Filter which user_notifications to delete.
     */
    where: user_notificationsWhereUniqueInput
  }

  /**
   * user_notifications deleteMany
   */
  export type user_notificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_notifications to delete
     */
    where?: user_notificationsWhereInput
  }

  /**
   * user_notifications without action
   */
  export type user_notificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_notifications
     */
    select?: user_notificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_notificationsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsersScalarFieldEnum: {
    id: 'id',
    displayName: 'displayName',
    role: 'role',
    email: 'email',
    salt: 'salt',
    phone: 'phone',
    hashPassword: 'hashPassword'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const InstitutionsScalarFieldEnum: {
    id: 'id',
    instituteName: 'instituteName',
    state: 'state',
    adminUserId: 'adminUserId',
    createdAt: 'createdAt'
  };

  export type InstitutionsScalarFieldEnum = (typeof InstitutionsScalarFieldEnum)[keyof typeof InstitutionsScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    bio: 'bio',
    gender: 'gender',
    DOB: 'DOB',
    avatarURL: 'avatarURL',
    github: 'github',
    linkedin: 'linkedin',
    skills: 'skills',
    interests: 'interests',
    department: 'department',
    resourceId: 'resourceId',
    instituteId: 'instituteId',
    facultyId: 'facultyId'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const RoadmapsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    domain: 'domain'
  };

  export type RoadmapsScalarFieldEnum = (typeof RoadmapsScalarFieldEnum)[keyof typeof RoadmapsScalarFieldEnum]


  export const CheckpointsScalarFieldEnum: {
    id: 'id',
    roadmapId: 'roadmapId',
    title: 'title',
    description: 'description',
    resourceType: 'resourceType',
    resourceUrl: 'resourceUrl'
  };

  export type CheckpointsScalarFieldEnum = (typeof CheckpointsScalarFieldEnum)[keyof typeof CheckpointsScalarFieldEnum]


  export const StudentLearningProgressScalarFieldEnum: {
    id: 'id',
    profileId: 'profileId',
    checkpointId: 'checkpointId',
    isCompleted: 'isCompleted',
    completedAt: 'completedAt'
  };

  export type StudentLearningProgressScalarFieldEnum = (typeof StudentLearningProgressScalarFieldEnum)[keyof typeof StudentLearningProgressScalarFieldEnum]


  export const CoursesScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    type: 'type',
    price: 'price',
    instructorId: 'instructorId',
    thumbnail_url: 'thumbnail_url',
    created_at: 'created_at'
  };

  export type CoursesScalarFieldEnum = (typeof CoursesScalarFieldEnum)[keyof typeof CoursesScalarFieldEnum]


  export const CourseEnrollmentsScalarFieldEnum: {
    id: 'id',
    courseId: 'courseId',
    userId: 'userId',
    progressPercent: 'progressPercent',
    enrolledAt: 'enrolledAt'
  };

  export type CourseEnrollmentsScalarFieldEnum = (typeof CourseEnrollmentsScalarFieldEnum)[keyof typeof CourseEnrollmentsScalarFieldEnum]


  export const MentorsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    expertise: 'expertise',
    rating: 'rating',
    bio: 'bio'
  };

  export type MentorsScalarFieldEnum = (typeof MentorsScalarFieldEnum)[keyof typeof MentorsScalarFieldEnum]


  export const MentorSessionsScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    mentorId: 'mentorId',
    scheduled_at: 'scheduled_at',
    status: 'status',
    meeting_link: 'meeting_link'
  };

  export type MentorSessionsScalarFieldEnum = (typeof MentorSessionsScalarFieldEnum)[keyof typeof MentorSessionsScalarFieldEnum]


  export const MentorReviewsScalarFieldEnum: {
    id: 'id',
    mentorId: 'mentorId',
    rating: 'rating',
    reviews: 'reviews',
    studentId: 'studentId'
  };

  export type MentorReviewsScalarFieldEnum = (typeof MentorReviewsScalarFieldEnum)[keyof typeof MentorReviewsScalarFieldEnum]


  export const PortfolioProjectsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    title: 'title',
    description: 'description',
    github_url: 'github_url',
    live_url: 'live_url',
    tags: 'tags'
  };

  export type PortfolioProjectsScalarFieldEnum = (typeof PortfolioProjectsScalarFieldEnum)[keyof typeof PortfolioProjectsScalarFieldEnum]


  export const InternshipsScalarFieldEnum: {
    id: 'id',
    industry_user_id: 'industry_user_id',
    title: 'title',
    description: 'description',
    type: 'type',
    stipend: 'stipend',
    location: 'location',
    required_skills: 'required_skills',
    duration_weeks: 'duration_weeks',
    created_at: 'created_at'
  };

  export type InternshipsScalarFieldEnum = (typeof InternshipsScalarFieldEnum)[keyof typeof InternshipsScalarFieldEnum]


  export const Internship_applicationsScalarFieldEnum: {
    id: 'id',
    internship_id: 'internship_id',
    student_id: 'student_id',
    status: 'status',
    submission_url: 'submission_url',
    score: 'score',
    applied_at: 'applied_at'
  };

  export type Internship_applicationsScalarFieldEnum = (typeof Internship_applicationsScalarFieldEnum)[keyof typeof Internship_applicationsScalarFieldEnum]


  export const Logbook_entriesScalarFieldEnum: {
    id: 'id',
    applicationId: 'applicationId',
    date: 'date',
    taskDone: 'taskDone',
    proofUrl: 'proofUrl',
    hours_spent: 'hours_spent'
  };

  export type Logbook_entriesScalarFieldEnum = (typeof Logbook_entriesScalarFieldEnum)[keyof typeof Logbook_entriesScalarFieldEnum]


  export const Internship_evaluationScalarFieldEnum: {
    id: 'id',
    application_id: 'application_id',
    faculty_id: 'faculty_id',
    rubric_json: 'rubric_json',
    comments: 'comments',
    final_score: 'final_score'
  };

  export type Internship_evaluationScalarFieldEnum = (typeof Internship_evaluationScalarFieldEnum)[keyof typeof Internship_evaluationScalarFieldEnum]


  export const FacultyScalarFieldEnum: {
    id: 'id',
    instituteId: 'instituteId',
    userId: 'userId',
    name: 'name',
    department: 'department'
  };

  export type FacultyScalarFieldEnum = (typeof FacultyScalarFieldEnum)[keyof typeof FacultyScalarFieldEnum]


  export const CreditsScalarFieldEnum: {
    id: 'id',
    student_id: 'student_id',
    credits_earned: 'credits_earned'
  };

  export type CreditsScalarFieldEnum = (typeof CreditsScalarFieldEnum)[keyof typeof CreditsScalarFieldEnum]


  export const CertificatesScalarFieldEnum: {
    id: 'id',
    student_id: 'student_id',
    title: 'title',
    certificateUrl: 'certificateUrl',
    issuedAt: 'issuedAt'
  };

  export type CertificatesScalarFieldEnum = (typeof CertificatesScalarFieldEnum)[keyof typeof CertificatesScalarFieldEnum]


  export const NotificationsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    message: 'message',
    created_at: 'created_at'
  };

  export type NotificationsScalarFieldEnum = (typeof NotificationsScalarFieldEnum)[keyof typeof NotificationsScalarFieldEnum]


  export const User_notificationsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    notification_id: 'notification_id',
    isRead: 'isRead',
    read_at: 'read_at'
  };

  export type User_notificationsScalarFieldEnum = (typeof User_notificationsScalarFieldEnum)[keyof typeof User_notificationsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'CourseType'
   */
  export type EnumCourseTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CourseType'>
    


  /**
   * Reference to a field of type 'CourseType[]'
   */
  export type ListEnumCourseTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CourseType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'MentorSessionStatus'
   */
  export type EnumMentorSessionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MentorSessionStatus'>
    


  /**
   * Reference to a field of type 'MentorSessionStatus[]'
   */
  export type ListEnumMentorSessionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MentorSessionStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'InternshipStatus'
   */
  export type EnumInternshipStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InternshipStatus'>
    


  /**
   * Reference to a field of type 'InternshipStatus[]'
   */
  export type ListEnumInternshipStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InternshipStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: StringFilter<"users"> | string
    displayName?: StringFilter<"users"> | string
    role?: StringNullableListFilter<"users">
    email?: StringFilter<"users"> | string
    salt?: StringFilter<"users"> | string
    phone?: StringFilter<"users"> | string
    hashPassword?: StringFilter<"users"> | string
    courseEnrollments?: CourseEnrollmentsListRelationFilter
    courses_instructor?: CoursesListRelationFilter
    facultyProfile?: XOR<FacultyNullableRelationFilter, facultyWhereInput> | null
    institutions_admin?: InstitutionsListRelationFilter
    internships_industryUser?: InternshipsListRelationFilter
    mentors?: XOR<MentorsNullableRelationFilter, mentorsWhereInput> | null
    profiles?: XOR<ProfileNullableRelationFilter, profileWhereInput> | null
    user_notifications?: User_notificationsListRelationFilter
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    displayName?: SortOrder
    role?: SortOrder
    email?: SortOrder
    salt?: SortOrder
    phone?: SortOrder
    hashPassword?: SortOrder
    courseEnrollments?: courseEnrollmentsOrderByRelationAggregateInput
    courses_instructor?: coursesOrderByRelationAggregateInput
    facultyProfile?: facultyOrderByWithRelationInput
    institutions_admin?: institutionsOrderByRelationAggregateInput
    internships_industryUser?: internshipsOrderByRelationAggregateInput
    mentors?: mentorsOrderByWithRelationInput
    profiles?: profileOrderByWithRelationInput
    user_notifications?: user_notificationsOrderByRelationAggregateInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    displayName?: StringFilter<"users"> | string
    role?: StringNullableListFilter<"users">
    salt?: StringFilter<"users"> | string
    phone?: StringFilter<"users"> | string
    hashPassword?: StringFilter<"users"> | string
    courseEnrollments?: CourseEnrollmentsListRelationFilter
    courses_instructor?: CoursesListRelationFilter
    facultyProfile?: XOR<FacultyNullableRelationFilter, facultyWhereInput> | null
    institutions_admin?: InstitutionsListRelationFilter
    internships_industryUser?: InternshipsListRelationFilter
    mentors?: XOR<MentorsNullableRelationFilter, mentorsWhereInput> | null
    profiles?: XOR<ProfileNullableRelationFilter, profileWhereInput> | null
    user_notifications?: User_notificationsListRelationFilter
  }, "id" | "email">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    displayName?: SortOrder
    role?: SortOrder
    email?: SortOrder
    salt?: SortOrder
    phone?: SortOrder
    hashPassword?: SortOrder
    _count?: usersCountOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"users"> | string
    displayName?: StringWithAggregatesFilter<"users"> | string
    role?: StringNullableListFilter<"users">
    email?: StringWithAggregatesFilter<"users"> | string
    salt?: StringWithAggregatesFilter<"users"> | string
    phone?: StringWithAggregatesFilter<"users"> | string
    hashPassword?: StringWithAggregatesFilter<"users"> | string
  }

  export type institutionsWhereInput = {
    AND?: institutionsWhereInput | institutionsWhereInput[]
    OR?: institutionsWhereInput[]
    NOT?: institutionsWhereInput | institutionsWhereInput[]
    id?: StringFilter<"institutions"> | string
    instituteName?: StringFilter<"institutions"> | string
    state?: StringFilter<"institutions"> | string
    adminUserId?: StringFilter<"institutions"> | string
    createdAt?: DateTimeFilter<"institutions"> | Date | string
    faculty?: FacultyListRelationFilter
    adminUser?: XOR<UsersRelationFilter, usersWhereInput>
    profiles?: ProfileListRelationFilter
  }

  export type institutionsOrderByWithRelationInput = {
    id?: SortOrder
    instituteName?: SortOrder
    state?: SortOrder
    adminUserId?: SortOrder
    createdAt?: SortOrder
    faculty?: facultyOrderByRelationAggregateInput
    adminUser?: usersOrderByWithRelationInput
    profiles?: profileOrderByRelationAggregateInput
  }

  export type institutionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: institutionsWhereInput | institutionsWhereInput[]
    OR?: institutionsWhereInput[]
    NOT?: institutionsWhereInput | institutionsWhereInput[]
    instituteName?: StringFilter<"institutions"> | string
    state?: StringFilter<"institutions"> | string
    adminUserId?: StringFilter<"institutions"> | string
    createdAt?: DateTimeFilter<"institutions"> | Date | string
    faculty?: FacultyListRelationFilter
    adminUser?: XOR<UsersRelationFilter, usersWhereInput>
    profiles?: ProfileListRelationFilter
  }, "id">

  export type institutionsOrderByWithAggregationInput = {
    id?: SortOrder
    instituteName?: SortOrder
    state?: SortOrder
    adminUserId?: SortOrder
    createdAt?: SortOrder
    _count?: institutionsCountOrderByAggregateInput
    _max?: institutionsMaxOrderByAggregateInput
    _min?: institutionsMinOrderByAggregateInput
  }

  export type institutionsScalarWhereWithAggregatesInput = {
    AND?: institutionsScalarWhereWithAggregatesInput | institutionsScalarWhereWithAggregatesInput[]
    OR?: institutionsScalarWhereWithAggregatesInput[]
    NOT?: institutionsScalarWhereWithAggregatesInput | institutionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"institutions"> | string
    instituteName?: StringWithAggregatesFilter<"institutions"> | string
    state?: StringWithAggregatesFilter<"institutions"> | string
    adminUserId?: StringWithAggregatesFilter<"institutions"> | string
    createdAt?: DateTimeWithAggregatesFilter<"institutions"> | Date | string
  }

  export type profileWhereInput = {
    AND?: profileWhereInput | profileWhereInput[]
    OR?: profileWhereInput[]
    NOT?: profileWhereInput | profileWhereInput[]
    id?: StringFilter<"profile"> | string
    userId?: StringFilter<"profile"> | string
    bio?: StringNullableFilter<"profile"> | string | null
    gender?: StringNullableFilter<"profile"> | string | null
    DOB?: DateTimeNullableFilter<"profile"> | Date | string | null
    avatarURL?: StringNullableFilter<"profile"> | string | null
    github?: StringNullableFilter<"profile"> | string | null
    linkedin?: StringNullableFilter<"profile"> | string | null
    skills?: StringNullableListFilter<"profile">
    interests?: StringNullableListFilter<"profile">
    department?: StringNullableFilter<"profile"> | string | null
    resourceId?: StringNullableFilter<"profile"> | string | null
    instituteId?: StringFilter<"profile"> | string
    facultyId?: StringNullableFilter<"profile"> | string | null
    certificates?: CertificatesListRelationFilter
    credits?: CreditsListRelationFilter
    internshipApplications?: Internship_applicationsListRelationFilter
    mentorReviews?: MentorReviewsListRelationFilter
    mentorSessions?: MentorSessionsListRelationFilter
    portfolioProjects?: PortfolioProjectsListRelationFilter
    faculty?: XOR<FacultyNullableRelationFilter, facultyWhereInput> | null
    institution?: XOR<InstitutionsRelationFilter, institutionsWhereInput>
    user?: XOR<UsersRelationFilter, usersWhereInput>
    learningProgress?: StudentLearningProgressListRelationFilter
  }

  export type profileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    bio?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    DOB?: SortOrderInput | SortOrder
    avatarURL?: SortOrderInput | SortOrder
    github?: SortOrderInput | SortOrder
    linkedin?: SortOrderInput | SortOrder
    skills?: SortOrder
    interests?: SortOrder
    department?: SortOrderInput | SortOrder
    resourceId?: SortOrderInput | SortOrder
    instituteId?: SortOrder
    facultyId?: SortOrderInput | SortOrder
    certificates?: certificatesOrderByRelationAggregateInput
    credits?: creditsOrderByRelationAggregateInput
    internshipApplications?: internship_applicationsOrderByRelationAggregateInput
    mentorReviews?: mentorReviewsOrderByRelationAggregateInput
    mentorSessions?: mentorSessionsOrderByRelationAggregateInput
    portfolioProjects?: portfolioProjectsOrderByRelationAggregateInput
    faculty?: facultyOrderByWithRelationInput
    institution?: institutionsOrderByWithRelationInput
    user?: usersOrderByWithRelationInput
    learningProgress?: studentLearningProgressOrderByRelationAggregateInput
  }

  export type profileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: profileWhereInput | profileWhereInput[]
    OR?: profileWhereInput[]
    NOT?: profileWhereInput | profileWhereInput[]
    bio?: StringNullableFilter<"profile"> | string | null
    gender?: StringNullableFilter<"profile"> | string | null
    DOB?: DateTimeNullableFilter<"profile"> | Date | string | null
    avatarURL?: StringNullableFilter<"profile"> | string | null
    github?: StringNullableFilter<"profile"> | string | null
    linkedin?: StringNullableFilter<"profile"> | string | null
    skills?: StringNullableListFilter<"profile">
    interests?: StringNullableListFilter<"profile">
    department?: StringNullableFilter<"profile"> | string | null
    resourceId?: StringNullableFilter<"profile"> | string | null
    instituteId?: StringFilter<"profile"> | string
    facultyId?: StringNullableFilter<"profile"> | string | null
    certificates?: CertificatesListRelationFilter
    credits?: CreditsListRelationFilter
    internshipApplications?: Internship_applicationsListRelationFilter
    mentorReviews?: MentorReviewsListRelationFilter
    mentorSessions?: MentorSessionsListRelationFilter
    portfolioProjects?: PortfolioProjectsListRelationFilter
    faculty?: XOR<FacultyNullableRelationFilter, facultyWhereInput> | null
    institution?: XOR<InstitutionsRelationFilter, institutionsWhereInput>
    user?: XOR<UsersRelationFilter, usersWhereInput>
    learningProgress?: StudentLearningProgressListRelationFilter
  }, "id" | "userId">

  export type profileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    bio?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    DOB?: SortOrderInput | SortOrder
    avatarURL?: SortOrderInput | SortOrder
    github?: SortOrderInput | SortOrder
    linkedin?: SortOrderInput | SortOrder
    skills?: SortOrder
    interests?: SortOrder
    department?: SortOrderInput | SortOrder
    resourceId?: SortOrderInput | SortOrder
    instituteId?: SortOrder
    facultyId?: SortOrderInput | SortOrder
    _count?: profileCountOrderByAggregateInput
    _max?: profileMaxOrderByAggregateInput
    _min?: profileMinOrderByAggregateInput
  }

  export type profileScalarWhereWithAggregatesInput = {
    AND?: profileScalarWhereWithAggregatesInput | profileScalarWhereWithAggregatesInput[]
    OR?: profileScalarWhereWithAggregatesInput[]
    NOT?: profileScalarWhereWithAggregatesInput | profileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"profile"> | string
    userId?: StringWithAggregatesFilter<"profile"> | string
    bio?: StringNullableWithAggregatesFilter<"profile"> | string | null
    gender?: StringNullableWithAggregatesFilter<"profile"> | string | null
    DOB?: DateTimeNullableWithAggregatesFilter<"profile"> | Date | string | null
    avatarURL?: StringNullableWithAggregatesFilter<"profile"> | string | null
    github?: StringNullableWithAggregatesFilter<"profile"> | string | null
    linkedin?: StringNullableWithAggregatesFilter<"profile"> | string | null
    skills?: StringNullableListFilter<"profile">
    interests?: StringNullableListFilter<"profile">
    department?: StringNullableWithAggregatesFilter<"profile"> | string | null
    resourceId?: StringNullableWithAggregatesFilter<"profile"> | string | null
    instituteId?: StringWithAggregatesFilter<"profile"> | string
    facultyId?: StringNullableWithAggregatesFilter<"profile"> | string | null
  }

  export type roadmapsWhereInput = {
    AND?: roadmapsWhereInput | roadmapsWhereInput[]
    OR?: roadmapsWhereInput[]
    NOT?: roadmapsWhereInput | roadmapsWhereInput[]
    id?: StringFilter<"roadmaps"> | string
    title?: StringFilter<"roadmaps"> | string
    description?: StringFilter<"roadmaps"> | string
    domain?: StringFilter<"roadmaps"> | string
    checkpoints?: CheckpointsListRelationFilter
  }

  export type roadmapsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    domain?: SortOrder
    checkpoints?: checkpointsOrderByRelationAggregateInput
  }

  export type roadmapsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: roadmapsWhereInput | roadmapsWhereInput[]
    OR?: roadmapsWhereInput[]
    NOT?: roadmapsWhereInput | roadmapsWhereInput[]
    title?: StringFilter<"roadmaps"> | string
    description?: StringFilter<"roadmaps"> | string
    domain?: StringFilter<"roadmaps"> | string
    checkpoints?: CheckpointsListRelationFilter
  }, "id">

  export type roadmapsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    domain?: SortOrder
    _count?: roadmapsCountOrderByAggregateInput
    _max?: roadmapsMaxOrderByAggregateInput
    _min?: roadmapsMinOrderByAggregateInput
  }

  export type roadmapsScalarWhereWithAggregatesInput = {
    AND?: roadmapsScalarWhereWithAggregatesInput | roadmapsScalarWhereWithAggregatesInput[]
    OR?: roadmapsScalarWhereWithAggregatesInput[]
    NOT?: roadmapsScalarWhereWithAggregatesInput | roadmapsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"roadmaps"> | string
    title?: StringWithAggregatesFilter<"roadmaps"> | string
    description?: StringWithAggregatesFilter<"roadmaps"> | string
    domain?: StringWithAggregatesFilter<"roadmaps"> | string
  }

  export type checkpointsWhereInput = {
    AND?: checkpointsWhereInput | checkpointsWhereInput[]
    OR?: checkpointsWhereInput[]
    NOT?: checkpointsWhereInput | checkpointsWhereInput[]
    id?: StringFilter<"checkpoints"> | string
    roadmapId?: StringFilter<"checkpoints"> | string
    title?: StringFilter<"checkpoints"> | string
    description?: StringFilter<"checkpoints"> | string
    resourceType?: StringFilter<"checkpoints"> | string
    resourceUrl?: StringFilter<"checkpoints"> | string
    roadmap?: XOR<RoadmapsRelationFilter, roadmapsWhereInput>
    progress?: StudentLearningProgressListRelationFilter
  }

  export type checkpointsOrderByWithRelationInput = {
    id?: SortOrder
    roadmapId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    resourceType?: SortOrder
    resourceUrl?: SortOrder
    roadmap?: roadmapsOrderByWithRelationInput
    progress?: studentLearningProgressOrderByRelationAggregateInput
  }

  export type checkpointsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: checkpointsWhereInput | checkpointsWhereInput[]
    OR?: checkpointsWhereInput[]
    NOT?: checkpointsWhereInput | checkpointsWhereInput[]
    roadmapId?: StringFilter<"checkpoints"> | string
    title?: StringFilter<"checkpoints"> | string
    description?: StringFilter<"checkpoints"> | string
    resourceType?: StringFilter<"checkpoints"> | string
    resourceUrl?: StringFilter<"checkpoints"> | string
    roadmap?: XOR<RoadmapsRelationFilter, roadmapsWhereInput>
    progress?: StudentLearningProgressListRelationFilter
  }, "id">

  export type checkpointsOrderByWithAggregationInput = {
    id?: SortOrder
    roadmapId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    resourceType?: SortOrder
    resourceUrl?: SortOrder
    _count?: checkpointsCountOrderByAggregateInput
    _max?: checkpointsMaxOrderByAggregateInput
    _min?: checkpointsMinOrderByAggregateInput
  }

  export type checkpointsScalarWhereWithAggregatesInput = {
    AND?: checkpointsScalarWhereWithAggregatesInput | checkpointsScalarWhereWithAggregatesInput[]
    OR?: checkpointsScalarWhereWithAggregatesInput[]
    NOT?: checkpointsScalarWhereWithAggregatesInput | checkpointsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"checkpoints"> | string
    roadmapId?: StringWithAggregatesFilter<"checkpoints"> | string
    title?: StringWithAggregatesFilter<"checkpoints"> | string
    description?: StringWithAggregatesFilter<"checkpoints"> | string
    resourceType?: StringWithAggregatesFilter<"checkpoints"> | string
    resourceUrl?: StringWithAggregatesFilter<"checkpoints"> | string
  }

  export type studentLearningProgressWhereInput = {
    AND?: studentLearningProgressWhereInput | studentLearningProgressWhereInput[]
    OR?: studentLearningProgressWhereInput[]
    NOT?: studentLearningProgressWhereInput | studentLearningProgressWhereInput[]
    id?: StringFilter<"studentLearningProgress"> | string
    profileId?: StringFilter<"studentLearningProgress"> | string
    checkpointId?: StringFilter<"studentLearningProgress"> | string
    isCompleted?: BoolFilter<"studentLearningProgress"> | boolean
    completedAt?: DateTimeNullableFilter<"studentLearningProgress"> | Date | string | null
    checkpoint?: XOR<CheckpointsRelationFilter, checkpointsWhereInput>
    profile?: XOR<ProfileRelationFilter, profileWhereInput>
  }

  export type studentLearningProgressOrderByWithRelationInput = {
    id?: SortOrder
    profileId?: SortOrder
    checkpointId?: SortOrder
    isCompleted?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    checkpoint?: checkpointsOrderByWithRelationInput
    profile?: profileOrderByWithRelationInput
  }

  export type studentLearningProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: studentLearningProgressWhereInput | studentLearningProgressWhereInput[]
    OR?: studentLearningProgressWhereInput[]
    NOT?: studentLearningProgressWhereInput | studentLearningProgressWhereInput[]
    profileId?: StringFilter<"studentLearningProgress"> | string
    checkpointId?: StringFilter<"studentLearningProgress"> | string
    isCompleted?: BoolFilter<"studentLearningProgress"> | boolean
    completedAt?: DateTimeNullableFilter<"studentLearningProgress"> | Date | string | null
    checkpoint?: XOR<CheckpointsRelationFilter, checkpointsWhereInput>
    profile?: XOR<ProfileRelationFilter, profileWhereInput>
  }, "id">

  export type studentLearningProgressOrderByWithAggregationInput = {
    id?: SortOrder
    profileId?: SortOrder
    checkpointId?: SortOrder
    isCompleted?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: studentLearningProgressCountOrderByAggregateInput
    _max?: studentLearningProgressMaxOrderByAggregateInput
    _min?: studentLearningProgressMinOrderByAggregateInput
  }

  export type studentLearningProgressScalarWhereWithAggregatesInput = {
    AND?: studentLearningProgressScalarWhereWithAggregatesInput | studentLearningProgressScalarWhereWithAggregatesInput[]
    OR?: studentLearningProgressScalarWhereWithAggregatesInput[]
    NOT?: studentLearningProgressScalarWhereWithAggregatesInput | studentLearningProgressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"studentLearningProgress"> | string
    profileId?: StringWithAggregatesFilter<"studentLearningProgress"> | string
    checkpointId?: StringWithAggregatesFilter<"studentLearningProgress"> | string
    isCompleted?: BoolWithAggregatesFilter<"studentLearningProgress"> | boolean
    completedAt?: DateTimeNullableWithAggregatesFilter<"studentLearningProgress"> | Date | string | null
  }

  export type coursesWhereInput = {
    AND?: coursesWhereInput | coursesWhereInput[]
    OR?: coursesWhereInput[]
    NOT?: coursesWhereInput | coursesWhereInput[]
    id?: StringFilter<"courses"> | string
    title?: StringFilter<"courses"> | string
    description?: StringFilter<"courses"> | string
    type?: EnumCourseTypeFilter<"courses"> | $Enums.CourseType
    price?: FloatNullableFilter<"courses"> | number | null
    instructorId?: StringFilter<"courses"> | string
    thumbnail_url?: StringNullableFilter<"courses"> | string | null
    created_at?: DateTimeFilter<"courses"> | Date | string
    enrollments?: CourseEnrollmentsListRelationFilter
    instructor?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type coursesOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    price?: SortOrderInput | SortOrder
    instructorId?: SortOrder
    thumbnail_url?: SortOrderInput | SortOrder
    created_at?: SortOrder
    enrollments?: courseEnrollmentsOrderByRelationAggregateInput
    instructor?: usersOrderByWithRelationInput
  }

  export type coursesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: coursesWhereInput | coursesWhereInput[]
    OR?: coursesWhereInput[]
    NOT?: coursesWhereInput | coursesWhereInput[]
    title?: StringFilter<"courses"> | string
    description?: StringFilter<"courses"> | string
    type?: EnumCourseTypeFilter<"courses"> | $Enums.CourseType
    price?: FloatNullableFilter<"courses"> | number | null
    instructorId?: StringFilter<"courses"> | string
    thumbnail_url?: StringNullableFilter<"courses"> | string | null
    created_at?: DateTimeFilter<"courses"> | Date | string
    enrollments?: CourseEnrollmentsListRelationFilter
    instructor?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id">

  export type coursesOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    price?: SortOrderInput | SortOrder
    instructorId?: SortOrder
    thumbnail_url?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: coursesCountOrderByAggregateInput
    _avg?: coursesAvgOrderByAggregateInput
    _max?: coursesMaxOrderByAggregateInput
    _min?: coursesMinOrderByAggregateInput
    _sum?: coursesSumOrderByAggregateInput
  }

  export type coursesScalarWhereWithAggregatesInput = {
    AND?: coursesScalarWhereWithAggregatesInput | coursesScalarWhereWithAggregatesInput[]
    OR?: coursesScalarWhereWithAggregatesInput[]
    NOT?: coursesScalarWhereWithAggregatesInput | coursesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"courses"> | string
    title?: StringWithAggregatesFilter<"courses"> | string
    description?: StringWithAggregatesFilter<"courses"> | string
    type?: EnumCourseTypeWithAggregatesFilter<"courses"> | $Enums.CourseType
    price?: FloatNullableWithAggregatesFilter<"courses"> | number | null
    instructorId?: StringWithAggregatesFilter<"courses"> | string
    thumbnail_url?: StringNullableWithAggregatesFilter<"courses"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"courses"> | Date | string
  }

  export type courseEnrollmentsWhereInput = {
    AND?: courseEnrollmentsWhereInput | courseEnrollmentsWhereInput[]
    OR?: courseEnrollmentsWhereInput[]
    NOT?: courseEnrollmentsWhereInput | courseEnrollmentsWhereInput[]
    id?: StringFilter<"courseEnrollments"> | string
    courseId?: StringFilter<"courseEnrollments"> | string
    userId?: StringFilter<"courseEnrollments"> | string
    progressPercent?: FloatNullableFilter<"courseEnrollments"> | number | null
    enrolledAt?: DateTimeFilter<"courseEnrollments"> | Date | string
    course?: XOR<CoursesRelationFilter, coursesWhereInput>
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type courseEnrollmentsOrderByWithRelationInput = {
    id?: SortOrder
    courseId?: SortOrder
    userId?: SortOrder
    progressPercent?: SortOrderInput | SortOrder
    enrolledAt?: SortOrder
    course?: coursesOrderByWithRelationInput
    user?: usersOrderByWithRelationInput
  }

  export type courseEnrollmentsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: courseEnrollmentsWhereInput | courseEnrollmentsWhereInput[]
    OR?: courseEnrollmentsWhereInput[]
    NOT?: courseEnrollmentsWhereInput | courseEnrollmentsWhereInput[]
    courseId?: StringFilter<"courseEnrollments"> | string
    userId?: StringFilter<"courseEnrollments"> | string
    progressPercent?: FloatNullableFilter<"courseEnrollments"> | number | null
    enrolledAt?: DateTimeFilter<"courseEnrollments"> | Date | string
    course?: XOR<CoursesRelationFilter, coursesWhereInput>
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id">

  export type courseEnrollmentsOrderByWithAggregationInput = {
    id?: SortOrder
    courseId?: SortOrder
    userId?: SortOrder
    progressPercent?: SortOrderInput | SortOrder
    enrolledAt?: SortOrder
    _count?: courseEnrollmentsCountOrderByAggregateInput
    _avg?: courseEnrollmentsAvgOrderByAggregateInput
    _max?: courseEnrollmentsMaxOrderByAggregateInput
    _min?: courseEnrollmentsMinOrderByAggregateInput
    _sum?: courseEnrollmentsSumOrderByAggregateInput
  }

  export type courseEnrollmentsScalarWhereWithAggregatesInput = {
    AND?: courseEnrollmentsScalarWhereWithAggregatesInput | courseEnrollmentsScalarWhereWithAggregatesInput[]
    OR?: courseEnrollmentsScalarWhereWithAggregatesInput[]
    NOT?: courseEnrollmentsScalarWhereWithAggregatesInput | courseEnrollmentsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"courseEnrollments"> | string
    courseId?: StringWithAggregatesFilter<"courseEnrollments"> | string
    userId?: StringWithAggregatesFilter<"courseEnrollments"> | string
    progressPercent?: FloatNullableWithAggregatesFilter<"courseEnrollments"> | number | null
    enrolledAt?: DateTimeWithAggregatesFilter<"courseEnrollments"> | Date | string
  }

  export type mentorsWhereInput = {
    AND?: mentorsWhereInput | mentorsWhereInput[]
    OR?: mentorsWhereInput[]
    NOT?: mentorsWhereInput | mentorsWhereInput[]
    id?: StringFilter<"mentors"> | string
    user_id?: StringFilter<"mentors"> | string
    expertise?: JsonNullableFilter<"mentors">
    rating?: FloatNullableFilter<"mentors"> | number | null
    bio?: StringNullableFilter<"mentors"> | string | null
    reviews?: MentorReviewsListRelationFilter
    sessions?: MentorSessionsListRelationFilter
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type mentorsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    expertise?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    reviews?: mentorReviewsOrderByRelationAggregateInput
    sessions?: mentorSessionsOrderByRelationAggregateInput
    user?: usersOrderByWithRelationInput
  }

  export type mentorsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    user_id?: string
    AND?: mentorsWhereInput | mentorsWhereInput[]
    OR?: mentorsWhereInput[]
    NOT?: mentorsWhereInput | mentorsWhereInput[]
    expertise?: JsonNullableFilter<"mentors">
    rating?: FloatNullableFilter<"mentors"> | number | null
    bio?: StringNullableFilter<"mentors"> | string | null
    reviews?: MentorReviewsListRelationFilter
    sessions?: MentorSessionsListRelationFilter
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id" | "user_id">

  export type mentorsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    expertise?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    _count?: mentorsCountOrderByAggregateInput
    _avg?: mentorsAvgOrderByAggregateInput
    _max?: mentorsMaxOrderByAggregateInput
    _min?: mentorsMinOrderByAggregateInput
    _sum?: mentorsSumOrderByAggregateInput
  }

  export type mentorsScalarWhereWithAggregatesInput = {
    AND?: mentorsScalarWhereWithAggregatesInput | mentorsScalarWhereWithAggregatesInput[]
    OR?: mentorsScalarWhereWithAggregatesInput[]
    NOT?: mentorsScalarWhereWithAggregatesInput | mentorsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"mentors"> | string
    user_id?: StringWithAggregatesFilter<"mentors"> | string
    expertise?: JsonNullableWithAggregatesFilter<"mentors">
    rating?: FloatNullableWithAggregatesFilter<"mentors"> | number | null
    bio?: StringNullableWithAggregatesFilter<"mentors"> | string | null
  }

  export type mentorSessionsWhereInput = {
    AND?: mentorSessionsWhereInput | mentorSessionsWhereInput[]
    OR?: mentorSessionsWhereInput[]
    NOT?: mentorSessionsWhereInput | mentorSessionsWhereInput[]
    id?: StringFilter<"mentorSessions"> | string
    studentId?: StringFilter<"mentorSessions"> | string
    mentorId?: StringFilter<"mentorSessions"> | string
    scheduled_at?: DateTimeFilter<"mentorSessions"> | Date | string
    status?: EnumMentorSessionStatusFilter<"mentorSessions"> | $Enums.MentorSessionStatus
    meeting_link?: StringNullableFilter<"mentorSessions"> | string | null
    mentor?: XOR<MentorsRelationFilter, mentorsWhereInput>
    student?: XOR<ProfileRelationFilter, profileWhereInput>
  }

  export type mentorSessionsOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    mentorId?: SortOrder
    scheduled_at?: SortOrder
    status?: SortOrder
    meeting_link?: SortOrderInput | SortOrder
    mentor?: mentorsOrderByWithRelationInput
    student?: profileOrderByWithRelationInput
  }

  export type mentorSessionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: mentorSessionsWhereInput | mentorSessionsWhereInput[]
    OR?: mentorSessionsWhereInput[]
    NOT?: mentorSessionsWhereInput | mentorSessionsWhereInput[]
    studentId?: StringFilter<"mentorSessions"> | string
    mentorId?: StringFilter<"mentorSessions"> | string
    scheduled_at?: DateTimeFilter<"mentorSessions"> | Date | string
    status?: EnumMentorSessionStatusFilter<"mentorSessions"> | $Enums.MentorSessionStatus
    meeting_link?: StringNullableFilter<"mentorSessions"> | string | null
    mentor?: XOR<MentorsRelationFilter, mentorsWhereInput>
    student?: XOR<ProfileRelationFilter, profileWhereInput>
  }, "id">

  export type mentorSessionsOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    mentorId?: SortOrder
    scheduled_at?: SortOrder
    status?: SortOrder
    meeting_link?: SortOrderInput | SortOrder
    _count?: mentorSessionsCountOrderByAggregateInput
    _max?: mentorSessionsMaxOrderByAggregateInput
    _min?: mentorSessionsMinOrderByAggregateInput
  }

  export type mentorSessionsScalarWhereWithAggregatesInput = {
    AND?: mentorSessionsScalarWhereWithAggregatesInput | mentorSessionsScalarWhereWithAggregatesInput[]
    OR?: mentorSessionsScalarWhereWithAggregatesInput[]
    NOT?: mentorSessionsScalarWhereWithAggregatesInput | mentorSessionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"mentorSessions"> | string
    studentId?: StringWithAggregatesFilter<"mentorSessions"> | string
    mentorId?: StringWithAggregatesFilter<"mentorSessions"> | string
    scheduled_at?: DateTimeWithAggregatesFilter<"mentorSessions"> | Date | string
    status?: EnumMentorSessionStatusWithAggregatesFilter<"mentorSessions"> | $Enums.MentorSessionStatus
    meeting_link?: StringNullableWithAggregatesFilter<"mentorSessions"> | string | null
  }

  export type mentorReviewsWhereInput = {
    AND?: mentorReviewsWhereInput | mentorReviewsWhereInput[]
    OR?: mentorReviewsWhereInput[]
    NOT?: mentorReviewsWhereInput | mentorReviewsWhereInput[]
    id?: StringFilter<"mentorReviews"> | string
    mentorId?: StringFilter<"mentorReviews"> | string
    rating?: FloatFilter<"mentorReviews"> | number
    reviews?: StringNullableFilter<"mentorReviews"> | string | null
    studentId?: StringFilter<"mentorReviews"> | string
    mentor?: XOR<MentorsRelationFilter, mentorsWhereInput>
    student?: XOR<ProfileRelationFilter, profileWhereInput>
  }

  export type mentorReviewsOrderByWithRelationInput = {
    id?: SortOrder
    mentorId?: SortOrder
    rating?: SortOrder
    reviews?: SortOrderInput | SortOrder
    studentId?: SortOrder
    mentor?: mentorsOrderByWithRelationInput
    student?: profileOrderByWithRelationInput
  }

  export type mentorReviewsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: mentorReviewsWhereInput | mentorReviewsWhereInput[]
    OR?: mentorReviewsWhereInput[]
    NOT?: mentorReviewsWhereInput | mentorReviewsWhereInput[]
    mentorId?: StringFilter<"mentorReviews"> | string
    rating?: FloatFilter<"mentorReviews"> | number
    reviews?: StringNullableFilter<"mentorReviews"> | string | null
    studentId?: StringFilter<"mentorReviews"> | string
    mentor?: XOR<MentorsRelationFilter, mentorsWhereInput>
    student?: XOR<ProfileRelationFilter, profileWhereInput>
  }, "id">

  export type mentorReviewsOrderByWithAggregationInput = {
    id?: SortOrder
    mentorId?: SortOrder
    rating?: SortOrder
    reviews?: SortOrderInput | SortOrder
    studentId?: SortOrder
    _count?: mentorReviewsCountOrderByAggregateInput
    _avg?: mentorReviewsAvgOrderByAggregateInput
    _max?: mentorReviewsMaxOrderByAggregateInput
    _min?: mentorReviewsMinOrderByAggregateInput
    _sum?: mentorReviewsSumOrderByAggregateInput
  }

  export type mentorReviewsScalarWhereWithAggregatesInput = {
    AND?: mentorReviewsScalarWhereWithAggregatesInput | mentorReviewsScalarWhereWithAggregatesInput[]
    OR?: mentorReviewsScalarWhereWithAggregatesInput[]
    NOT?: mentorReviewsScalarWhereWithAggregatesInput | mentorReviewsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"mentorReviews"> | string
    mentorId?: StringWithAggregatesFilter<"mentorReviews"> | string
    rating?: FloatWithAggregatesFilter<"mentorReviews"> | number
    reviews?: StringNullableWithAggregatesFilter<"mentorReviews"> | string | null
    studentId?: StringWithAggregatesFilter<"mentorReviews"> | string
  }

  export type portfolioProjectsWhereInput = {
    AND?: portfolioProjectsWhereInput | portfolioProjectsWhereInput[]
    OR?: portfolioProjectsWhereInput[]
    NOT?: portfolioProjectsWhereInput | portfolioProjectsWhereInput[]
    id?: StringFilter<"portfolioProjects"> | string
    user_id?: StringFilter<"portfolioProjects"> | string
    title?: StringFilter<"portfolioProjects"> | string
    description?: StringNullableFilter<"portfolioProjects"> | string | null
    github_url?: StringNullableFilter<"portfolioProjects"> | string | null
    live_url?: StringNullableFilter<"portfolioProjects"> | string | null
    tags?: StringNullableListFilter<"portfolioProjects">
    user?: XOR<ProfileRelationFilter, profileWhereInput>
  }

  export type portfolioProjectsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    github_url?: SortOrderInput | SortOrder
    live_url?: SortOrderInput | SortOrder
    tags?: SortOrder
    user?: profileOrderByWithRelationInput
  }

  export type portfolioProjectsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: portfolioProjectsWhereInput | portfolioProjectsWhereInput[]
    OR?: portfolioProjectsWhereInput[]
    NOT?: portfolioProjectsWhereInput | portfolioProjectsWhereInput[]
    user_id?: StringFilter<"portfolioProjects"> | string
    title?: StringFilter<"portfolioProjects"> | string
    description?: StringNullableFilter<"portfolioProjects"> | string | null
    github_url?: StringNullableFilter<"portfolioProjects"> | string | null
    live_url?: StringNullableFilter<"portfolioProjects"> | string | null
    tags?: StringNullableListFilter<"portfolioProjects">
    user?: XOR<ProfileRelationFilter, profileWhereInput>
  }, "id">

  export type portfolioProjectsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    github_url?: SortOrderInput | SortOrder
    live_url?: SortOrderInput | SortOrder
    tags?: SortOrder
    _count?: portfolioProjectsCountOrderByAggregateInput
    _max?: portfolioProjectsMaxOrderByAggregateInput
    _min?: portfolioProjectsMinOrderByAggregateInput
  }

  export type portfolioProjectsScalarWhereWithAggregatesInput = {
    AND?: portfolioProjectsScalarWhereWithAggregatesInput | portfolioProjectsScalarWhereWithAggregatesInput[]
    OR?: portfolioProjectsScalarWhereWithAggregatesInput[]
    NOT?: portfolioProjectsScalarWhereWithAggregatesInput | portfolioProjectsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"portfolioProjects"> | string
    user_id?: StringWithAggregatesFilter<"portfolioProjects"> | string
    title?: StringWithAggregatesFilter<"portfolioProjects"> | string
    description?: StringNullableWithAggregatesFilter<"portfolioProjects"> | string | null
    github_url?: StringNullableWithAggregatesFilter<"portfolioProjects"> | string | null
    live_url?: StringNullableWithAggregatesFilter<"portfolioProjects"> | string | null
    tags?: StringNullableListFilter<"portfolioProjects">
  }

  export type internshipsWhereInput = {
    AND?: internshipsWhereInput | internshipsWhereInput[]
    OR?: internshipsWhereInput[]
    NOT?: internshipsWhereInput | internshipsWhereInput[]
    id?: StringFilter<"internships"> | string
    industry_user_id?: StringFilter<"internships"> | string
    title?: StringFilter<"internships"> | string
    description?: StringFilter<"internships"> | string
    type?: StringFilter<"internships"> | string
    stipend?: FloatNullableFilter<"internships"> | number | null
    location?: StringFilter<"internships"> | string
    required_skills?: JsonFilter<"internships">
    duration_weeks?: IntFilter<"internships"> | number
    created_at?: DateTimeFilter<"internships"> | Date | string
    applications?: Internship_applicationsListRelationFilter
    industryUser?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type internshipsOrderByWithRelationInput = {
    id?: SortOrder
    industry_user_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    stipend?: SortOrderInput | SortOrder
    location?: SortOrder
    required_skills?: SortOrder
    duration_weeks?: SortOrder
    created_at?: SortOrder
    applications?: internship_applicationsOrderByRelationAggregateInput
    industryUser?: usersOrderByWithRelationInput
  }

  export type internshipsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: internshipsWhereInput | internshipsWhereInput[]
    OR?: internshipsWhereInput[]
    NOT?: internshipsWhereInput | internshipsWhereInput[]
    industry_user_id?: StringFilter<"internships"> | string
    title?: StringFilter<"internships"> | string
    description?: StringFilter<"internships"> | string
    type?: StringFilter<"internships"> | string
    stipend?: FloatNullableFilter<"internships"> | number | null
    location?: StringFilter<"internships"> | string
    required_skills?: JsonFilter<"internships">
    duration_weeks?: IntFilter<"internships"> | number
    created_at?: DateTimeFilter<"internships"> | Date | string
    applications?: Internship_applicationsListRelationFilter
    industryUser?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id">

  export type internshipsOrderByWithAggregationInput = {
    id?: SortOrder
    industry_user_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    stipend?: SortOrderInput | SortOrder
    location?: SortOrder
    required_skills?: SortOrder
    duration_weeks?: SortOrder
    created_at?: SortOrder
    _count?: internshipsCountOrderByAggregateInput
    _avg?: internshipsAvgOrderByAggregateInput
    _max?: internshipsMaxOrderByAggregateInput
    _min?: internshipsMinOrderByAggregateInput
    _sum?: internshipsSumOrderByAggregateInput
  }

  export type internshipsScalarWhereWithAggregatesInput = {
    AND?: internshipsScalarWhereWithAggregatesInput | internshipsScalarWhereWithAggregatesInput[]
    OR?: internshipsScalarWhereWithAggregatesInput[]
    NOT?: internshipsScalarWhereWithAggregatesInput | internshipsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"internships"> | string
    industry_user_id?: StringWithAggregatesFilter<"internships"> | string
    title?: StringWithAggregatesFilter<"internships"> | string
    description?: StringWithAggregatesFilter<"internships"> | string
    type?: StringWithAggregatesFilter<"internships"> | string
    stipend?: FloatNullableWithAggregatesFilter<"internships"> | number | null
    location?: StringWithAggregatesFilter<"internships"> | string
    required_skills?: JsonWithAggregatesFilter<"internships">
    duration_weeks?: IntWithAggregatesFilter<"internships"> | number
    created_at?: DateTimeWithAggregatesFilter<"internships"> | Date | string
  }

  export type internship_applicationsWhereInput = {
    AND?: internship_applicationsWhereInput | internship_applicationsWhereInput[]
    OR?: internship_applicationsWhereInput[]
    NOT?: internship_applicationsWhereInput | internship_applicationsWhereInput[]
    id?: StringFilter<"internship_applications"> | string
    internship_id?: StringFilter<"internship_applications"> | string
    student_id?: StringFilter<"internship_applications"> | string
    status?: EnumInternshipStatusFilter<"internship_applications"> | $Enums.InternshipStatus
    submission_url?: StringNullableFilter<"internship_applications"> | string | null
    score?: FloatNullableFilter<"internship_applications"> | number | null
    applied_at?: DateTimeFilter<"internship_applications"> | Date | string
    internship?: XOR<InternshipsRelationFilter, internshipsWhereInput>
    student?: XOR<ProfileRelationFilter, profileWhereInput>
    evaluations?: Internship_evaluationListRelationFilter
    logbookEntries?: Logbook_entriesListRelationFilter
  }

  export type internship_applicationsOrderByWithRelationInput = {
    id?: SortOrder
    internship_id?: SortOrder
    student_id?: SortOrder
    status?: SortOrder
    submission_url?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    applied_at?: SortOrder
    internship?: internshipsOrderByWithRelationInput
    student?: profileOrderByWithRelationInput
    evaluations?: internship_evaluationOrderByRelationAggregateInput
    logbookEntries?: logbook_entriesOrderByRelationAggregateInput
  }

  export type internship_applicationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: internship_applicationsWhereInput | internship_applicationsWhereInput[]
    OR?: internship_applicationsWhereInput[]
    NOT?: internship_applicationsWhereInput | internship_applicationsWhereInput[]
    internship_id?: StringFilter<"internship_applications"> | string
    student_id?: StringFilter<"internship_applications"> | string
    status?: EnumInternshipStatusFilter<"internship_applications"> | $Enums.InternshipStatus
    submission_url?: StringNullableFilter<"internship_applications"> | string | null
    score?: FloatNullableFilter<"internship_applications"> | number | null
    applied_at?: DateTimeFilter<"internship_applications"> | Date | string
    internship?: XOR<InternshipsRelationFilter, internshipsWhereInput>
    student?: XOR<ProfileRelationFilter, profileWhereInput>
    evaluations?: Internship_evaluationListRelationFilter
    logbookEntries?: Logbook_entriesListRelationFilter
  }, "id">

  export type internship_applicationsOrderByWithAggregationInput = {
    id?: SortOrder
    internship_id?: SortOrder
    student_id?: SortOrder
    status?: SortOrder
    submission_url?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    applied_at?: SortOrder
    _count?: internship_applicationsCountOrderByAggregateInput
    _avg?: internship_applicationsAvgOrderByAggregateInput
    _max?: internship_applicationsMaxOrderByAggregateInput
    _min?: internship_applicationsMinOrderByAggregateInput
    _sum?: internship_applicationsSumOrderByAggregateInput
  }

  export type internship_applicationsScalarWhereWithAggregatesInput = {
    AND?: internship_applicationsScalarWhereWithAggregatesInput | internship_applicationsScalarWhereWithAggregatesInput[]
    OR?: internship_applicationsScalarWhereWithAggregatesInput[]
    NOT?: internship_applicationsScalarWhereWithAggregatesInput | internship_applicationsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"internship_applications"> | string
    internship_id?: StringWithAggregatesFilter<"internship_applications"> | string
    student_id?: StringWithAggregatesFilter<"internship_applications"> | string
    status?: EnumInternshipStatusWithAggregatesFilter<"internship_applications"> | $Enums.InternshipStatus
    submission_url?: StringNullableWithAggregatesFilter<"internship_applications"> | string | null
    score?: FloatNullableWithAggregatesFilter<"internship_applications"> | number | null
    applied_at?: DateTimeWithAggregatesFilter<"internship_applications"> | Date | string
  }

  export type logbook_entriesWhereInput = {
    AND?: logbook_entriesWhereInput | logbook_entriesWhereInput[]
    OR?: logbook_entriesWhereInput[]
    NOT?: logbook_entriesWhereInput | logbook_entriesWhereInput[]
    id?: StringFilter<"logbook_entries"> | string
    applicationId?: StringFilter<"logbook_entries"> | string
    date?: DateTimeFilter<"logbook_entries"> | Date | string
    taskDone?: StringFilter<"logbook_entries"> | string
    proofUrl?: StringNullableFilter<"logbook_entries"> | string | null
    hours_spent?: IntFilter<"logbook_entries"> | number
    application?: XOR<Internship_applicationsRelationFilter, internship_applicationsWhereInput>
  }

  export type logbook_entriesOrderByWithRelationInput = {
    id?: SortOrder
    applicationId?: SortOrder
    date?: SortOrder
    taskDone?: SortOrder
    proofUrl?: SortOrderInput | SortOrder
    hours_spent?: SortOrder
    application?: internship_applicationsOrderByWithRelationInput
  }

  export type logbook_entriesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: logbook_entriesWhereInput | logbook_entriesWhereInput[]
    OR?: logbook_entriesWhereInput[]
    NOT?: logbook_entriesWhereInput | logbook_entriesWhereInput[]
    applicationId?: StringFilter<"logbook_entries"> | string
    date?: DateTimeFilter<"logbook_entries"> | Date | string
    taskDone?: StringFilter<"logbook_entries"> | string
    proofUrl?: StringNullableFilter<"logbook_entries"> | string | null
    hours_spent?: IntFilter<"logbook_entries"> | number
    application?: XOR<Internship_applicationsRelationFilter, internship_applicationsWhereInput>
  }, "id">

  export type logbook_entriesOrderByWithAggregationInput = {
    id?: SortOrder
    applicationId?: SortOrder
    date?: SortOrder
    taskDone?: SortOrder
    proofUrl?: SortOrderInput | SortOrder
    hours_spent?: SortOrder
    _count?: logbook_entriesCountOrderByAggregateInput
    _avg?: logbook_entriesAvgOrderByAggregateInput
    _max?: logbook_entriesMaxOrderByAggregateInput
    _min?: logbook_entriesMinOrderByAggregateInput
    _sum?: logbook_entriesSumOrderByAggregateInput
  }

  export type logbook_entriesScalarWhereWithAggregatesInput = {
    AND?: logbook_entriesScalarWhereWithAggregatesInput | logbook_entriesScalarWhereWithAggregatesInput[]
    OR?: logbook_entriesScalarWhereWithAggregatesInput[]
    NOT?: logbook_entriesScalarWhereWithAggregatesInput | logbook_entriesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"logbook_entries"> | string
    applicationId?: StringWithAggregatesFilter<"logbook_entries"> | string
    date?: DateTimeWithAggregatesFilter<"logbook_entries"> | Date | string
    taskDone?: StringWithAggregatesFilter<"logbook_entries"> | string
    proofUrl?: StringNullableWithAggregatesFilter<"logbook_entries"> | string | null
    hours_spent?: IntWithAggregatesFilter<"logbook_entries"> | number
  }

  export type internship_evaluationWhereInput = {
    AND?: internship_evaluationWhereInput | internship_evaluationWhereInput[]
    OR?: internship_evaluationWhereInput[]
    NOT?: internship_evaluationWhereInput | internship_evaluationWhereInput[]
    id?: StringFilter<"internship_evaluation"> | string
    application_id?: StringFilter<"internship_evaluation"> | string
    faculty_id?: StringFilter<"internship_evaluation"> | string
    rubric_json?: JsonNullableFilter<"internship_evaluation">
    comments?: StringNullableFilter<"internship_evaluation"> | string | null
    final_score?: FloatNullableFilter<"internship_evaluation"> | number | null
    application?: XOR<Internship_applicationsRelationFilter, internship_applicationsWhereInput>
    faculty?: XOR<FacultyRelationFilter, facultyWhereInput>
  }

  export type internship_evaluationOrderByWithRelationInput = {
    id?: SortOrder
    application_id?: SortOrder
    faculty_id?: SortOrder
    rubric_json?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    final_score?: SortOrderInput | SortOrder
    application?: internship_applicationsOrderByWithRelationInput
    faculty?: facultyOrderByWithRelationInput
  }

  export type internship_evaluationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: internship_evaluationWhereInput | internship_evaluationWhereInput[]
    OR?: internship_evaluationWhereInput[]
    NOT?: internship_evaluationWhereInput | internship_evaluationWhereInput[]
    application_id?: StringFilter<"internship_evaluation"> | string
    faculty_id?: StringFilter<"internship_evaluation"> | string
    rubric_json?: JsonNullableFilter<"internship_evaluation">
    comments?: StringNullableFilter<"internship_evaluation"> | string | null
    final_score?: FloatNullableFilter<"internship_evaluation"> | number | null
    application?: XOR<Internship_applicationsRelationFilter, internship_applicationsWhereInput>
    faculty?: XOR<FacultyRelationFilter, facultyWhereInput>
  }, "id">

  export type internship_evaluationOrderByWithAggregationInput = {
    id?: SortOrder
    application_id?: SortOrder
    faculty_id?: SortOrder
    rubric_json?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    final_score?: SortOrderInput | SortOrder
    _count?: internship_evaluationCountOrderByAggregateInput
    _avg?: internship_evaluationAvgOrderByAggregateInput
    _max?: internship_evaluationMaxOrderByAggregateInput
    _min?: internship_evaluationMinOrderByAggregateInput
    _sum?: internship_evaluationSumOrderByAggregateInput
  }

  export type internship_evaluationScalarWhereWithAggregatesInput = {
    AND?: internship_evaluationScalarWhereWithAggregatesInput | internship_evaluationScalarWhereWithAggregatesInput[]
    OR?: internship_evaluationScalarWhereWithAggregatesInput[]
    NOT?: internship_evaluationScalarWhereWithAggregatesInput | internship_evaluationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"internship_evaluation"> | string
    application_id?: StringWithAggregatesFilter<"internship_evaluation"> | string
    faculty_id?: StringWithAggregatesFilter<"internship_evaluation"> | string
    rubric_json?: JsonNullableWithAggregatesFilter<"internship_evaluation">
    comments?: StringNullableWithAggregatesFilter<"internship_evaluation"> | string | null
    final_score?: FloatNullableWithAggregatesFilter<"internship_evaluation"> | number | null
  }

  export type facultyWhereInput = {
    AND?: facultyWhereInput | facultyWhereInput[]
    OR?: facultyWhereInput[]
    NOT?: facultyWhereInput | facultyWhereInput[]
    id?: StringFilter<"faculty"> | string
    instituteId?: StringFilter<"faculty"> | string
    userId?: StringFilter<"faculty"> | string
    name?: StringFilter<"faculty"> | string
    department?: StringFilter<"faculty"> | string
    institution?: XOR<InstitutionsRelationFilter, institutionsWhereInput>
    user?: XOR<UsersRelationFilter, usersWhereInput>
    evaluations?: Internship_evaluationListRelationFilter
    students?: ProfileListRelationFilter
  }

  export type facultyOrderByWithRelationInput = {
    id?: SortOrder
    instituteId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    department?: SortOrder
    institution?: institutionsOrderByWithRelationInput
    user?: usersOrderByWithRelationInput
    evaluations?: internship_evaluationOrderByRelationAggregateInput
    students?: profileOrderByRelationAggregateInput
  }

  export type facultyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: facultyWhereInput | facultyWhereInput[]
    OR?: facultyWhereInput[]
    NOT?: facultyWhereInput | facultyWhereInput[]
    instituteId?: StringFilter<"faculty"> | string
    name?: StringFilter<"faculty"> | string
    department?: StringFilter<"faculty"> | string
    institution?: XOR<InstitutionsRelationFilter, institutionsWhereInput>
    user?: XOR<UsersRelationFilter, usersWhereInput>
    evaluations?: Internship_evaluationListRelationFilter
    students?: ProfileListRelationFilter
  }, "id" | "userId">

  export type facultyOrderByWithAggregationInput = {
    id?: SortOrder
    instituteId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    department?: SortOrder
    _count?: facultyCountOrderByAggregateInput
    _max?: facultyMaxOrderByAggregateInput
    _min?: facultyMinOrderByAggregateInput
  }

  export type facultyScalarWhereWithAggregatesInput = {
    AND?: facultyScalarWhereWithAggregatesInput | facultyScalarWhereWithAggregatesInput[]
    OR?: facultyScalarWhereWithAggregatesInput[]
    NOT?: facultyScalarWhereWithAggregatesInput | facultyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"faculty"> | string
    instituteId?: StringWithAggregatesFilter<"faculty"> | string
    userId?: StringWithAggregatesFilter<"faculty"> | string
    name?: StringWithAggregatesFilter<"faculty"> | string
    department?: StringWithAggregatesFilter<"faculty"> | string
  }

  export type creditsWhereInput = {
    AND?: creditsWhereInput | creditsWhereInput[]
    OR?: creditsWhereInput[]
    NOT?: creditsWhereInput | creditsWhereInput[]
    id?: StringFilter<"credits"> | string
    student_id?: StringFilter<"credits"> | string
    credits_earned?: FloatFilter<"credits"> | number
    student?: XOR<ProfileRelationFilter, profileWhereInput>
  }

  export type creditsOrderByWithRelationInput = {
    id?: SortOrder
    student_id?: SortOrder
    credits_earned?: SortOrder
    student?: profileOrderByWithRelationInput
  }

  export type creditsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: creditsWhereInput | creditsWhereInput[]
    OR?: creditsWhereInput[]
    NOT?: creditsWhereInput | creditsWhereInput[]
    student_id?: StringFilter<"credits"> | string
    credits_earned?: FloatFilter<"credits"> | number
    student?: XOR<ProfileRelationFilter, profileWhereInput>
  }, "id">

  export type creditsOrderByWithAggregationInput = {
    id?: SortOrder
    student_id?: SortOrder
    credits_earned?: SortOrder
    _count?: creditsCountOrderByAggregateInput
    _avg?: creditsAvgOrderByAggregateInput
    _max?: creditsMaxOrderByAggregateInput
    _min?: creditsMinOrderByAggregateInput
    _sum?: creditsSumOrderByAggregateInput
  }

  export type creditsScalarWhereWithAggregatesInput = {
    AND?: creditsScalarWhereWithAggregatesInput | creditsScalarWhereWithAggregatesInput[]
    OR?: creditsScalarWhereWithAggregatesInput[]
    NOT?: creditsScalarWhereWithAggregatesInput | creditsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"credits"> | string
    student_id?: StringWithAggregatesFilter<"credits"> | string
    credits_earned?: FloatWithAggregatesFilter<"credits"> | number
  }

  export type certificatesWhereInput = {
    AND?: certificatesWhereInput | certificatesWhereInput[]
    OR?: certificatesWhereInput[]
    NOT?: certificatesWhereInput | certificatesWhereInput[]
    id?: StringFilter<"certificates"> | string
    student_id?: StringFilter<"certificates"> | string
    title?: StringFilter<"certificates"> | string
    certificateUrl?: StringFilter<"certificates"> | string
    issuedAt?: DateTimeFilter<"certificates"> | Date | string
    student?: XOR<ProfileRelationFilter, profileWhereInput>
  }

  export type certificatesOrderByWithRelationInput = {
    id?: SortOrder
    student_id?: SortOrder
    title?: SortOrder
    certificateUrl?: SortOrder
    issuedAt?: SortOrder
    student?: profileOrderByWithRelationInput
  }

  export type certificatesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: certificatesWhereInput | certificatesWhereInput[]
    OR?: certificatesWhereInput[]
    NOT?: certificatesWhereInput | certificatesWhereInput[]
    student_id?: StringFilter<"certificates"> | string
    title?: StringFilter<"certificates"> | string
    certificateUrl?: StringFilter<"certificates"> | string
    issuedAt?: DateTimeFilter<"certificates"> | Date | string
    student?: XOR<ProfileRelationFilter, profileWhereInput>
  }, "id">

  export type certificatesOrderByWithAggregationInput = {
    id?: SortOrder
    student_id?: SortOrder
    title?: SortOrder
    certificateUrl?: SortOrder
    issuedAt?: SortOrder
    _count?: certificatesCountOrderByAggregateInput
    _max?: certificatesMaxOrderByAggregateInput
    _min?: certificatesMinOrderByAggregateInput
  }

  export type certificatesScalarWhereWithAggregatesInput = {
    AND?: certificatesScalarWhereWithAggregatesInput | certificatesScalarWhereWithAggregatesInput[]
    OR?: certificatesScalarWhereWithAggregatesInput[]
    NOT?: certificatesScalarWhereWithAggregatesInput | certificatesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"certificates"> | string
    student_id?: StringWithAggregatesFilter<"certificates"> | string
    title?: StringWithAggregatesFilter<"certificates"> | string
    certificateUrl?: StringWithAggregatesFilter<"certificates"> | string
    issuedAt?: DateTimeWithAggregatesFilter<"certificates"> | Date | string
  }

  export type notificationsWhereInput = {
    AND?: notificationsWhereInput | notificationsWhereInput[]
    OR?: notificationsWhereInput[]
    NOT?: notificationsWhereInput | notificationsWhereInput[]
    id?: StringFilter<"notifications"> | string
    title?: StringFilter<"notifications"> | string
    message?: StringFilter<"notifications"> | string
    created_at?: DateTimeFilter<"notifications"> | Date | string
    userNotifications?: User_notificationsListRelationFilter
  }

  export type notificationsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
    userNotifications?: user_notificationsOrderByRelationAggregateInput
  }

  export type notificationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: notificationsWhereInput | notificationsWhereInput[]
    OR?: notificationsWhereInput[]
    NOT?: notificationsWhereInput | notificationsWhereInput[]
    title?: StringFilter<"notifications"> | string
    message?: StringFilter<"notifications"> | string
    created_at?: DateTimeFilter<"notifications"> | Date | string
    userNotifications?: User_notificationsListRelationFilter
  }, "id">

  export type notificationsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
    _count?: notificationsCountOrderByAggregateInput
    _max?: notificationsMaxOrderByAggregateInput
    _min?: notificationsMinOrderByAggregateInput
  }

  export type notificationsScalarWhereWithAggregatesInput = {
    AND?: notificationsScalarWhereWithAggregatesInput | notificationsScalarWhereWithAggregatesInput[]
    OR?: notificationsScalarWhereWithAggregatesInput[]
    NOT?: notificationsScalarWhereWithAggregatesInput | notificationsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"notifications"> | string
    title?: StringWithAggregatesFilter<"notifications"> | string
    message?: StringWithAggregatesFilter<"notifications"> | string
    created_at?: DateTimeWithAggregatesFilter<"notifications"> | Date | string
  }

  export type user_notificationsWhereInput = {
    AND?: user_notificationsWhereInput | user_notificationsWhereInput[]
    OR?: user_notificationsWhereInput[]
    NOT?: user_notificationsWhereInput | user_notificationsWhereInput[]
    id?: StringFilter<"user_notifications"> | string
    user_id?: StringFilter<"user_notifications"> | string
    notification_id?: StringFilter<"user_notifications"> | string
    isRead?: BoolFilter<"user_notifications"> | boolean
    read_at?: DateTimeNullableFilter<"user_notifications"> | Date | string | null
    notification?: XOR<NotificationsRelationFilter, notificationsWhereInput>
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type user_notificationsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    notification_id?: SortOrder
    isRead?: SortOrder
    read_at?: SortOrderInput | SortOrder
    notification?: notificationsOrderByWithRelationInput
    user?: usersOrderByWithRelationInput
  }

  export type user_notificationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: user_notificationsWhereInput | user_notificationsWhereInput[]
    OR?: user_notificationsWhereInput[]
    NOT?: user_notificationsWhereInput | user_notificationsWhereInput[]
    user_id?: StringFilter<"user_notifications"> | string
    notification_id?: StringFilter<"user_notifications"> | string
    isRead?: BoolFilter<"user_notifications"> | boolean
    read_at?: DateTimeNullableFilter<"user_notifications"> | Date | string | null
    notification?: XOR<NotificationsRelationFilter, notificationsWhereInput>
    user?: XOR<UsersRelationFilter, usersWhereInput>
  }, "id">

  export type user_notificationsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    notification_id?: SortOrder
    isRead?: SortOrder
    read_at?: SortOrderInput | SortOrder
    _count?: user_notificationsCountOrderByAggregateInput
    _max?: user_notificationsMaxOrderByAggregateInput
    _min?: user_notificationsMinOrderByAggregateInput
  }

  export type user_notificationsScalarWhereWithAggregatesInput = {
    AND?: user_notificationsScalarWhereWithAggregatesInput | user_notificationsScalarWhereWithAggregatesInput[]
    OR?: user_notificationsScalarWhereWithAggregatesInput[]
    NOT?: user_notificationsScalarWhereWithAggregatesInput | user_notificationsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"user_notifications"> | string
    user_id?: StringWithAggregatesFilter<"user_notifications"> | string
    notification_id?: StringWithAggregatesFilter<"user_notifications"> | string
    isRead?: BoolWithAggregatesFilter<"user_notifications"> | boolean
    read_at?: DateTimeNullableWithAggregatesFilter<"user_notifications"> | Date | string | null
  }

  export type usersCreateInput = {
    id?: string
    displayName: string
    role?: usersCreateroleInput | string[]
    email: string
    salt: string
    phone: string
    hashPassword: string
    courseEnrollments?: courseEnrollmentsCreateNestedManyWithoutUserInput
    courses_instructor?: coursesCreateNestedManyWithoutInstructorInput
    facultyProfile?: facultyCreateNestedOneWithoutUserInput
    institutions_admin?: institutionsCreateNestedManyWithoutAdminUserInput
    internships_industryUser?: internshipsCreateNestedManyWithoutIndustryUserInput
    mentors?: mentorsCreateNestedOneWithoutUserInput
    profiles?: profileCreateNestedOneWithoutUserInput
    user_notifications?: user_notificationsCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateInput = {
    id?: string
    displayName: string
    role?: usersCreateroleInput | string[]
    email: string
    salt: string
    phone: string
    hashPassword: string
    courseEnrollments?: courseEnrollmentsUncheckedCreateNestedManyWithoutUserInput
    courses_instructor?: coursesUncheckedCreateNestedManyWithoutInstructorInput
    facultyProfile?: facultyUncheckedCreateNestedOneWithoutUserInput
    institutions_admin?: institutionsUncheckedCreateNestedManyWithoutAdminUserInput
    internships_industryUser?: internshipsUncheckedCreateNestedManyWithoutIndustryUserInput
    mentors?: mentorsUncheckedCreateNestedOneWithoutUserInput
    profiles?: profileUncheckedCreateNestedOneWithoutUserInput
    user_notifications?: user_notificationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    role?: usersUpdateroleInput | string[]
    email?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    hashPassword?: StringFieldUpdateOperationsInput | string
    courseEnrollments?: courseEnrollmentsUpdateManyWithoutUserNestedInput
    courses_instructor?: coursesUpdateManyWithoutInstructorNestedInput
    facultyProfile?: facultyUpdateOneWithoutUserNestedInput
    institutions_admin?: institutionsUpdateManyWithoutAdminUserNestedInput
    internships_industryUser?: internshipsUpdateManyWithoutIndustryUserNestedInput
    mentors?: mentorsUpdateOneWithoutUserNestedInput
    profiles?: profileUpdateOneWithoutUserNestedInput
    user_notifications?: user_notificationsUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    role?: usersUpdateroleInput | string[]
    email?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    hashPassword?: StringFieldUpdateOperationsInput | string
    courseEnrollments?: courseEnrollmentsUncheckedUpdateManyWithoutUserNestedInput
    courses_instructor?: coursesUncheckedUpdateManyWithoutInstructorNestedInput
    facultyProfile?: facultyUncheckedUpdateOneWithoutUserNestedInput
    institutions_admin?: institutionsUncheckedUpdateManyWithoutAdminUserNestedInput
    internships_industryUser?: internshipsUncheckedUpdateManyWithoutIndustryUserNestedInput
    mentors?: mentorsUncheckedUpdateOneWithoutUserNestedInput
    profiles?: profileUncheckedUpdateOneWithoutUserNestedInput
    user_notifications?: user_notificationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type usersCreateManyInput = {
    id?: string
    displayName: string
    role?: usersCreateroleInput | string[]
    email: string
    salt: string
    phone: string
    hashPassword: string
  }

  export type usersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    role?: usersUpdateroleInput | string[]
    email?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    hashPassword?: StringFieldUpdateOperationsInput | string
  }

  export type usersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    role?: usersUpdateroleInput | string[]
    email?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    hashPassword?: StringFieldUpdateOperationsInput | string
  }

  export type institutionsCreateInput = {
    id?: string
    instituteName: string
    state: string
    createdAt: Date | string
    faculty?: facultyCreateNestedManyWithoutInstitutionInput
    adminUser: usersCreateNestedOneWithoutInstitutions_adminInput
    profiles?: profileCreateNestedManyWithoutInstitutionInput
  }

  export type institutionsUncheckedCreateInput = {
    id?: string
    instituteName: string
    state: string
    adminUserId: string
    createdAt: Date | string
    faculty?: facultyUncheckedCreateNestedManyWithoutInstitutionInput
    profiles?: profileUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type institutionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    faculty?: facultyUpdateManyWithoutInstitutionNestedInput
    adminUser?: usersUpdateOneRequiredWithoutInstitutions_adminNestedInput
    profiles?: profileUpdateManyWithoutInstitutionNestedInput
  }

  export type institutionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    adminUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    faculty?: facultyUncheckedUpdateManyWithoutInstitutionNestedInput
    profiles?: profileUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type institutionsCreateManyInput = {
    id?: string
    instituteName: string
    state: string
    adminUserId: string
    createdAt: Date | string
  }

  export type institutionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type institutionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    adminUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type profileCreateInput = {
    id?: string
    bio?: string | null
    gender?: string | null
    DOB?: Date | string | null
    avatarURL?: string | null
    github?: string | null
    linkedin?: string | null
    skills?: profileCreateskillsInput | string[]
    interests?: profileCreateinterestsInput | string[]
    department?: string | null
    resourceId?: string | null
    certificates?: certificatesCreateNestedManyWithoutStudentInput
    credits?: creditsCreateNestedManyWithoutStudentInput
    internshipApplications?: internship_applicationsCreateNestedManyWithoutStudentInput
    mentorReviews?: mentorReviewsCreateNestedManyWithoutStudentInput
    mentorSessions?: mentorSessionsCreateNestedManyWithoutStudentInput
    portfolioProjects?: portfolioProjectsCreateNestedManyWithoutUserInput
    faculty?: facultyCreateNestedOneWithoutStudentsInput
    institution: institutionsCreateNestedOneWithoutProfilesInput
    user: usersCreateNestedOneWithoutProfilesInput
    learningProgress?: studentLearningProgressCreateNestedManyWithoutProfileInput
  }

  export type profileUncheckedCreateInput = {
    id?: string
    userId: string
    bio?: string | null
    gender?: string | null
    DOB?: Date | string | null
    avatarURL?: string | null
    github?: string | null
    linkedin?: string | null
    skills?: profileCreateskillsInput | string[]
    interests?: profileCreateinterestsInput | string[]
    department?: string | null
    resourceId?: string | null
    instituteId: string
    facultyId?: string | null
    certificates?: certificatesUncheckedCreateNestedManyWithoutStudentInput
    credits?: creditsUncheckedCreateNestedManyWithoutStudentInput
    internshipApplications?: internship_applicationsUncheckedCreateNestedManyWithoutStudentInput
    mentorReviews?: mentorReviewsUncheckedCreateNestedManyWithoutStudentInput
    mentorSessions?: mentorSessionsUncheckedCreateNestedManyWithoutStudentInput
    portfolioProjects?: portfolioProjectsUncheckedCreateNestedManyWithoutUserInput
    learningProgress?: studentLearningProgressUncheckedCreateNestedManyWithoutProfileInput
  }

  export type profileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarURL?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: profileUpdateskillsInput | string[]
    interests?: profileUpdateinterestsInput | string[]
    department?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    certificates?: certificatesUpdateManyWithoutStudentNestedInput
    credits?: creditsUpdateManyWithoutStudentNestedInput
    internshipApplications?: internship_applicationsUpdateManyWithoutStudentNestedInput
    mentorReviews?: mentorReviewsUpdateManyWithoutStudentNestedInput
    mentorSessions?: mentorSessionsUpdateManyWithoutStudentNestedInput
    portfolioProjects?: portfolioProjectsUpdateManyWithoutUserNestedInput
    faculty?: facultyUpdateOneWithoutStudentsNestedInput
    institution?: institutionsUpdateOneRequiredWithoutProfilesNestedInput
    user?: usersUpdateOneRequiredWithoutProfilesNestedInput
    learningProgress?: studentLearningProgressUpdateManyWithoutProfileNestedInput
  }

  export type profileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarURL?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: profileUpdateskillsInput | string[]
    interests?: profileUpdateinterestsInput | string[]
    department?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    instituteId?: StringFieldUpdateOperationsInput | string
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
    certificates?: certificatesUncheckedUpdateManyWithoutStudentNestedInput
    credits?: creditsUncheckedUpdateManyWithoutStudentNestedInput
    internshipApplications?: internship_applicationsUncheckedUpdateManyWithoutStudentNestedInput
    mentorReviews?: mentorReviewsUncheckedUpdateManyWithoutStudentNestedInput
    mentorSessions?: mentorSessionsUncheckedUpdateManyWithoutStudentNestedInput
    portfolioProjects?: portfolioProjectsUncheckedUpdateManyWithoutUserNestedInput
    learningProgress?: studentLearningProgressUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type profileCreateManyInput = {
    id?: string
    userId: string
    bio?: string | null
    gender?: string | null
    DOB?: Date | string | null
    avatarURL?: string | null
    github?: string | null
    linkedin?: string | null
    skills?: profileCreateskillsInput | string[]
    interests?: profileCreateinterestsInput | string[]
    department?: string | null
    resourceId?: string | null
    instituteId: string
    facultyId?: string | null
  }

  export type profileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarURL?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: profileUpdateskillsInput | string[]
    interests?: profileUpdateinterestsInput | string[]
    department?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type profileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarURL?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: profileUpdateskillsInput | string[]
    interests?: profileUpdateinterestsInput | string[]
    department?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    instituteId?: StringFieldUpdateOperationsInput | string
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type roadmapsCreateInput = {
    id?: string
    title: string
    description: string
    domain: string
    checkpoints?: checkpointsCreateNestedManyWithoutRoadmapInput
  }

  export type roadmapsUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    domain: string
    checkpoints?: checkpointsUncheckedCreateNestedManyWithoutRoadmapInput
  }

  export type roadmapsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    checkpoints?: checkpointsUpdateManyWithoutRoadmapNestedInput
  }

  export type roadmapsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    checkpoints?: checkpointsUncheckedUpdateManyWithoutRoadmapNestedInput
  }

  export type roadmapsCreateManyInput = {
    id?: string
    title: string
    description: string
    domain: string
  }

  export type roadmapsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
  }

  export type roadmapsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
  }

  export type checkpointsCreateInput = {
    id?: string
    title: string
    description: string
    resourceType: string
    resourceUrl: string
    roadmap: roadmapsCreateNestedOneWithoutCheckpointsInput
    progress?: studentLearningProgressCreateNestedManyWithoutCheckpointInput
  }

  export type checkpointsUncheckedCreateInput = {
    id?: string
    roadmapId: string
    title: string
    description: string
    resourceType: string
    resourceUrl: string
    progress?: studentLearningProgressUncheckedCreateNestedManyWithoutCheckpointInput
  }

  export type checkpointsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceUrl?: StringFieldUpdateOperationsInput | string
    roadmap?: roadmapsUpdateOneRequiredWithoutCheckpointsNestedInput
    progress?: studentLearningProgressUpdateManyWithoutCheckpointNestedInput
  }

  export type checkpointsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roadmapId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceUrl?: StringFieldUpdateOperationsInput | string
    progress?: studentLearningProgressUncheckedUpdateManyWithoutCheckpointNestedInput
  }

  export type checkpointsCreateManyInput = {
    id?: string
    roadmapId: string
    title: string
    description: string
    resourceType: string
    resourceUrl: string
  }

  export type checkpointsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceUrl?: StringFieldUpdateOperationsInput | string
  }

  export type checkpointsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roadmapId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceUrl?: StringFieldUpdateOperationsInput | string
  }

  export type studentLearningProgressCreateInput = {
    id?: string
    isCompleted: boolean
    completedAt?: Date | string | null
    checkpoint: checkpointsCreateNestedOneWithoutProgressInput
    profile: profileCreateNestedOneWithoutLearningProgressInput
  }

  export type studentLearningProgressUncheckedCreateInput = {
    id?: string
    profileId: string
    checkpointId: string
    isCompleted: boolean
    completedAt?: Date | string | null
  }

  export type studentLearningProgressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkpoint?: checkpointsUpdateOneRequiredWithoutProgressNestedInput
    profile?: profileUpdateOneRequiredWithoutLearningProgressNestedInput
  }

  export type studentLearningProgressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    checkpointId?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type studentLearningProgressCreateManyInput = {
    id?: string
    profileId: string
    checkpointId: string
    isCompleted: boolean
    completedAt?: Date | string | null
  }

  export type studentLearningProgressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type studentLearningProgressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    checkpointId?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type coursesCreateInput = {
    id?: string
    title: string
    description: string
    type: $Enums.CourseType
    price?: number | null
    thumbnail_url?: string | null
    created_at: Date | string
    enrollments?: courseEnrollmentsCreateNestedManyWithoutCourseInput
    instructor: usersCreateNestedOneWithoutCourses_instructorInput
  }

  export type coursesUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    type: $Enums.CourseType
    price?: number | null
    instructorId: string
    thumbnail_url?: string | null
    created_at: Date | string
    enrollments?: courseEnrollmentsUncheckedCreateNestedManyWithoutCourseInput
  }

  export type coursesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: courseEnrollmentsUpdateManyWithoutCourseNestedInput
    instructor?: usersUpdateOneRequiredWithoutCourses_instructorNestedInput
  }

  export type coursesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    instructorId?: StringFieldUpdateOperationsInput | string
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: courseEnrollmentsUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type coursesCreateManyInput = {
    id?: string
    title: string
    description: string
    type: $Enums.CourseType
    price?: number | null
    instructorId: string
    thumbnail_url?: string | null
    created_at: Date | string
  }

  export type coursesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type coursesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    instructorId?: StringFieldUpdateOperationsInput | string
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type courseEnrollmentsCreateInput = {
    id?: string
    progressPercent?: number | null
    enrolledAt: Date | string
    course: coursesCreateNestedOneWithoutEnrollmentsInput
    user: usersCreateNestedOneWithoutCourseEnrollmentsInput
  }

  export type courseEnrollmentsUncheckedCreateInput = {
    id?: string
    courseId: string
    userId: string
    progressPercent?: number | null
    enrolledAt: Date | string
  }

  export type courseEnrollmentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    progressPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: coursesUpdateOneRequiredWithoutEnrollmentsNestedInput
    user?: usersUpdateOneRequiredWithoutCourseEnrollmentsNestedInput
  }

  export type courseEnrollmentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    progressPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type courseEnrollmentsCreateManyInput = {
    id?: string
    courseId: string
    userId: string
    progressPercent?: number | null
    enrolledAt: Date | string
  }

  export type courseEnrollmentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    progressPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type courseEnrollmentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    progressPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type mentorsCreateInput = {
    id?: string
    expertise?: NullableJsonNullValueInput | InputJsonValue
    rating?: number | null
    bio?: string | null
    reviews?: mentorReviewsCreateNestedManyWithoutMentorInput
    sessions?: mentorSessionsCreateNestedManyWithoutMentorInput
    user: usersCreateNestedOneWithoutMentorsInput
  }

  export type mentorsUncheckedCreateInput = {
    id?: string
    user_id: string
    expertise?: NullableJsonNullValueInput | InputJsonValue
    rating?: number | null
    bio?: string | null
    reviews?: mentorReviewsUncheckedCreateNestedManyWithoutMentorInput
    sessions?: mentorSessionsUncheckedCreateNestedManyWithoutMentorInput
  }

  export type mentorsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expertise?: NullableJsonNullValueInput | InputJsonValue
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    reviews?: mentorReviewsUpdateManyWithoutMentorNestedInput
    sessions?: mentorSessionsUpdateManyWithoutMentorNestedInput
    user?: usersUpdateOneRequiredWithoutMentorsNestedInput
  }

  export type mentorsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    expertise?: NullableJsonNullValueInput | InputJsonValue
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    reviews?: mentorReviewsUncheckedUpdateManyWithoutMentorNestedInput
    sessions?: mentorSessionsUncheckedUpdateManyWithoutMentorNestedInput
  }

  export type mentorsCreateManyInput = {
    id?: string
    user_id: string
    expertise?: NullableJsonNullValueInput | InputJsonValue
    rating?: number | null
    bio?: string | null
  }

  export type mentorsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    expertise?: NullableJsonNullValueInput | InputJsonValue
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type mentorsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    expertise?: NullableJsonNullValueInput | InputJsonValue
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type mentorSessionsCreateInput = {
    id?: string
    scheduled_at: Date | string
    status: $Enums.MentorSessionStatus
    meeting_link?: string | null
    mentor: mentorsCreateNestedOneWithoutSessionsInput
    student: profileCreateNestedOneWithoutMentorSessionsInput
  }

  export type mentorSessionsUncheckedCreateInput = {
    id?: string
    studentId: string
    mentorId: string
    scheduled_at: Date | string
    status: $Enums.MentorSessionStatus
    meeting_link?: string | null
  }

  export type mentorSessionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduled_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMentorSessionStatusFieldUpdateOperationsInput | $Enums.MentorSessionStatus
    meeting_link?: NullableStringFieldUpdateOperationsInput | string | null
    mentor?: mentorsUpdateOneRequiredWithoutSessionsNestedInput
    student?: profileUpdateOneRequiredWithoutMentorSessionsNestedInput
  }

  export type mentorSessionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    mentorId?: StringFieldUpdateOperationsInput | string
    scheduled_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMentorSessionStatusFieldUpdateOperationsInput | $Enums.MentorSessionStatus
    meeting_link?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type mentorSessionsCreateManyInput = {
    id?: string
    studentId: string
    mentorId: string
    scheduled_at: Date | string
    status: $Enums.MentorSessionStatus
    meeting_link?: string | null
  }

  export type mentorSessionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduled_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMentorSessionStatusFieldUpdateOperationsInput | $Enums.MentorSessionStatus
    meeting_link?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type mentorSessionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    mentorId?: StringFieldUpdateOperationsInput | string
    scheduled_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMentorSessionStatusFieldUpdateOperationsInput | $Enums.MentorSessionStatus
    meeting_link?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type mentorReviewsCreateInput = {
    id?: string
    rating: number
    reviews?: string | null
    mentor: mentorsCreateNestedOneWithoutReviewsInput
    student: profileCreateNestedOneWithoutMentorReviewsInput
  }

  export type mentorReviewsUncheckedCreateInput = {
    id?: string
    mentorId: string
    rating: number
    reviews?: string | null
    studentId: string
  }

  export type mentorReviewsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    reviews?: NullableStringFieldUpdateOperationsInput | string | null
    mentor?: mentorsUpdateOneRequiredWithoutReviewsNestedInput
    student?: profileUpdateOneRequiredWithoutMentorReviewsNestedInput
  }

  export type mentorReviewsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mentorId?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    reviews?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: StringFieldUpdateOperationsInput | string
  }

  export type mentorReviewsCreateManyInput = {
    id?: string
    mentorId: string
    rating: number
    reviews?: string | null
    studentId: string
  }

  export type mentorReviewsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    reviews?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type mentorReviewsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    mentorId?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    reviews?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: StringFieldUpdateOperationsInput | string
  }

  export type portfolioProjectsCreateInput = {
    id?: string
    title: string
    description?: string | null
    github_url?: string | null
    live_url?: string | null
    tags?: portfolioProjectsCreatetagsInput | string[]
    user: profileCreateNestedOneWithoutPortfolioProjectsInput
  }

  export type portfolioProjectsUncheckedCreateInput = {
    id?: string
    user_id: string
    title: string
    description?: string | null
    github_url?: string | null
    live_url?: string | null
    tags?: portfolioProjectsCreatetagsInput | string[]
  }

  export type portfolioProjectsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    github_url?: NullableStringFieldUpdateOperationsInput | string | null
    live_url?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: portfolioProjectsUpdatetagsInput | string[]
    user?: profileUpdateOneRequiredWithoutPortfolioProjectsNestedInput
  }

  export type portfolioProjectsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    github_url?: NullableStringFieldUpdateOperationsInput | string | null
    live_url?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: portfolioProjectsUpdatetagsInput | string[]
  }

  export type portfolioProjectsCreateManyInput = {
    id?: string
    user_id: string
    title: string
    description?: string | null
    github_url?: string | null
    live_url?: string | null
    tags?: portfolioProjectsCreatetagsInput | string[]
  }

  export type portfolioProjectsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    github_url?: NullableStringFieldUpdateOperationsInput | string | null
    live_url?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: portfolioProjectsUpdatetagsInput | string[]
  }

  export type portfolioProjectsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    github_url?: NullableStringFieldUpdateOperationsInput | string | null
    live_url?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: portfolioProjectsUpdatetagsInput | string[]
  }

  export type internshipsCreateInput = {
    id?: string
    title: string
    description: string
    type: string
    stipend?: number | null
    location: string
    required_skills: JsonNullValueInput | InputJsonValue
    duration_weeks: number
    created_at: Date | string
    applications?: internship_applicationsCreateNestedManyWithoutInternshipInput
    industryUser: usersCreateNestedOneWithoutInternships_industryUserInput
  }

  export type internshipsUncheckedCreateInput = {
    id?: string
    industry_user_id: string
    title: string
    description: string
    type: string
    stipend?: number | null
    location: string
    required_skills: JsonNullValueInput | InputJsonValue
    duration_weeks: number
    created_at: Date | string
    applications?: internship_applicationsUncheckedCreateNestedManyWithoutInternshipInput
  }

  export type internshipsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    stipend?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: StringFieldUpdateOperationsInput | string
    required_skills?: JsonNullValueInput | InputJsonValue
    duration_weeks?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: internship_applicationsUpdateManyWithoutInternshipNestedInput
    industryUser?: usersUpdateOneRequiredWithoutInternships_industryUserNestedInput
  }

  export type internshipsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    industry_user_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    stipend?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: StringFieldUpdateOperationsInput | string
    required_skills?: JsonNullValueInput | InputJsonValue
    duration_weeks?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: internship_applicationsUncheckedUpdateManyWithoutInternshipNestedInput
  }

  export type internshipsCreateManyInput = {
    id?: string
    industry_user_id: string
    title: string
    description: string
    type: string
    stipend?: number | null
    location: string
    required_skills: JsonNullValueInput | InputJsonValue
    duration_weeks: number
    created_at: Date | string
  }

  export type internshipsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    stipend?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: StringFieldUpdateOperationsInput | string
    required_skills?: JsonNullValueInput | InputJsonValue
    duration_weeks?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type internshipsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    industry_user_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    stipend?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: StringFieldUpdateOperationsInput | string
    required_skills?: JsonNullValueInput | InputJsonValue
    duration_weeks?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type internship_applicationsCreateInput = {
    id?: string
    status: $Enums.InternshipStatus
    submission_url?: string | null
    score?: number | null
    applied_at: Date | string
    internship: internshipsCreateNestedOneWithoutApplicationsInput
    student: profileCreateNestedOneWithoutInternshipApplicationsInput
    evaluations?: internship_evaluationCreateNestedManyWithoutApplicationInput
    logbookEntries?: logbook_entriesCreateNestedManyWithoutApplicationInput
  }

  export type internship_applicationsUncheckedCreateInput = {
    id?: string
    internship_id: string
    student_id: string
    status: $Enums.InternshipStatus
    submission_url?: string | null
    score?: number | null
    applied_at: Date | string
    evaluations?: internship_evaluationUncheckedCreateNestedManyWithoutApplicationInput
    logbookEntries?: logbook_entriesUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type internship_applicationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInternshipStatusFieldUpdateOperationsInput | $Enums.InternshipStatus
    submission_url?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    applied_at?: DateTimeFieldUpdateOperationsInput | Date | string
    internship?: internshipsUpdateOneRequiredWithoutApplicationsNestedInput
    student?: profileUpdateOneRequiredWithoutInternshipApplicationsNestedInput
    evaluations?: internship_evaluationUpdateManyWithoutApplicationNestedInput
    logbookEntries?: logbook_entriesUpdateManyWithoutApplicationNestedInput
  }

  export type internship_applicationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    internship_id?: StringFieldUpdateOperationsInput | string
    student_id?: StringFieldUpdateOperationsInput | string
    status?: EnumInternshipStatusFieldUpdateOperationsInput | $Enums.InternshipStatus
    submission_url?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    applied_at?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: internship_evaluationUncheckedUpdateManyWithoutApplicationNestedInput
    logbookEntries?: logbook_entriesUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type internship_applicationsCreateManyInput = {
    id?: string
    internship_id: string
    student_id: string
    status: $Enums.InternshipStatus
    submission_url?: string | null
    score?: number | null
    applied_at: Date | string
  }

  export type internship_applicationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInternshipStatusFieldUpdateOperationsInput | $Enums.InternshipStatus
    submission_url?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    applied_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type internship_applicationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    internship_id?: StringFieldUpdateOperationsInput | string
    student_id?: StringFieldUpdateOperationsInput | string
    status?: EnumInternshipStatusFieldUpdateOperationsInput | $Enums.InternshipStatus
    submission_url?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    applied_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type logbook_entriesCreateInput = {
    id?: string
    date: Date | string
    taskDone: string
    proofUrl?: string | null
    hours_spent: number
    application: internship_applicationsCreateNestedOneWithoutLogbookEntriesInput
  }

  export type logbook_entriesUncheckedCreateInput = {
    id?: string
    applicationId: string
    date: Date | string
    taskDone: string
    proofUrl?: string | null
    hours_spent: number
  }

  export type logbook_entriesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    taskDone?: StringFieldUpdateOperationsInput | string
    proofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    hours_spent?: IntFieldUpdateOperationsInput | number
    application?: internship_applicationsUpdateOneRequiredWithoutLogbookEntriesNestedInput
  }

  export type logbook_entriesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    taskDone?: StringFieldUpdateOperationsInput | string
    proofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    hours_spent?: IntFieldUpdateOperationsInput | number
  }

  export type logbook_entriesCreateManyInput = {
    id?: string
    applicationId: string
    date: Date | string
    taskDone: string
    proofUrl?: string | null
    hours_spent: number
  }

  export type logbook_entriesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    taskDone?: StringFieldUpdateOperationsInput | string
    proofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    hours_spent?: IntFieldUpdateOperationsInput | number
  }

  export type logbook_entriesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    taskDone?: StringFieldUpdateOperationsInput | string
    proofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    hours_spent?: IntFieldUpdateOperationsInput | number
  }

  export type internship_evaluationCreateInput = {
    id?: string
    rubric_json?: NullableJsonNullValueInput | InputJsonValue
    comments?: string | null
    final_score?: number | null
    application: internship_applicationsCreateNestedOneWithoutEvaluationsInput
    faculty: facultyCreateNestedOneWithoutEvaluationsInput
  }

  export type internship_evaluationUncheckedCreateInput = {
    id?: string
    application_id: string
    faculty_id: string
    rubric_json?: NullableJsonNullValueInput | InputJsonValue
    comments?: string | null
    final_score?: number | null
  }

  export type internship_evaluationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rubric_json?: NullableJsonNullValueInput | InputJsonValue
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    final_score?: NullableFloatFieldUpdateOperationsInput | number | null
    application?: internship_applicationsUpdateOneRequiredWithoutEvaluationsNestedInput
    faculty?: facultyUpdateOneRequiredWithoutEvaluationsNestedInput
  }

  export type internship_evaluationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    application_id?: StringFieldUpdateOperationsInput | string
    faculty_id?: StringFieldUpdateOperationsInput | string
    rubric_json?: NullableJsonNullValueInput | InputJsonValue
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    final_score?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type internship_evaluationCreateManyInput = {
    id?: string
    application_id: string
    faculty_id: string
    rubric_json?: NullableJsonNullValueInput | InputJsonValue
    comments?: string | null
    final_score?: number | null
  }

  export type internship_evaluationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rubric_json?: NullableJsonNullValueInput | InputJsonValue
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    final_score?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type internship_evaluationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    application_id?: StringFieldUpdateOperationsInput | string
    faculty_id?: StringFieldUpdateOperationsInput | string
    rubric_json?: NullableJsonNullValueInput | InputJsonValue
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    final_score?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type facultyCreateInput = {
    id?: string
    name: string
    department: string
    institution: institutionsCreateNestedOneWithoutFacultyInput
    user: usersCreateNestedOneWithoutFacultyProfileInput
    evaluations?: internship_evaluationCreateNestedManyWithoutFacultyInput
    students?: profileCreateNestedManyWithoutFacultyInput
  }

  export type facultyUncheckedCreateInput = {
    id?: string
    instituteId: string
    userId: string
    name: string
    department: string
    evaluations?: internship_evaluationUncheckedCreateNestedManyWithoutFacultyInput
    students?: profileUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type facultyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    institution?: institutionsUpdateOneRequiredWithoutFacultyNestedInput
    user?: usersUpdateOneRequiredWithoutFacultyProfileNestedInput
    evaluations?: internship_evaluationUpdateManyWithoutFacultyNestedInput
    students?: profileUpdateManyWithoutFacultyNestedInput
  }

  export type facultyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    evaluations?: internship_evaluationUncheckedUpdateManyWithoutFacultyNestedInput
    students?: profileUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type facultyCreateManyInput = {
    id?: string
    instituteId: string
    userId: string
    name: string
    department: string
  }

  export type facultyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
  }

  export type facultyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
  }

  export type creditsCreateInput = {
    id?: string
    credits_earned: number
    student: profileCreateNestedOneWithoutCreditsInput
  }

  export type creditsUncheckedCreateInput = {
    id?: string
    student_id: string
    credits_earned: number
  }

  export type creditsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    credits_earned?: FloatFieldUpdateOperationsInput | number
    student?: profileUpdateOneRequiredWithoutCreditsNestedInput
  }

  export type creditsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    student_id?: StringFieldUpdateOperationsInput | string
    credits_earned?: FloatFieldUpdateOperationsInput | number
  }

  export type creditsCreateManyInput = {
    id?: string
    student_id: string
    credits_earned: number
  }

  export type creditsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    credits_earned?: FloatFieldUpdateOperationsInput | number
  }

  export type creditsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    student_id?: StringFieldUpdateOperationsInput | string
    credits_earned?: FloatFieldUpdateOperationsInput | number
  }

  export type certificatesCreateInput = {
    id?: string
    title: string
    certificateUrl: string
    issuedAt: Date | string
    student: profileCreateNestedOneWithoutCertificatesInput
  }

  export type certificatesUncheckedCreateInput = {
    id?: string
    student_id: string
    title: string
    certificateUrl: string
    issuedAt: Date | string
  }

  export type certificatesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    certificateUrl?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: profileUpdateOneRequiredWithoutCertificatesNestedInput
  }

  export type certificatesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    student_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    certificateUrl?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type certificatesCreateManyInput = {
    id?: string
    student_id: string
    title: string
    certificateUrl: string
    issuedAt: Date | string
  }

  export type certificatesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    certificateUrl?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type certificatesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    student_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    certificateUrl?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsCreateInput = {
    id?: string
    title: string
    message: string
    created_at: Date | string
    userNotifications?: user_notificationsCreateNestedManyWithoutNotificationInput
  }

  export type notificationsUncheckedCreateInput = {
    id?: string
    title: string
    message: string
    created_at: Date | string
    userNotifications?: user_notificationsUncheckedCreateNestedManyWithoutNotificationInput
  }

  export type notificationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userNotifications?: user_notificationsUpdateManyWithoutNotificationNestedInput
  }

  export type notificationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    userNotifications?: user_notificationsUncheckedUpdateManyWithoutNotificationNestedInput
  }

  export type notificationsCreateManyInput = {
    id?: string
    title: string
    message: string
    created_at: Date | string
  }

  export type notificationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_notificationsCreateInput = {
    id?: string
    isRead: boolean
    read_at?: Date | string | null
    notification: notificationsCreateNestedOneWithoutUserNotificationsInput
    user: usersCreateNestedOneWithoutUser_notificationsInput
  }

  export type user_notificationsUncheckedCreateInput = {
    id?: string
    user_id: string
    notification_id: string
    isRead: boolean
    read_at?: Date | string | null
  }

  export type user_notificationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notification?: notificationsUpdateOneRequiredWithoutUserNotificationsNestedInput
    user?: usersUpdateOneRequiredWithoutUser_notificationsNestedInput
  }

  export type user_notificationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    notification_id?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_notificationsCreateManyInput = {
    id?: string
    user_id: string
    notification_id: string
    isRead: boolean
    read_at?: Date | string | null
  }

  export type user_notificationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_notificationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    notification_id?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type CourseEnrollmentsListRelationFilter = {
    every?: courseEnrollmentsWhereInput
    some?: courseEnrollmentsWhereInput
    none?: courseEnrollmentsWhereInput
  }

  export type CoursesListRelationFilter = {
    every?: coursesWhereInput
    some?: coursesWhereInput
    none?: coursesWhereInput
  }

  export type FacultyNullableRelationFilter = {
    is?: facultyWhereInput | null
    isNot?: facultyWhereInput | null
  }

  export type InstitutionsListRelationFilter = {
    every?: institutionsWhereInput
    some?: institutionsWhereInput
    none?: institutionsWhereInput
  }

  export type InternshipsListRelationFilter = {
    every?: internshipsWhereInput
    some?: internshipsWhereInput
    none?: internshipsWhereInput
  }

  export type MentorsNullableRelationFilter = {
    is?: mentorsWhereInput | null
    isNot?: mentorsWhereInput | null
  }

  export type ProfileNullableRelationFilter = {
    is?: profileWhereInput | null
    isNot?: profileWhereInput | null
  }

  export type User_notificationsListRelationFilter = {
    every?: user_notificationsWhereInput
    some?: user_notificationsWhereInput
    none?: user_notificationsWhereInput
  }

  export type courseEnrollmentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type coursesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type institutionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type internshipsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type user_notificationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    displayName?: SortOrder
    role?: SortOrder
    email?: SortOrder
    salt?: SortOrder
    phone?: SortOrder
    hashPassword?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    displayName?: SortOrder
    email?: SortOrder
    salt?: SortOrder
    phone?: SortOrder
    hashPassword?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    displayName?: SortOrder
    email?: SortOrder
    salt?: SortOrder
    phone?: SortOrder
    hashPassword?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type FacultyListRelationFilter = {
    every?: facultyWhereInput
    some?: facultyWhereInput
    none?: facultyWhereInput
  }

  export type UsersRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type ProfileListRelationFilter = {
    every?: profileWhereInput
    some?: profileWhereInput
    none?: profileWhereInput
  }

  export type facultyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type profileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type institutionsCountOrderByAggregateInput = {
    id?: SortOrder
    instituteName?: SortOrder
    state?: SortOrder
    adminUserId?: SortOrder
    createdAt?: SortOrder
  }

  export type institutionsMaxOrderByAggregateInput = {
    id?: SortOrder
    instituteName?: SortOrder
    state?: SortOrder
    adminUserId?: SortOrder
    createdAt?: SortOrder
  }

  export type institutionsMinOrderByAggregateInput = {
    id?: SortOrder
    instituteName?: SortOrder
    state?: SortOrder
    adminUserId?: SortOrder
    createdAt?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type CertificatesListRelationFilter = {
    every?: certificatesWhereInput
    some?: certificatesWhereInput
    none?: certificatesWhereInput
  }

  export type CreditsListRelationFilter = {
    every?: creditsWhereInput
    some?: creditsWhereInput
    none?: creditsWhereInput
  }

  export type Internship_applicationsListRelationFilter = {
    every?: internship_applicationsWhereInput
    some?: internship_applicationsWhereInput
    none?: internship_applicationsWhereInput
  }

  export type MentorReviewsListRelationFilter = {
    every?: mentorReviewsWhereInput
    some?: mentorReviewsWhereInput
    none?: mentorReviewsWhereInput
  }

  export type MentorSessionsListRelationFilter = {
    every?: mentorSessionsWhereInput
    some?: mentorSessionsWhereInput
    none?: mentorSessionsWhereInput
  }

  export type PortfolioProjectsListRelationFilter = {
    every?: portfolioProjectsWhereInput
    some?: portfolioProjectsWhereInput
    none?: portfolioProjectsWhereInput
  }

  export type InstitutionsRelationFilter = {
    is?: institutionsWhereInput
    isNot?: institutionsWhereInput
  }

  export type StudentLearningProgressListRelationFilter = {
    every?: studentLearningProgressWhereInput
    some?: studentLearningProgressWhereInput
    none?: studentLearningProgressWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type certificatesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type creditsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type internship_applicationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type mentorReviewsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type mentorSessionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type portfolioProjectsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type studentLearningProgressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type profileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bio?: SortOrder
    gender?: SortOrder
    DOB?: SortOrder
    avatarURL?: SortOrder
    github?: SortOrder
    linkedin?: SortOrder
    skills?: SortOrder
    interests?: SortOrder
    department?: SortOrder
    resourceId?: SortOrder
    instituteId?: SortOrder
    facultyId?: SortOrder
  }

  export type profileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bio?: SortOrder
    gender?: SortOrder
    DOB?: SortOrder
    avatarURL?: SortOrder
    github?: SortOrder
    linkedin?: SortOrder
    department?: SortOrder
    resourceId?: SortOrder
    instituteId?: SortOrder
    facultyId?: SortOrder
  }

  export type profileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bio?: SortOrder
    gender?: SortOrder
    DOB?: SortOrder
    avatarURL?: SortOrder
    github?: SortOrder
    linkedin?: SortOrder
    department?: SortOrder
    resourceId?: SortOrder
    instituteId?: SortOrder
    facultyId?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type CheckpointsListRelationFilter = {
    every?: checkpointsWhereInput
    some?: checkpointsWhereInput
    none?: checkpointsWhereInput
  }

  export type checkpointsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type roadmapsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    domain?: SortOrder
  }

  export type roadmapsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    domain?: SortOrder
  }

  export type roadmapsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    domain?: SortOrder
  }

  export type RoadmapsRelationFilter = {
    is?: roadmapsWhereInput
    isNot?: roadmapsWhereInput
  }

  export type checkpointsCountOrderByAggregateInput = {
    id?: SortOrder
    roadmapId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    resourceType?: SortOrder
    resourceUrl?: SortOrder
  }

  export type checkpointsMaxOrderByAggregateInput = {
    id?: SortOrder
    roadmapId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    resourceType?: SortOrder
    resourceUrl?: SortOrder
  }

  export type checkpointsMinOrderByAggregateInput = {
    id?: SortOrder
    roadmapId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    resourceType?: SortOrder
    resourceUrl?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type CheckpointsRelationFilter = {
    is?: checkpointsWhereInput
    isNot?: checkpointsWhereInput
  }

  export type ProfileRelationFilter = {
    is?: profileWhereInput
    isNot?: profileWhereInput
  }

  export type studentLearningProgressCountOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    checkpointId?: SortOrder
    isCompleted?: SortOrder
    completedAt?: SortOrder
  }

  export type studentLearningProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    checkpointId?: SortOrder
    isCompleted?: SortOrder
    completedAt?: SortOrder
  }

  export type studentLearningProgressMinOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    checkpointId?: SortOrder
    isCompleted?: SortOrder
    completedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumCourseTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseType | EnumCourseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CourseType[] | ListEnumCourseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseType[] | ListEnumCourseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseTypeFilter<$PrismaModel> | $Enums.CourseType
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type coursesCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    price?: SortOrder
    instructorId?: SortOrder
    thumbnail_url?: SortOrder
    created_at?: SortOrder
  }

  export type coursesAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type coursesMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    price?: SortOrder
    instructorId?: SortOrder
    thumbnail_url?: SortOrder
    created_at?: SortOrder
  }

  export type coursesMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    price?: SortOrder
    instructorId?: SortOrder
    thumbnail_url?: SortOrder
    created_at?: SortOrder
  }

  export type coursesSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type EnumCourseTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseType | EnumCourseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CourseType[] | ListEnumCourseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseType[] | ListEnumCourseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseTypeWithAggregatesFilter<$PrismaModel> | $Enums.CourseType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCourseTypeFilter<$PrismaModel>
    _max?: NestedEnumCourseTypeFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type CoursesRelationFilter = {
    is?: coursesWhereInput
    isNot?: coursesWhereInput
  }

  export type courseEnrollmentsCountOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    userId?: SortOrder
    progressPercent?: SortOrder
    enrolledAt?: SortOrder
  }

  export type courseEnrollmentsAvgOrderByAggregateInput = {
    progressPercent?: SortOrder
  }

  export type courseEnrollmentsMaxOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    userId?: SortOrder
    progressPercent?: SortOrder
    enrolledAt?: SortOrder
  }

  export type courseEnrollmentsMinOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    userId?: SortOrder
    progressPercent?: SortOrder
    enrolledAt?: SortOrder
  }

  export type courseEnrollmentsSumOrderByAggregateInput = {
    progressPercent?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type mentorsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    expertise?: SortOrder
    rating?: SortOrder
    bio?: SortOrder
  }

  export type mentorsAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type mentorsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    rating?: SortOrder
    bio?: SortOrder
  }

  export type mentorsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    rating?: SortOrder
    bio?: SortOrder
  }

  export type mentorsSumOrderByAggregateInput = {
    rating?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumMentorSessionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MentorSessionStatus | EnumMentorSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MentorSessionStatus[] | ListEnumMentorSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MentorSessionStatus[] | ListEnumMentorSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMentorSessionStatusFilter<$PrismaModel> | $Enums.MentorSessionStatus
  }

  export type MentorsRelationFilter = {
    is?: mentorsWhereInput
    isNot?: mentorsWhereInput
  }

  export type mentorSessionsCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    mentorId?: SortOrder
    scheduled_at?: SortOrder
    status?: SortOrder
    meeting_link?: SortOrder
  }

  export type mentorSessionsMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    mentorId?: SortOrder
    scheduled_at?: SortOrder
    status?: SortOrder
    meeting_link?: SortOrder
  }

  export type mentorSessionsMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    mentorId?: SortOrder
    scheduled_at?: SortOrder
    status?: SortOrder
    meeting_link?: SortOrder
  }

  export type EnumMentorSessionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MentorSessionStatus | EnumMentorSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MentorSessionStatus[] | ListEnumMentorSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MentorSessionStatus[] | ListEnumMentorSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMentorSessionStatusWithAggregatesFilter<$PrismaModel> | $Enums.MentorSessionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMentorSessionStatusFilter<$PrismaModel>
    _max?: NestedEnumMentorSessionStatusFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type mentorReviewsCountOrderByAggregateInput = {
    id?: SortOrder
    mentorId?: SortOrder
    rating?: SortOrder
    reviews?: SortOrder
    studentId?: SortOrder
  }

  export type mentorReviewsAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type mentorReviewsMaxOrderByAggregateInput = {
    id?: SortOrder
    mentorId?: SortOrder
    rating?: SortOrder
    reviews?: SortOrder
    studentId?: SortOrder
  }

  export type mentorReviewsMinOrderByAggregateInput = {
    id?: SortOrder
    mentorId?: SortOrder
    rating?: SortOrder
    reviews?: SortOrder
    studentId?: SortOrder
  }

  export type mentorReviewsSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type portfolioProjectsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    github_url?: SortOrder
    live_url?: SortOrder
    tags?: SortOrder
  }

  export type portfolioProjectsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    github_url?: SortOrder
    live_url?: SortOrder
  }

  export type portfolioProjectsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    github_url?: SortOrder
    live_url?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type internshipsCountOrderByAggregateInput = {
    id?: SortOrder
    industry_user_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    stipend?: SortOrder
    location?: SortOrder
    required_skills?: SortOrder
    duration_weeks?: SortOrder
    created_at?: SortOrder
  }

  export type internshipsAvgOrderByAggregateInput = {
    stipend?: SortOrder
    duration_weeks?: SortOrder
  }

  export type internshipsMaxOrderByAggregateInput = {
    id?: SortOrder
    industry_user_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    stipend?: SortOrder
    location?: SortOrder
    duration_weeks?: SortOrder
    created_at?: SortOrder
  }

  export type internshipsMinOrderByAggregateInput = {
    id?: SortOrder
    industry_user_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    stipend?: SortOrder
    location?: SortOrder
    duration_weeks?: SortOrder
    created_at?: SortOrder
  }

  export type internshipsSumOrderByAggregateInput = {
    stipend?: SortOrder
    duration_weeks?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumInternshipStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InternshipStatus | EnumInternshipStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InternshipStatus[] | ListEnumInternshipStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InternshipStatus[] | ListEnumInternshipStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInternshipStatusFilter<$PrismaModel> | $Enums.InternshipStatus
  }

  export type InternshipsRelationFilter = {
    is?: internshipsWhereInput
    isNot?: internshipsWhereInput
  }

  export type Internship_evaluationListRelationFilter = {
    every?: internship_evaluationWhereInput
    some?: internship_evaluationWhereInput
    none?: internship_evaluationWhereInput
  }

  export type Logbook_entriesListRelationFilter = {
    every?: logbook_entriesWhereInput
    some?: logbook_entriesWhereInput
    none?: logbook_entriesWhereInput
  }

  export type internship_evaluationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type logbook_entriesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type internship_applicationsCountOrderByAggregateInput = {
    id?: SortOrder
    internship_id?: SortOrder
    student_id?: SortOrder
    status?: SortOrder
    submission_url?: SortOrder
    score?: SortOrder
    applied_at?: SortOrder
  }

  export type internship_applicationsAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type internship_applicationsMaxOrderByAggregateInput = {
    id?: SortOrder
    internship_id?: SortOrder
    student_id?: SortOrder
    status?: SortOrder
    submission_url?: SortOrder
    score?: SortOrder
    applied_at?: SortOrder
  }

  export type internship_applicationsMinOrderByAggregateInput = {
    id?: SortOrder
    internship_id?: SortOrder
    student_id?: SortOrder
    status?: SortOrder
    submission_url?: SortOrder
    score?: SortOrder
    applied_at?: SortOrder
  }

  export type internship_applicationsSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type EnumInternshipStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InternshipStatus | EnumInternshipStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InternshipStatus[] | ListEnumInternshipStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InternshipStatus[] | ListEnumInternshipStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInternshipStatusWithAggregatesFilter<$PrismaModel> | $Enums.InternshipStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInternshipStatusFilter<$PrismaModel>
    _max?: NestedEnumInternshipStatusFilter<$PrismaModel>
  }

  export type Internship_applicationsRelationFilter = {
    is?: internship_applicationsWhereInput
    isNot?: internship_applicationsWhereInput
  }

  export type logbook_entriesCountOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    date?: SortOrder
    taskDone?: SortOrder
    proofUrl?: SortOrder
    hours_spent?: SortOrder
  }

  export type logbook_entriesAvgOrderByAggregateInput = {
    hours_spent?: SortOrder
  }

  export type logbook_entriesMaxOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    date?: SortOrder
    taskDone?: SortOrder
    proofUrl?: SortOrder
    hours_spent?: SortOrder
  }

  export type logbook_entriesMinOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    date?: SortOrder
    taskDone?: SortOrder
    proofUrl?: SortOrder
    hours_spent?: SortOrder
  }

  export type logbook_entriesSumOrderByAggregateInput = {
    hours_spent?: SortOrder
  }

  export type FacultyRelationFilter = {
    is?: facultyWhereInput
    isNot?: facultyWhereInput
  }

  export type internship_evaluationCountOrderByAggregateInput = {
    id?: SortOrder
    application_id?: SortOrder
    faculty_id?: SortOrder
    rubric_json?: SortOrder
    comments?: SortOrder
    final_score?: SortOrder
  }

  export type internship_evaluationAvgOrderByAggregateInput = {
    final_score?: SortOrder
  }

  export type internship_evaluationMaxOrderByAggregateInput = {
    id?: SortOrder
    application_id?: SortOrder
    faculty_id?: SortOrder
    comments?: SortOrder
    final_score?: SortOrder
  }

  export type internship_evaluationMinOrderByAggregateInput = {
    id?: SortOrder
    application_id?: SortOrder
    faculty_id?: SortOrder
    comments?: SortOrder
    final_score?: SortOrder
  }

  export type internship_evaluationSumOrderByAggregateInput = {
    final_score?: SortOrder
  }

  export type facultyCountOrderByAggregateInput = {
    id?: SortOrder
    instituteId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    department?: SortOrder
  }

  export type facultyMaxOrderByAggregateInput = {
    id?: SortOrder
    instituteId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    department?: SortOrder
  }

  export type facultyMinOrderByAggregateInput = {
    id?: SortOrder
    instituteId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    department?: SortOrder
  }

  export type creditsCountOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    credits_earned?: SortOrder
  }

  export type creditsAvgOrderByAggregateInput = {
    credits_earned?: SortOrder
  }

  export type creditsMaxOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    credits_earned?: SortOrder
  }

  export type creditsMinOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    credits_earned?: SortOrder
  }

  export type creditsSumOrderByAggregateInput = {
    credits_earned?: SortOrder
  }

  export type certificatesCountOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    title?: SortOrder
    certificateUrl?: SortOrder
    issuedAt?: SortOrder
  }

  export type certificatesMaxOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    title?: SortOrder
    certificateUrl?: SortOrder
    issuedAt?: SortOrder
  }

  export type certificatesMinOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    title?: SortOrder
    certificateUrl?: SortOrder
    issuedAt?: SortOrder
  }

  export type notificationsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
  }

  export type notificationsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
  }

  export type notificationsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
  }

  export type NotificationsRelationFilter = {
    is?: notificationsWhereInput
    isNot?: notificationsWhereInput
  }

  export type user_notificationsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    notification_id?: SortOrder
    isRead?: SortOrder
    read_at?: SortOrder
  }

  export type user_notificationsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    notification_id?: SortOrder
    isRead?: SortOrder
    read_at?: SortOrder
  }

  export type user_notificationsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    notification_id?: SortOrder
    isRead?: SortOrder
    read_at?: SortOrder
  }

  export type usersCreateroleInput = {
    set: string[]
  }

  export type courseEnrollmentsCreateNestedManyWithoutUserInput = {
    create?: XOR<courseEnrollmentsCreateWithoutUserInput, courseEnrollmentsUncheckedCreateWithoutUserInput> | courseEnrollmentsCreateWithoutUserInput[] | courseEnrollmentsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: courseEnrollmentsCreateOrConnectWithoutUserInput | courseEnrollmentsCreateOrConnectWithoutUserInput[]
    createMany?: courseEnrollmentsCreateManyUserInputEnvelope
    connect?: courseEnrollmentsWhereUniqueInput | courseEnrollmentsWhereUniqueInput[]
  }

  export type coursesCreateNestedManyWithoutInstructorInput = {
    create?: XOR<coursesCreateWithoutInstructorInput, coursesUncheckedCreateWithoutInstructorInput> | coursesCreateWithoutInstructorInput[] | coursesUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: coursesCreateOrConnectWithoutInstructorInput | coursesCreateOrConnectWithoutInstructorInput[]
    createMany?: coursesCreateManyInstructorInputEnvelope
    connect?: coursesWhereUniqueInput | coursesWhereUniqueInput[]
  }

  export type facultyCreateNestedOneWithoutUserInput = {
    create?: XOR<facultyCreateWithoutUserInput, facultyUncheckedCreateWithoutUserInput>
    connectOrCreate?: facultyCreateOrConnectWithoutUserInput
    connect?: facultyWhereUniqueInput
  }

  export type institutionsCreateNestedManyWithoutAdminUserInput = {
    create?: XOR<institutionsCreateWithoutAdminUserInput, institutionsUncheckedCreateWithoutAdminUserInput> | institutionsCreateWithoutAdminUserInput[] | institutionsUncheckedCreateWithoutAdminUserInput[]
    connectOrCreate?: institutionsCreateOrConnectWithoutAdminUserInput | institutionsCreateOrConnectWithoutAdminUserInput[]
    createMany?: institutionsCreateManyAdminUserInputEnvelope
    connect?: institutionsWhereUniqueInput | institutionsWhereUniqueInput[]
  }

  export type internshipsCreateNestedManyWithoutIndustryUserInput = {
    create?: XOR<internshipsCreateWithoutIndustryUserInput, internshipsUncheckedCreateWithoutIndustryUserInput> | internshipsCreateWithoutIndustryUserInput[] | internshipsUncheckedCreateWithoutIndustryUserInput[]
    connectOrCreate?: internshipsCreateOrConnectWithoutIndustryUserInput | internshipsCreateOrConnectWithoutIndustryUserInput[]
    createMany?: internshipsCreateManyIndustryUserInputEnvelope
    connect?: internshipsWhereUniqueInput | internshipsWhereUniqueInput[]
  }

  export type mentorsCreateNestedOneWithoutUserInput = {
    create?: XOR<mentorsCreateWithoutUserInput, mentorsUncheckedCreateWithoutUserInput>
    connectOrCreate?: mentorsCreateOrConnectWithoutUserInput
    connect?: mentorsWhereUniqueInput
  }

  export type profileCreateNestedOneWithoutUserInput = {
    create?: XOR<profileCreateWithoutUserInput, profileUncheckedCreateWithoutUserInput>
    connectOrCreate?: profileCreateOrConnectWithoutUserInput
    connect?: profileWhereUniqueInput
  }

  export type user_notificationsCreateNestedManyWithoutUserInput = {
    create?: XOR<user_notificationsCreateWithoutUserInput, user_notificationsUncheckedCreateWithoutUserInput> | user_notificationsCreateWithoutUserInput[] | user_notificationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_notificationsCreateOrConnectWithoutUserInput | user_notificationsCreateOrConnectWithoutUserInput[]
    createMany?: user_notificationsCreateManyUserInputEnvelope
    connect?: user_notificationsWhereUniqueInput | user_notificationsWhereUniqueInput[]
  }

  export type courseEnrollmentsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<courseEnrollmentsCreateWithoutUserInput, courseEnrollmentsUncheckedCreateWithoutUserInput> | courseEnrollmentsCreateWithoutUserInput[] | courseEnrollmentsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: courseEnrollmentsCreateOrConnectWithoutUserInput | courseEnrollmentsCreateOrConnectWithoutUserInput[]
    createMany?: courseEnrollmentsCreateManyUserInputEnvelope
    connect?: courseEnrollmentsWhereUniqueInput | courseEnrollmentsWhereUniqueInput[]
  }

  export type coursesUncheckedCreateNestedManyWithoutInstructorInput = {
    create?: XOR<coursesCreateWithoutInstructorInput, coursesUncheckedCreateWithoutInstructorInput> | coursesCreateWithoutInstructorInput[] | coursesUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: coursesCreateOrConnectWithoutInstructorInput | coursesCreateOrConnectWithoutInstructorInput[]
    createMany?: coursesCreateManyInstructorInputEnvelope
    connect?: coursesWhereUniqueInput | coursesWhereUniqueInput[]
  }

  export type facultyUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<facultyCreateWithoutUserInput, facultyUncheckedCreateWithoutUserInput>
    connectOrCreate?: facultyCreateOrConnectWithoutUserInput
    connect?: facultyWhereUniqueInput
  }

  export type institutionsUncheckedCreateNestedManyWithoutAdminUserInput = {
    create?: XOR<institutionsCreateWithoutAdminUserInput, institutionsUncheckedCreateWithoutAdminUserInput> | institutionsCreateWithoutAdminUserInput[] | institutionsUncheckedCreateWithoutAdminUserInput[]
    connectOrCreate?: institutionsCreateOrConnectWithoutAdminUserInput | institutionsCreateOrConnectWithoutAdminUserInput[]
    createMany?: institutionsCreateManyAdminUserInputEnvelope
    connect?: institutionsWhereUniqueInput | institutionsWhereUniqueInput[]
  }

  export type internshipsUncheckedCreateNestedManyWithoutIndustryUserInput = {
    create?: XOR<internshipsCreateWithoutIndustryUserInput, internshipsUncheckedCreateWithoutIndustryUserInput> | internshipsCreateWithoutIndustryUserInput[] | internshipsUncheckedCreateWithoutIndustryUserInput[]
    connectOrCreate?: internshipsCreateOrConnectWithoutIndustryUserInput | internshipsCreateOrConnectWithoutIndustryUserInput[]
    createMany?: internshipsCreateManyIndustryUserInputEnvelope
    connect?: internshipsWhereUniqueInput | internshipsWhereUniqueInput[]
  }

  export type mentorsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<mentorsCreateWithoutUserInput, mentorsUncheckedCreateWithoutUserInput>
    connectOrCreate?: mentorsCreateOrConnectWithoutUserInput
    connect?: mentorsWhereUniqueInput
  }

  export type profileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<profileCreateWithoutUserInput, profileUncheckedCreateWithoutUserInput>
    connectOrCreate?: profileCreateOrConnectWithoutUserInput
    connect?: profileWhereUniqueInput
  }

  export type user_notificationsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<user_notificationsCreateWithoutUserInput, user_notificationsUncheckedCreateWithoutUserInput> | user_notificationsCreateWithoutUserInput[] | user_notificationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_notificationsCreateOrConnectWithoutUserInput | user_notificationsCreateOrConnectWithoutUserInput[]
    createMany?: user_notificationsCreateManyUserInputEnvelope
    connect?: user_notificationsWhereUniqueInput | user_notificationsWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type usersUpdateroleInput = {
    set?: string[]
    push?: string | string[]
  }

  export type courseEnrollmentsUpdateManyWithoutUserNestedInput = {
    create?: XOR<courseEnrollmentsCreateWithoutUserInput, courseEnrollmentsUncheckedCreateWithoutUserInput> | courseEnrollmentsCreateWithoutUserInput[] | courseEnrollmentsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: courseEnrollmentsCreateOrConnectWithoutUserInput | courseEnrollmentsCreateOrConnectWithoutUserInput[]
    upsert?: courseEnrollmentsUpsertWithWhereUniqueWithoutUserInput | courseEnrollmentsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: courseEnrollmentsCreateManyUserInputEnvelope
    set?: courseEnrollmentsWhereUniqueInput | courseEnrollmentsWhereUniqueInput[]
    disconnect?: courseEnrollmentsWhereUniqueInput | courseEnrollmentsWhereUniqueInput[]
    delete?: courseEnrollmentsWhereUniqueInput | courseEnrollmentsWhereUniqueInput[]
    connect?: courseEnrollmentsWhereUniqueInput | courseEnrollmentsWhereUniqueInput[]
    update?: courseEnrollmentsUpdateWithWhereUniqueWithoutUserInput | courseEnrollmentsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: courseEnrollmentsUpdateManyWithWhereWithoutUserInput | courseEnrollmentsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: courseEnrollmentsScalarWhereInput | courseEnrollmentsScalarWhereInput[]
  }

  export type coursesUpdateManyWithoutInstructorNestedInput = {
    create?: XOR<coursesCreateWithoutInstructorInput, coursesUncheckedCreateWithoutInstructorInput> | coursesCreateWithoutInstructorInput[] | coursesUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: coursesCreateOrConnectWithoutInstructorInput | coursesCreateOrConnectWithoutInstructorInput[]
    upsert?: coursesUpsertWithWhereUniqueWithoutInstructorInput | coursesUpsertWithWhereUniqueWithoutInstructorInput[]
    createMany?: coursesCreateManyInstructorInputEnvelope
    set?: coursesWhereUniqueInput | coursesWhereUniqueInput[]
    disconnect?: coursesWhereUniqueInput | coursesWhereUniqueInput[]
    delete?: coursesWhereUniqueInput | coursesWhereUniqueInput[]
    connect?: coursesWhereUniqueInput | coursesWhereUniqueInput[]
    update?: coursesUpdateWithWhereUniqueWithoutInstructorInput | coursesUpdateWithWhereUniqueWithoutInstructorInput[]
    updateMany?: coursesUpdateManyWithWhereWithoutInstructorInput | coursesUpdateManyWithWhereWithoutInstructorInput[]
    deleteMany?: coursesScalarWhereInput | coursesScalarWhereInput[]
  }

  export type facultyUpdateOneWithoutUserNestedInput = {
    create?: XOR<facultyCreateWithoutUserInput, facultyUncheckedCreateWithoutUserInput>
    connectOrCreate?: facultyCreateOrConnectWithoutUserInput
    upsert?: facultyUpsertWithoutUserInput
    disconnect?: facultyWhereInput | boolean
    delete?: facultyWhereInput | boolean
    connect?: facultyWhereUniqueInput
    update?: XOR<XOR<facultyUpdateToOneWithWhereWithoutUserInput, facultyUpdateWithoutUserInput>, facultyUncheckedUpdateWithoutUserInput>
  }

  export type institutionsUpdateManyWithoutAdminUserNestedInput = {
    create?: XOR<institutionsCreateWithoutAdminUserInput, institutionsUncheckedCreateWithoutAdminUserInput> | institutionsCreateWithoutAdminUserInput[] | institutionsUncheckedCreateWithoutAdminUserInput[]
    connectOrCreate?: institutionsCreateOrConnectWithoutAdminUserInput | institutionsCreateOrConnectWithoutAdminUserInput[]
    upsert?: institutionsUpsertWithWhereUniqueWithoutAdminUserInput | institutionsUpsertWithWhereUniqueWithoutAdminUserInput[]
    createMany?: institutionsCreateManyAdminUserInputEnvelope
    set?: institutionsWhereUniqueInput | institutionsWhereUniqueInput[]
    disconnect?: institutionsWhereUniqueInput | institutionsWhereUniqueInput[]
    delete?: institutionsWhereUniqueInput | institutionsWhereUniqueInput[]
    connect?: institutionsWhereUniqueInput | institutionsWhereUniqueInput[]
    update?: institutionsUpdateWithWhereUniqueWithoutAdminUserInput | institutionsUpdateWithWhereUniqueWithoutAdminUserInput[]
    updateMany?: institutionsUpdateManyWithWhereWithoutAdminUserInput | institutionsUpdateManyWithWhereWithoutAdminUserInput[]
    deleteMany?: institutionsScalarWhereInput | institutionsScalarWhereInput[]
  }

  export type internshipsUpdateManyWithoutIndustryUserNestedInput = {
    create?: XOR<internshipsCreateWithoutIndustryUserInput, internshipsUncheckedCreateWithoutIndustryUserInput> | internshipsCreateWithoutIndustryUserInput[] | internshipsUncheckedCreateWithoutIndustryUserInput[]
    connectOrCreate?: internshipsCreateOrConnectWithoutIndustryUserInput | internshipsCreateOrConnectWithoutIndustryUserInput[]
    upsert?: internshipsUpsertWithWhereUniqueWithoutIndustryUserInput | internshipsUpsertWithWhereUniqueWithoutIndustryUserInput[]
    createMany?: internshipsCreateManyIndustryUserInputEnvelope
    set?: internshipsWhereUniqueInput | internshipsWhereUniqueInput[]
    disconnect?: internshipsWhereUniqueInput | internshipsWhereUniqueInput[]
    delete?: internshipsWhereUniqueInput | internshipsWhereUniqueInput[]
    connect?: internshipsWhereUniqueInput | internshipsWhereUniqueInput[]
    update?: internshipsUpdateWithWhereUniqueWithoutIndustryUserInput | internshipsUpdateWithWhereUniqueWithoutIndustryUserInput[]
    updateMany?: internshipsUpdateManyWithWhereWithoutIndustryUserInput | internshipsUpdateManyWithWhereWithoutIndustryUserInput[]
    deleteMany?: internshipsScalarWhereInput | internshipsScalarWhereInput[]
  }

  export type mentorsUpdateOneWithoutUserNestedInput = {
    create?: XOR<mentorsCreateWithoutUserInput, mentorsUncheckedCreateWithoutUserInput>
    connectOrCreate?: mentorsCreateOrConnectWithoutUserInput
    upsert?: mentorsUpsertWithoutUserInput
    disconnect?: mentorsWhereInput | boolean
    delete?: mentorsWhereInput | boolean
    connect?: mentorsWhereUniqueInput
    update?: XOR<XOR<mentorsUpdateToOneWithWhereWithoutUserInput, mentorsUpdateWithoutUserInput>, mentorsUncheckedUpdateWithoutUserInput>
  }

  export type profileUpdateOneWithoutUserNestedInput = {
    create?: XOR<profileCreateWithoutUserInput, profileUncheckedCreateWithoutUserInput>
    connectOrCreate?: profileCreateOrConnectWithoutUserInput
    upsert?: profileUpsertWithoutUserInput
    disconnect?: profileWhereInput | boolean
    delete?: profileWhereInput | boolean
    connect?: profileWhereUniqueInput
    update?: XOR<XOR<profileUpdateToOneWithWhereWithoutUserInput, profileUpdateWithoutUserInput>, profileUncheckedUpdateWithoutUserInput>
  }

  export type user_notificationsUpdateManyWithoutUserNestedInput = {
    create?: XOR<user_notificationsCreateWithoutUserInput, user_notificationsUncheckedCreateWithoutUserInput> | user_notificationsCreateWithoutUserInput[] | user_notificationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_notificationsCreateOrConnectWithoutUserInput | user_notificationsCreateOrConnectWithoutUserInput[]
    upsert?: user_notificationsUpsertWithWhereUniqueWithoutUserInput | user_notificationsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: user_notificationsCreateManyUserInputEnvelope
    set?: user_notificationsWhereUniqueInput | user_notificationsWhereUniqueInput[]
    disconnect?: user_notificationsWhereUniqueInput | user_notificationsWhereUniqueInput[]
    delete?: user_notificationsWhereUniqueInput | user_notificationsWhereUniqueInput[]
    connect?: user_notificationsWhereUniqueInput | user_notificationsWhereUniqueInput[]
    update?: user_notificationsUpdateWithWhereUniqueWithoutUserInput | user_notificationsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: user_notificationsUpdateManyWithWhereWithoutUserInput | user_notificationsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: user_notificationsScalarWhereInput | user_notificationsScalarWhereInput[]
  }

  export type courseEnrollmentsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<courseEnrollmentsCreateWithoutUserInput, courseEnrollmentsUncheckedCreateWithoutUserInput> | courseEnrollmentsCreateWithoutUserInput[] | courseEnrollmentsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: courseEnrollmentsCreateOrConnectWithoutUserInput | courseEnrollmentsCreateOrConnectWithoutUserInput[]
    upsert?: courseEnrollmentsUpsertWithWhereUniqueWithoutUserInput | courseEnrollmentsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: courseEnrollmentsCreateManyUserInputEnvelope
    set?: courseEnrollmentsWhereUniqueInput | courseEnrollmentsWhereUniqueInput[]
    disconnect?: courseEnrollmentsWhereUniqueInput | courseEnrollmentsWhereUniqueInput[]
    delete?: courseEnrollmentsWhereUniqueInput | courseEnrollmentsWhereUniqueInput[]
    connect?: courseEnrollmentsWhereUniqueInput | courseEnrollmentsWhereUniqueInput[]
    update?: courseEnrollmentsUpdateWithWhereUniqueWithoutUserInput | courseEnrollmentsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: courseEnrollmentsUpdateManyWithWhereWithoutUserInput | courseEnrollmentsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: courseEnrollmentsScalarWhereInput | courseEnrollmentsScalarWhereInput[]
  }

  export type coursesUncheckedUpdateManyWithoutInstructorNestedInput = {
    create?: XOR<coursesCreateWithoutInstructorInput, coursesUncheckedCreateWithoutInstructorInput> | coursesCreateWithoutInstructorInput[] | coursesUncheckedCreateWithoutInstructorInput[]
    connectOrCreate?: coursesCreateOrConnectWithoutInstructorInput | coursesCreateOrConnectWithoutInstructorInput[]
    upsert?: coursesUpsertWithWhereUniqueWithoutInstructorInput | coursesUpsertWithWhereUniqueWithoutInstructorInput[]
    createMany?: coursesCreateManyInstructorInputEnvelope
    set?: coursesWhereUniqueInput | coursesWhereUniqueInput[]
    disconnect?: coursesWhereUniqueInput | coursesWhereUniqueInput[]
    delete?: coursesWhereUniqueInput | coursesWhereUniqueInput[]
    connect?: coursesWhereUniqueInput | coursesWhereUniqueInput[]
    update?: coursesUpdateWithWhereUniqueWithoutInstructorInput | coursesUpdateWithWhereUniqueWithoutInstructorInput[]
    updateMany?: coursesUpdateManyWithWhereWithoutInstructorInput | coursesUpdateManyWithWhereWithoutInstructorInput[]
    deleteMany?: coursesScalarWhereInput | coursesScalarWhereInput[]
  }

  export type facultyUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<facultyCreateWithoutUserInput, facultyUncheckedCreateWithoutUserInput>
    connectOrCreate?: facultyCreateOrConnectWithoutUserInput
    upsert?: facultyUpsertWithoutUserInput
    disconnect?: facultyWhereInput | boolean
    delete?: facultyWhereInput | boolean
    connect?: facultyWhereUniqueInput
    update?: XOR<XOR<facultyUpdateToOneWithWhereWithoutUserInput, facultyUpdateWithoutUserInput>, facultyUncheckedUpdateWithoutUserInput>
  }

  export type institutionsUncheckedUpdateManyWithoutAdminUserNestedInput = {
    create?: XOR<institutionsCreateWithoutAdminUserInput, institutionsUncheckedCreateWithoutAdminUserInput> | institutionsCreateWithoutAdminUserInput[] | institutionsUncheckedCreateWithoutAdminUserInput[]
    connectOrCreate?: institutionsCreateOrConnectWithoutAdminUserInput | institutionsCreateOrConnectWithoutAdminUserInput[]
    upsert?: institutionsUpsertWithWhereUniqueWithoutAdminUserInput | institutionsUpsertWithWhereUniqueWithoutAdminUserInput[]
    createMany?: institutionsCreateManyAdminUserInputEnvelope
    set?: institutionsWhereUniqueInput | institutionsWhereUniqueInput[]
    disconnect?: institutionsWhereUniqueInput | institutionsWhereUniqueInput[]
    delete?: institutionsWhereUniqueInput | institutionsWhereUniqueInput[]
    connect?: institutionsWhereUniqueInput | institutionsWhereUniqueInput[]
    update?: institutionsUpdateWithWhereUniqueWithoutAdminUserInput | institutionsUpdateWithWhereUniqueWithoutAdminUserInput[]
    updateMany?: institutionsUpdateManyWithWhereWithoutAdminUserInput | institutionsUpdateManyWithWhereWithoutAdminUserInput[]
    deleteMany?: institutionsScalarWhereInput | institutionsScalarWhereInput[]
  }

  export type internshipsUncheckedUpdateManyWithoutIndustryUserNestedInput = {
    create?: XOR<internshipsCreateWithoutIndustryUserInput, internshipsUncheckedCreateWithoutIndustryUserInput> | internshipsCreateWithoutIndustryUserInput[] | internshipsUncheckedCreateWithoutIndustryUserInput[]
    connectOrCreate?: internshipsCreateOrConnectWithoutIndustryUserInput | internshipsCreateOrConnectWithoutIndustryUserInput[]
    upsert?: internshipsUpsertWithWhereUniqueWithoutIndustryUserInput | internshipsUpsertWithWhereUniqueWithoutIndustryUserInput[]
    createMany?: internshipsCreateManyIndustryUserInputEnvelope
    set?: internshipsWhereUniqueInput | internshipsWhereUniqueInput[]
    disconnect?: internshipsWhereUniqueInput | internshipsWhereUniqueInput[]
    delete?: internshipsWhereUniqueInput | internshipsWhereUniqueInput[]
    connect?: internshipsWhereUniqueInput | internshipsWhereUniqueInput[]
    update?: internshipsUpdateWithWhereUniqueWithoutIndustryUserInput | internshipsUpdateWithWhereUniqueWithoutIndustryUserInput[]
    updateMany?: internshipsUpdateManyWithWhereWithoutIndustryUserInput | internshipsUpdateManyWithWhereWithoutIndustryUserInput[]
    deleteMany?: internshipsScalarWhereInput | internshipsScalarWhereInput[]
  }

  export type mentorsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<mentorsCreateWithoutUserInput, mentorsUncheckedCreateWithoutUserInput>
    connectOrCreate?: mentorsCreateOrConnectWithoutUserInput
    upsert?: mentorsUpsertWithoutUserInput
    disconnect?: mentorsWhereInput | boolean
    delete?: mentorsWhereInput | boolean
    connect?: mentorsWhereUniqueInput
    update?: XOR<XOR<mentorsUpdateToOneWithWhereWithoutUserInput, mentorsUpdateWithoutUserInput>, mentorsUncheckedUpdateWithoutUserInput>
  }

  export type profileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<profileCreateWithoutUserInput, profileUncheckedCreateWithoutUserInput>
    connectOrCreate?: profileCreateOrConnectWithoutUserInput
    upsert?: profileUpsertWithoutUserInput
    disconnect?: profileWhereInput | boolean
    delete?: profileWhereInput | boolean
    connect?: profileWhereUniqueInput
    update?: XOR<XOR<profileUpdateToOneWithWhereWithoutUserInput, profileUpdateWithoutUserInput>, profileUncheckedUpdateWithoutUserInput>
  }

  export type user_notificationsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<user_notificationsCreateWithoutUserInput, user_notificationsUncheckedCreateWithoutUserInput> | user_notificationsCreateWithoutUserInput[] | user_notificationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_notificationsCreateOrConnectWithoutUserInput | user_notificationsCreateOrConnectWithoutUserInput[]
    upsert?: user_notificationsUpsertWithWhereUniqueWithoutUserInput | user_notificationsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: user_notificationsCreateManyUserInputEnvelope
    set?: user_notificationsWhereUniqueInput | user_notificationsWhereUniqueInput[]
    disconnect?: user_notificationsWhereUniqueInput | user_notificationsWhereUniqueInput[]
    delete?: user_notificationsWhereUniqueInput | user_notificationsWhereUniqueInput[]
    connect?: user_notificationsWhereUniqueInput | user_notificationsWhereUniqueInput[]
    update?: user_notificationsUpdateWithWhereUniqueWithoutUserInput | user_notificationsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: user_notificationsUpdateManyWithWhereWithoutUserInput | user_notificationsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: user_notificationsScalarWhereInput | user_notificationsScalarWhereInput[]
  }

  export type facultyCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<facultyCreateWithoutInstitutionInput, facultyUncheckedCreateWithoutInstitutionInput> | facultyCreateWithoutInstitutionInput[] | facultyUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: facultyCreateOrConnectWithoutInstitutionInput | facultyCreateOrConnectWithoutInstitutionInput[]
    createMany?: facultyCreateManyInstitutionInputEnvelope
    connect?: facultyWhereUniqueInput | facultyWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutInstitutions_adminInput = {
    create?: XOR<usersCreateWithoutInstitutions_adminInput, usersUncheckedCreateWithoutInstitutions_adminInput>
    connectOrCreate?: usersCreateOrConnectWithoutInstitutions_adminInput
    connect?: usersWhereUniqueInput
  }

  export type profileCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<profileCreateWithoutInstitutionInput, profileUncheckedCreateWithoutInstitutionInput> | profileCreateWithoutInstitutionInput[] | profileUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: profileCreateOrConnectWithoutInstitutionInput | profileCreateOrConnectWithoutInstitutionInput[]
    createMany?: profileCreateManyInstitutionInputEnvelope
    connect?: profileWhereUniqueInput | profileWhereUniqueInput[]
  }

  export type facultyUncheckedCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<facultyCreateWithoutInstitutionInput, facultyUncheckedCreateWithoutInstitutionInput> | facultyCreateWithoutInstitutionInput[] | facultyUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: facultyCreateOrConnectWithoutInstitutionInput | facultyCreateOrConnectWithoutInstitutionInput[]
    createMany?: facultyCreateManyInstitutionInputEnvelope
    connect?: facultyWhereUniqueInput | facultyWhereUniqueInput[]
  }

  export type profileUncheckedCreateNestedManyWithoutInstitutionInput = {
    create?: XOR<profileCreateWithoutInstitutionInput, profileUncheckedCreateWithoutInstitutionInput> | profileCreateWithoutInstitutionInput[] | profileUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: profileCreateOrConnectWithoutInstitutionInput | profileCreateOrConnectWithoutInstitutionInput[]
    createMany?: profileCreateManyInstitutionInputEnvelope
    connect?: profileWhereUniqueInput | profileWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type facultyUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<facultyCreateWithoutInstitutionInput, facultyUncheckedCreateWithoutInstitutionInput> | facultyCreateWithoutInstitutionInput[] | facultyUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: facultyCreateOrConnectWithoutInstitutionInput | facultyCreateOrConnectWithoutInstitutionInput[]
    upsert?: facultyUpsertWithWhereUniqueWithoutInstitutionInput | facultyUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: facultyCreateManyInstitutionInputEnvelope
    set?: facultyWhereUniqueInput | facultyWhereUniqueInput[]
    disconnect?: facultyWhereUniqueInput | facultyWhereUniqueInput[]
    delete?: facultyWhereUniqueInput | facultyWhereUniqueInput[]
    connect?: facultyWhereUniqueInput | facultyWhereUniqueInput[]
    update?: facultyUpdateWithWhereUniqueWithoutInstitutionInput | facultyUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: facultyUpdateManyWithWhereWithoutInstitutionInput | facultyUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: facultyScalarWhereInput | facultyScalarWhereInput[]
  }

  export type usersUpdateOneRequiredWithoutInstitutions_adminNestedInput = {
    create?: XOR<usersCreateWithoutInstitutions_adminInput, usersUncheckedCreateWithoutInstitutions_adminInput>
    connectOrCreate?: usersCreateOrConnectWithoutInstitutions_adminInput
    upsert?: usersUpsertWithoutInstitutions_adminInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutInstitutions_adminInput, usersUpdateWithoutInstitutions_adminInput>, usersUncheckedUpdateWithoutInstitutions_adminInput>
  }

  export type profileUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<profileCreateWithoutInstitutionInput, profileUncheckedCreateWithoutInstitutionInput> | profileCreateWithoutInstitutionInput[] | profileUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: profileCreateOrConnectWithoutInstitutionInput | profileCreateOrConnectWithoutInstitutionInput[]
    upsert?: profileUpsertWithWhereUniqueWithoutInstitutionInput | profileUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: profileCreateManyInstitutionInputEnvelope
    set?: profileWhereUniqueInput | profileWhereUniqueInput[]
    disconnect?: profileWhereUniqueInput | profileWhereUniqueInput[]
    delete?: profileWhereUniqueInput | profileWhereUniqueInput[]
    connect?: profileWhereUniqueInput | profileWhereUniqueInput[]
    update?: profileUpdateWithWhereUniqueWithoutInstitutionInput | profileUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: profileUpdateManyWithWhereWithoutInstitutionInput | profileUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: profileScalarWhereInput | profileScalarWhereInput[]
  }

  export type facultyUncheckedUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<facultyCreateWithoutInstitutionInput, facultyUncheckedCreateWithoutInstitutionInput> | facultyCreateWithoutInstitutionInput[] | facultyUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: facultyCreateOrConnectWithoutInstitutionInput | facultyCreateOrConnectWithoutInstitutionInput[]
    upsert?: facultyUpsertWithWhereUniqueWithoutInstitutionInput | facultyUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: facultyCreateManyInstitutionInputEnvelope
    set?: facultyWhereUniqueInput | facultyWhereUniqueInput[]
    disconnect?: facultyWhereUniqueInput | facultyWhereUniqueInput[]
    delete?: facultyWhereUniqueInput | facultyWhereUniqueInput[]
    connect?: facultyWhereUniqueInput | facultyWhereUniqueInput[]
    update?: facultyUpdateWithWhereUniqueWithoutInstitutionInput | facultyUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: facultyUpdateManyWithWhereWithoutInstitutionInput | facultyUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: facultyScalarWhereInput | facultyScalarWhereInput[]
  }

  export type profileUncheckedUpdateManyWithoutInstitutionNestedInput = {
    create?: XOR<profileCreateWithoutInstitutionInput, profileUncheckedCreateWithoutInstitutionInput> | profileCreateWithoutInstitutionInput[] | profileUncheckedCreateWithoutInstitutionInput[]
    connectOrCreate?: profileCreateOrConnectWithoutInstitutionInput | profileCreateOrConnectWithoutInstitutionInput[]
    upsert?: profileUpsertWithWhereUniqueWithoutInstitutionInput | profileUpsertWithWhereUniqueWithoutInstitutionInput[]
    createMany?: profileCreateManyInstitutionInputEnvelope
    set?: profileWhereUniqueInput | profileWhereUniqueInput[]
    disconnect?: profileWhereUniqueInput | profileWhereUniqueInput[]
    delete?: profileWhereUniqueInput | profileWhereUniqueInput[]
    connect?: profileWhereUniqueInput | profileWhereUniqueInput[]
    update?: profileUpdateWithWhereUniqueWithoutInstitutionInput | profileUpdateWithWhereUniqueWithoutInstitutionInput[]
    updateMany?: profileUpdateManyWithWhereWithoutInstitutionInput | profileUpdateManyWithWhereWithoutInstitutionInput[]
    deleteMany?: profileScalarWhereInput | profileScalarWhereInput[]
  }

  export type profileCreateskillsInput = {
    set: string[]
  }

  export type profileCreateinterestsInput = {
    set: string[]
  }

  export type certificatesCreateNestedManyWithoutStudentInput = {
    create?: XOR<certificatesCreateWithoutStudentInput, certificatesUncheckedCreateWithoutStudentInput> | certificatesCreateWithoutStudentInput[] | certificatesUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: certificatesCreateOrConnectWithoutStudentInput | certificatesCreateOrConnectWithoutStudentInput[]
    createMany?: certificatesCreateManyStudentInputEnvelope
    connect?: certificatesWhereUniqueInput | certificatesWhereUniqueInput[]
  }

  export type creditsCreateNestedManyWithoutStudentInput = {
    create?: XOR<creditsCreateWithoutStudentInput, creditsUncheckedCreateWithoutStudentInput> | creditsCreateWithoutStudentInput[] | creditsUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: creditsCreateOrConnectWithoutStudentInput | creditsCreateOrConnectWithoutStudentInput[]
    createMany?: creditsCreateManyStudentInputEnvelope
    connect?: creditsWhereUniqueInput | creditsWhereUniqueInput[]
  }

  export type internship_applicationsCreateNestedManyWithoutStudentInput = {
    create?: XOR<internship_applicationsCreateWithoutStudentInput, internship_applicationsUncheckedCreateWithoutStudentInput> | internship_applicationsCreateWithoutStudentInput[] | internship_applicationsUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: internship_applicationsCreateOrConnectWithoutStudentInput | internship_applicationsCreateOrConnectWithoutStudentInput[]
    createMany?: internship_applicationsCreateManyStudentInputEnvelope
    connect?: internship_applicationsWhereUniqueInput | internship_applicationsWhereUniqueInput[]
  }

  export type mentorReviewsCreateNestedManyWithoutStudentInput = {
    create?: XOR<mentorReviewsCreateWithoutStudentInput, mentorReviewsUncheckedCreateWithoutStudentInput> | mentorReviewsCreateWithoutStudentInput[] | mentorReviewsUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: mentorReviewsCreateOrConnectWithoutStudentInput | mentorReviewsCreateOrConnectWithoutStudentInput[]
    createMany?: mentorReviewsCreateManyStudentInputEnvelope
    connect?: mentorReviewsWhereUniqueInput | mentorReviewsWhereUniqueInput[]
  }

  export type mentorSessionsCreateNestedManyWithoutStudentInput = {
    create?: XOR<mentorSessionsCreateWithoutStudentInput, mentorSessionsUncheckedCreateWithoutStudentInput> | mentorSessionsCreateWithoutStudentInput[] | mentorSessionsUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: mentorSessionsCreateOrConnectWithoutStudentInput | mentorSessionsCreateOrConnectWithoutStudentInput[]
    createMany?: mentorSessionsCreateManyStudentInputEnvelope
    connect?: mentorSessionsWhereUniqueInput | mentorSessionsWhereUniqueInput[]
  }

  export type portfolioProjectsCreateNestedManyWithoutUserInput = {
    create?: XOR<portfolioProjectsCreateWithoutUserInput, portfolioProjectsUncheckedCreateWithoutUserInput> | portfolioProjectsCreateWithoutUserInput[] | portfolioProjectsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: portfolioProjectsCreateOrConnectWithoutUserInput | portfolioProjectsCreateOrConnectWithoutUserInput[]
    createMany?: portfolioProjectsCreateManyUserInputEnvelope
    connect?: portfolioProjectsWhereUniqueInput | portfolioProjectsWhereUniqueInput[]
  }

  export type facultyCreateNestedOneWithoutStudentsInput = {
    create?: XOR<facultyCreateWithoutStudentsInput, facultyUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: facultyCreateOrConnectWithoutStudentsInput
    connect?: facultyWhereUniqueInput
  }

  export type institutionsCreateNestedOneWithoutProfilesInput = {
    create?: XOR<institutionsCreateWithoutProfilesInput, institutionsUncheckedCreateWithoutProfilesInput>
    connectOrCreate?: institutionsCreateOrConnectWithoutProfilesInput
    connect?: institutionsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutProfilesInput = {
    create?: XOR<usersCreateWithoutProfilesInput, usersUncheckedCreateWithoutProfilesInput>
    connectOrCreate?: usersCreateOrConnectWithoutProfilesInput
    connect?: usersWhereUniqueInput
  }

  export type studentLearningProgressCreateNestedManyWithoutProfileInput = {
    create?: XOR<studentLearningProgressCreateWithoutProfileInput, studentLearningProgressUncheckedCreateWithoutProfileInput> | studentLearningProgressCreateWithoutProfileInput[] | studentLearningProgressUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: studentLearningProgressCreateOrConnectWithoutProfileInput | studentLearningProgressCreateOrConnectWithoutProfileInput[]
    createMany?: studentLearningProgressCreateManyProfileInputEnvelope
    connect?: studentLearningProgressWhereUniqueInput | studentLearningProgressWhereUniqueInput[]
  }

  export type certificatesUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<certificatesCreateWithoutStudentInput, certificatesUncheckedCreateWithoutStudentInput> | certificatesCreateWithoutStudentInput[] | certificatesUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: certificatesCreateOrConnectWithoutStudentInput | certificatesCreateOrConnectWithoutStudentInput[]
    createMany?: certificatesCreateManyStudentInputEnvelope
    connect?: certificatesWhereUniqueInput | certificatesWhereUniqueInput[]
  }

  export type creditsUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<creditsCreateWithoutStudentInput, creditsUncheckedCreateWithoutStudentInput> | creditsCreateWithoutStudentInput[] | creditsUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: creditsCreateOrConnectWithoutStudentInput | creditsCreateOrConnectWithoutStudentInput[]
    createMany?: creditsCreateManyStudentInputEnvelope
    connect?: creditsWhereUniqueInput | creditsWhereUniqueInput[]
  }

  export type internship_applicationsUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<internship_applicationsCreateWithoutStudentInput, internship_applicationsUncheckedCreateWithoutStudentInput> | internship_applicationsCreateWithoutStudentInput[] | internship_applicationsUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: internship_applicationsCreateOrConnectWithoutStudentInput | internship_applicationsCreateOrConnectWithoutStudentInput[]
    createMany?: internship_applicationsCreateManyStudentInputEnvelope
    connect?: internship_applicationsWhereUniqueInput | internship_applicationsWhereUniqueInput[]
  }

  export type mentorReviewsUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<mentorReviewsCreateWithoutStudentInput, mentorReviewsUncheckedCreateWithoutStudentInput> | mentorReviewsCreateWithoutStudentInput[] | mentorReviewsUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: mentorReviewsCreateOrConnectWithoutStudentInput | mentorReviewsCreateOrConnectWithoutStudentInput[]
    createMany?: mentorReviewsCreateManyStudentInputEnvelope
    connect?: mentorReviewsWhereUniqueInput | mentorReviewsWhereUniqueInput[]
  }

  export type mentorSessionsUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<mentorSessionsCreateWithoutStudentInput, mentorSessionsUncheckedCreateWithoutStudentInput> | mentorSessionsCreateWithoutStudentInput[] | mentorSessionsUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: mentorSessionsCreateOrConnectWithoutStudentInput | mentorSessionsCreateOrConnectWithoutStudentInput[]
    createMany?: mentorSessionsCreateManyStudentInputEnvelope
    connect?: mentorSessionsWhereUniqueInput | mentorSessionsWhereUniqueInput[]
  }

  export type portfolioProjectsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<portfolioProjectsCreateWithoutUserInput, portfolioProjectsUncheckedCreateWithoutUserInput> | portfolioProjectsCreateWithoutUserInput[] | portfolioProjectsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: portfolioProjectsCreateOrConnectWithoutUserInput | portfolioProjectsCreateOrConnectWithoutUserInput[]
    createMany?: portfolioProjectsCreateManyUserInputEnvelope
    connect?: portfolioProjectsWhereUniqueInput | portfolioProjectsWhereUniqueInput[]
  }

  export type studentLearningProgressUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<studentLearningProgressCreateWithoutProfileInput, studentLearningProgressUncheckedCreateWithoutProfileInput> | studentLearningProgressCreateWithoutProfileInput[] | studentLearningProgressUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: studentLearningProgressCreateOrConnectWithoutProfileInput | studentLearningProgressCreateOrConnectWithoutProfileInput[]
    createMany?: studentLearningProgressCreateManyProfileInputEnvelope
    connect?: studentLearningProgressWhereUniqueInput | studentLearningProgressWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type profileUpdateskillsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type profileUpdateinterestsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type certificatesUpdateManyWithoutStudentNestedInput = {
    create?: XOR<certificatesCreateWithoutStudentInput, certificatesUncheckedCreateWithoutStudentInput> | certificatesCreateWithoutStudentInput[] | certificatesUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: certificatesCreateOrConnectWithoutStudentInput | certificatesCreateOrConnectWithoutStudentInput[]
    upsert?: certificatesUpsertWithWhereUniqueWithoutStudentInput | certificatesUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: certificatesCreateManyStudentInputEnvelope
    set?: certificatesWhereUniqueInput | certificatesWhereUniqueInput[]
    disconnect?: certificatesWhereUniqueInput | certificatesWhereUniqueInput[]
    delete?: certificatesWhereUniqueInput | certificatesWhereUniqueInput[]
    connect?: certificatesWhereUniqueInput | certificatesWhereUniqueInput[]
    update?: certificatesUpdateWithWhereUniqueWithoutStudentInput | certificatesUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: certificatesUpdateManyWithWhereWithoutStudentInput | certificatesUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: certificatesScalarWhereInput | certificatesScalarWhereInput[]
  }

  export type creditsUpdateManyWithoutStudentNestedInput = {
    create?: XOR<creditsCreateWithoutStudentInput, creditsUncheckedCreateWithoutStudentInput> | creditsCreateWithoutStudentInput[] | creditsUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: creditsCreateOrConnectWithoutStudentInput | creditsCreateOrConnectWithoutStudentInput[]
    upsert?: creditsUpsertWithWhereUniqueWithoutStudentInput | creditsUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: creditsCreateManyStudentInputEnvelope
    set?: creditsWhereUniqueInput | creditsWhereUniqueInput[]
    disconnect?: creditsWhereUniqueInput | creditsWhereUniqueInput[]
    delete?: creditsWhereUniqueInput | creditsWhereUniqueInput[]
    connect?: creditsWhereUniqueInput | creditsWhereUniqueInput[]
    update?: creditsUpdateWithWhereUniqueWithoutStudentInput | creditsUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: creditsUpdateManyWithWhereWithoutStudentInput | creditsUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: creditsScalarWhereInput | creditsScalarWhereInput[]
  }

  export type internship_applicationsUpdateManyWithoutStudentNestedInput = {
    create?: XOR<internship_applicationsCreateWithoutStudentInput, internship_applicationsUncheckedCreateWithoutStudentInput> | internship_applicationsCreateWithoutStudentInput[] | internship_applicationsUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: internship_applicationsCreateOrConnectWithoutStudentInput | internship_applicationsCreateOrConnectWithoutStudentInput[]
    upsert?: internship_applicationsUpsertWithWhereUniqueWithoutStudentInput | internship_applicationsUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: internship_applicationsCreateManyStudentInputEnvelope
    set?: internship_applicationsWhereUniqueInput | internship_applicationsWhereUniqueInput[]
    disconnect?: internship_applicationsWhereUniqueInput | internship_applicationsWhereUniqueInput[]
    delete?: internship_applicationsWhereUniqueInput | internship_applicationsWhereUniqueInput[]
    connect?: internship_applicationsWhereUniqueInput | internship_applicationsWhereUniqueInput[]
    update?: internship_applicationsUpdateWithWhereUniqueWithoutStudentInput | internship_applicationsUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: internship_applicationsUpdateManyWithWhereWithoutStudentInput | internship_applicationsUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: internship_applicationsScalarWhereInput | internship_applicationsScalarWhereInput[]
  }

  export type mentorReviewsUpdateManyWithoutStudentNestedInput = {
    create?: XOR<mentorReviewsCreateWithoutStudentInput, mentorReviewsUncheckedCreateWithoutStudentInput> | mentorReviewsCreateWithoutStudentInput[] | mentorReviewsUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: mentorReviewsCreateOrConnectWithoutStudentInput | mentorReviewsCreateOrConnectWithoutStudentInput[]
    upsert?: mentorReviewsUpsertWithWhereUniqueWithoutStudentInput | mentorReviewsUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: mentorReviewsCreateManyStudentInputEnvelope
    set?: mentorReviewsWhereUniqueInput | mentorReviewsWhereUniqueInput[]
    disconnect?: mentorReviewsWhereUniqueInput | mentorReviewsWhereUniqueInput[]
    delete?: mentorReviewsWhereUniqueInput | mentorReviewsWhereUniqueInput[]
    connect?: mentorReviewsWhereUniqueInput | mentorReviewsWhereUniqueInput[]
    update?: mentorReviewsUpdateWithWhereUniqueWithoutStudentInput | mentorReviewsUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: mentorReviewsUpdateManyWithWhereWithoutStudentInput | mentorReviewsUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: mentorReviewsScalarWhereInput | mentorReviewsScalarWhereInput[]
  }

  export type mentorSessionsUpdateManyWithoutStudentNestedInput = {
    create?: XOR<mentorSessionsCreateWithoutStudentInput, mentorSessionsUncheckedCreateWithoutStudentInput> | mentorSessionsCreateWithoutStudentInput[] | mentorSessionsUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: mentorSessionsCreateOrConnectWithoutStudentInput | mentorSessionsCreateOrConnectWithoutStudentInput[]
    upsert?: mentorSessionsUpsertWithWhereUniqueWithoutStudentInput | mentorSessionsUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: mentorSessionsCreateManyStudentInputEnvelope
    set?: mentorSessionsWhereUniqueInput | mentorSessionsWhereUniqueInput[]
    disconnect?: mentorSessionsWhereUniqueInput | mentorSessionsWhereUniqueInput[]
    delete?: mentorSessionsWhereUniqueInput | mentorSessionsWhereUniqueInput[]
    connect?: mentorSessionsWhereUniqueInput | mentorSessionsWhereUniqueInput[]
    update?: mentorSessionsUpdateWithWhereUniqueWithoutStudentInput | mentorSessionsUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: mentorSessionsUpdateManyWithWhereWithoutStudentInput | mentorSessionsUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: mentorSessionsScalarWhereInput | mentorSessionsScalarWhereInput[]
  }

  export type portfolioProjectsUpdateManyWithoutUserNestedInput = {
    create?: XOR<portfolioProjectsCreateWithoutUserInput, portfolioProjectsUncheckedCreateWithoutUserInput> | portfolioProjectsCreateWithoutUserInput[] | portfolioProjectsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: portfolioProjectsCreateOrConnectWithoutUserInput | portfolioProjectsCreateOrConnectWithoutUserInput[]
    upsert?: portfolioProjectsUpsertWithWhereUniqueWithoutUserInput | portfolioProjectsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: portfolioProjectsCreateManyUserInputEnvelope
    set?: portfolioProjectsWhereUniqueInput | portfolioProjectsWhereUniqueInput[]
    disconnect?: portfolioProjectsWhereUniqueInput | portfolioProjectsWhereUniqueInput[]
    delete?: portfolioProjectsWhereUniqueInput | portfolioProjectsWhereUniqueInput[]
    connect?: portfolioProjectsWhereUniqueInput | portfolioProjectsWhereUniqueInput[]
    update?: portfolioProjectsUpdateWithWhereUniqueWithoutUserInput | portfolioProjectsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: portfolioProjectsUpdateManyWithWhereWithoutUserInput | portfolioProjectsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: portfolioProjectsScalarWhereInput | portfolioProjectsScalarWhereInput[]
  }

  export type facultyUpdateOneWithoutStudentsNestedInput = {
    create?: XOR<facultyCreateWithoutStudentsInput, facultyUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: facultyCreateOrConnectWithoutStudentsInput
    upsert?: facultyUpsertWithoutStudentsInput
    disconnect?: facultyWhereInput | boolean
    delete?: facultyWhereInput | boolean
    connect?: facultyWhereUniqueInput
    update?: XOR<XOR<facultyUpdateToOneWithWhereWithoutStudentsInput, facultyUpdateWithoutStudentsInput>, facultyUncheckedUpdateWithoutStudentsInput>
  }

  export type institutionsUpdateOneRequiredWithoutProfilesNestedInput = {
    create?: XOR<institutionsCreateWithoutProfilesInput, institutionsUncheckedCreateWithoutProfilesInput>
    connectOrCreate?: institutionsCreateOrConnectWithoutProfilesInput
    upsert?: institutionsUpsertWithoutProfilesInput
    connect?: institutionsWhereUniqueInput
    update?: XOR<XOR<institutionsUpdateToOneWithWhereWithoutProfilesInput, institutionsUpdateWithoutProfilesInput>, institutionsUncheckedUpdateWithoutProfilesInput>
  }

  export type usersUpdateOneRequiredWithoutProfilesNestedInput = {
    create?: XOR<usersCreateWithoutProfilesInput, usersUncheckedCreateWithoutProfilesInput>
    connectOrCreate?: usersCreateOrConnectWithoutProfilesInput
    upsert?: usersUpsertWithoutProfilesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutProfilesInput, usersUpdateWithoutProfilesInput>, usersUncheckedUpdateWithoutProfilesInput>
  }

  export type studentLearningProgressUpdateManyWithoutProfileNestedInput = {
    create?: XOR<studentLearningProgressCreateWithoutProfileInput, studentLearningProgressUncheckedCreateWithoutProfileInput> | studentLearningProgressCreateWithoutProfileInput[] | studentLearningProgressUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: studentLearningProgressCreateOrConnectWithoutProfileInput | studentLearningProgressCreateOrConnectWithoutProfileInput[]
    upsert?: studentLearningProgressUpsertWithWhereUniqueWithoutProfileInput | studentLearningProgressUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: studentLearningProgressCreateManyProfileInputEnvelope
    set?: studentLearningProgressWhereUniqueInput | studentLearningProgressWhereUniqueInput[]
    disconnect?: studentLearningProgressWhereUniqueInput | studentLearningProgressWhereUniqueInput[]
    delete?: studentLearningProgressWhereUniqueInput | studentLearningProgressWhereUniqueInput[]
    connect?: studentLearningProgressWhereUniqueInput | studentLearningProgressWhereUniqueInput[]
    update?: studentLearningProgressUpdateWithWhereUniqueWithoutProfileInput | studentLearningProgressUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: studentLearningProgressUpdateManyWithWhereWithoutProfileInput | studentLearningProgressUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: studentLearningProgressScalarWhereInput | studentLearningProgressScalarWhereInput[]
  }

  export type certificatesUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<certificatesCreateWithoutStudentInput, certificatesUncheckedCreateWithoutStudentInput> | certificatesCreateWithoutStudentInput[] | certificatesUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: certificatesCreateOrConnectWithoutStudentInput | certificatesCreateOrConnectWithoutStudentInput[]
    upsert?: certificatesUpsertWithWhereUniqueWithoutStudentInput | certificatesUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: certificatesCreateManyStudentInputEnvelope
    set?: certificatesWhereUniqueInput | certificatesWhereUniqueInput[]
    disconnect?: certificatesWhereUniqueInput | certificatesWhereUniqueInput[]
    delete?: certificatesWhereUniqueInput | certificatesWhereUniqueInput[]
    connect?: certificatesWhereUniqueInput | certificatesWhereUniqueInput[]
    update?: certificatesUpdateWithWhereUniqueWithoutStudentInput | certificatesUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: certificatesUpdateManyWithWhereWithoutStudentInput | certificatesUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: certificatesScalarWhereInput | certificatesScalarWhereInput[]
  }

  export type creditsUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<creditsCreateWithoutStudentInput, creditsUncheckedCreateWithoutStudentInput> | creditsCreateWithoutStudentInput[] | creditsUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: creditsCreateOrConnectWithoutStudentInput | creditsCreateOrConnectWithoutStudentInput[]
    upsert?: creditsUpsertWithWhereUniqueWithoutStudentInput | creditsUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: creditsCreateManyStudentInputEnvelope
    set?: creditsWhereUniqueInput | creditsWhereUniqueInput[]
    disconnect?: creditsWhereUniqueInput | creditsWhereUniqueInput[]
    delete?: creditsWhereUniqueInput | creditsWhereUniqueInput[]
    connect?: creditsWhereUniqueInput | creditsWhereUniqueInput[]
    update?: creditsUpdateWithWhereUniqueWithoutStudentInput | creditsUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: creditsUpdateManyWithWhereWithoutStudentInput | creditsUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: creditsScalarWhereInput | creditsScalarWhereInput[]
  }

  export type internship_applicationsUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<internship_applicationsCreateWithoutStudentInput, internship_applicationsUncheckedCreateWithoutStudentInput> | internship_applicationsCreateWithoutStudentInput[] | internship_applicationsUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: internship_applicationsCreateOrConnectWithoutStudentInput | internship_applicationsCreateOrConnectWithoutStudentInput[]
    upsert?: internship_applicationsUpsertWithWhereUniqueWithoutStudentInput | internship_applicationsUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: internship_applicationsCreateManyStudentInputEnvelope
    set?: internship_applicationsWhereUniqueInput | internship_applicationsWhereUniqueInput[]
    disconnect?: internship_applicationsWhereUniqueInput | internship_applicationsWhereUniqueInput[]
    delete?: internship_applicationsWhereUniqueInput | internship_applicationsWhereUniqueInput[]
    connect?: internship_applicationsWhereUniqueInput | internship_applicationsWhereUniqueInput[]
    update?: internship_applicationsUpdateWithWhereUniqueWithoutStudentInput | internship_applicationsUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: internship_applicationsUpdateManyWithWhereWithoutStudentInput | internship_applicationsUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: internship_applicationsScalarWhereInput | internship_applicationsScalarWhereInput[]
  }

  export type mentorReviewsUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<mentorReviewsCreateWithoutStudentInput, mentorReviewsUncheckedCreateWithoutStudentInput> | mentorReviewsCreateWithoutStudentInput[] | mentorReviewsUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: mentorReviewsCreateOrConnectWithoutStudentInput | mentorReviewsCreateOrConnectWithoutStudentInput[]
    upsert?: mentorReviewsUpsertWithWhereUniqueWithoutStudentInput | mentorReviewsUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: mentorReviewsCreateManyStudentInputEnvelope
    set?: mentorReviewsWhereUniqueInput | mentorReviewsWhereUniqueInput[]
    disconnect?: mentorReviewsWhereUniqueInput | mentorReviewsWhereUniqueInput[]
    delete?: mentorReviewsWhereUniqueInput | mentorReviewsWhereUniqueInput[]
    connect?: mentorReviewsWhereUniqueInput | mentorReviewsWhereUniqueInput[]
    update?: mentorReviewsUpdateWithWhereUniqueWithoutStudentInput | mentorReviewsUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: mentorReviewsUpdateManyWithWhereWithoutStudentInput | mentorReviewsUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: mentorReviewsScalarWhereInput | mentorReviewsScalarWhereInput[]
  }

  export type mentorSessionsUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<mentorSessionsCreateWithoutStudentInput, mentorSessionsUncheckedCreateWithoutStudentInput> | mentorSessionsCreateWithoutStudentInput[] | mentorSessionsUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: mentorSessionsCreateOrConnectWithoutStudentInput | mentorSessionsCreateOrConnectWithoutStudentInput[]
    upsert?: mentorSessionsUpsertWithWhereUniqueWithoutStudentInput | mentorSessionsUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: mentorSessionsCreateManyStudentInputEnvelope
    set?: mentorSessionsWhereUniqueInput | mentorSessionsWhereUniqueInput[]
    disconnect?: mentorSessionsWhereUniqueInput | mentorSessionsWhereUniqueInput[]
    delete?: mentorSessionsWhereUniqueInput | mentorSessionsWhereUniqueInput[]
    connect?: mentorSessionsWhereUniqueInput | mentorSessionsWhereUniqueInput[]
    update?: mentorSessionsUpdateWithWhereUniqueWithoutStudentInput | mentorSessionsUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: mentorSessionsUpdateManyWithWhereWithoutStudentInput | mentorSessionsUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: mentorSessionsScalarWhereInput | mentorSessionsScalarWhereInput[]
  }

  export type portfolioProjectsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<portfolioProjectsCreateWithoutUserInput, portfolioProjectsUncheckedCreateWithoutUserInput> | portfolioProjectsCreateWithoutUserInput[] | portfolioProjectsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: portfolioProjectsCreateOrConnectWithoutUserInput | portfolioProjectsCreateOrConnectWithoutUserInput[]
    upsert?: portfolioProjectsUpsertWithWhereUniqueWithoutUserInput | portfolioProjectsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: portfolioProjectsCreateManyUserInputEnvelope
    set?: portfolioProjectsWhereUniqueInput | portfolioProjectsWhereUniqueInput[]
    disconnect?: portfolioProjectsWhereUniqueInput | portfolioProjectsWhereUniqueInput[]
    delete?: portfolioProjectsWhereUniqueInput | portfolioProjectsWhereUniqueInput[]
    connect?: portfolioProjectsWhereUniqueInput | portfolioProjectsWhereUniqueInput[]
    update?: portfolioProjectsUpdateWithWhereUniqueWithoutUserInput | portfolioProjectsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: portfolioProjectsUpdateManyWithWhereWithoutUserInput | portfolioProjectsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: portfolioProjectsScalarWhereInput | portfolioProjectsScalarWhereInput[]
  }

  export type studentLearningProgressUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<studentLearningProgressCreateWithoutProfileInput, studentLearningProgressUncheckedCreateWithoutProfileInput> | studentLearningProgressCreateWithoutProfileInput[] | studentLearningProgressUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: studentLearningProgressCreateOrConnectWithoutProfileInput | studentLearningProgressCreateOrConnectWithoutProfileInput[]
    upsert?: studentLearningProgressUpsertWithWhereUniqueWithoutProfileInput | studentLearningProgressUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: studentLearningProgressCreateManyProfileInputEnvelope
    set?: studentLearningProgressWhereUniqueInput | studentLearningProgressWhereUniqueInput[]
    disconnect?: studentLearningProgressWhereUniqueInput | studentLearningProgressWhereUniqueInput[]
    delete?: studentLearningProgressWhereUniqueInput | studentLearningProgressWhereUniqueInput[]
    connect?: studentLearningProgressWhereUniqueInput | studentLearningProgressWhereUniqueInput[]
    update?: studentLearningProgressUpdateWithWhereUniqueWithoutProfileInput | studentLearningProgressUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: studentLearningProgressUpdateManyWithWhereWithoutProfileInput | studentLearningProgressUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: studentLearningProgressScalarWhereInput | studentLearningProgressScalarWhereInput[]
  }

  export type checkpointsCreateNestedManyWithoutRoadmapInput = {
    create?: XOR<checkpointsCreateWithoutRoadmapInput, checkpointsUncheckedCreateWithoutRoadmapInput> | checkpointsCreateWithoutRoadmapInput[] | checkpointsUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: checkpointsCreateOrConnectWithoutRoadmapInput | checkpointsCreateOrConnectWithoutRoadmapInput[]
    createMany?: checkpointsCreateManyRoadmapInputEnvelope
    connect?: checkpointsWhereUniqueInput | checkpointsWhereUniqueInput[]
  }

  export type checkpointsUncheckedCreateNestedManyWithoutRoadmapInput = {
    create?: XOR<checkpointsCreateWithoutRoadmapInput, checkpointsUncheckedCreateWithoutRoadmapInput> | checkpointsCreateWithoutRoadmapInput[] | checkpointsUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: checkpointsCreateOrConnectWithoutRoadmapInput | checkpointsCreateOrConnectWithoutRoadmapInput[]
    createMany?: checkpointsCreateManyRoadmapInputEnvelope
    connect?: checkpointsWhereUniqueInput | checkpointsWhereUniqueInput[]
  }

  export type checkpointsUpdateManyWithoutRoadmapNestedInput = {
    create?: XOR<checkpointsCreateWithoutRoadmapInput, checkpointsUncheckedCreateWithoutRoadmapInput> | checkpointsCreateWithoutRoadmapInput[] | checkpointsUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: checkpointsCreateOrConnectWithoutRoadmapInput | checkpointsCreateOrConnectWithoutRoadmapInput[]
    upsert?: checkpointsUpsertWithWhereUniqueWithoutRoadmapInput | checkpointsUpsertWithWhereUniqueWithoutRoadmapInput[]
    createMany?: checkpointsCreateManyRoadmapInputEnvelope
    set?: checkpointsWhereUniqueInput | checkpointsWhereUniqueInput[]
    disconnect?: checkpointsWhereUniqueInput | checkpointsWhereUniqueInput[]
    delete?: checkpointsWhereUniqueInput | checkpointsWhereUniqueInput[]
    connect?: checkpointsWhereUniqueInput | checkpointsWhereUniqueInput[]
    update?: checkpointsUpdateWithWhereUniqueWithoutRoadmapInput | checkpointsUpdateWithWhereUniqueWithoutRoadmapInput[]
    updateMany?: checkpointsUpdateManyWithWhereWithoutRoadmapInput | checkpointsUpdateManyWithWhereWithoutRoadmapInput[]
    deleteMany?: checkpointsScalarWhereInput | checkpointsScalarWhereInput[]
  }

  export type checkpointsUncheckedUpdateManyWithoutRoadmapNestedInput = {
    create?: XOR<checkpointsCreateWithoutRoadmapInput, checkpointsUncheckedCreateWithoutRoadmapInput> | checkpointsCreateWithoutRoadmapInput[] | checkpointsUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: checkpointsCreateOrConnectWithoutRoadmapInput | checkpointsCreateOrConnectWithoutRoadmapInput[]
    upsert?: checkpointsUpsertWithWhereUniqueWithoutRoadmapInput | checkpointsUpsertWithWhereUniqueWithoutRoadmapInput[]
    createMany?: checkpointsCreateManyRoadmapInputEnvelope
    set?: checkpointsWhereUniqueInput | checkpointsWhereUniqueInput[]
    disconnect?: checkpointsWhereUniqueInput | checkpointsWhereUniqueInput[]
    delete?: checkpointsWhereUniqueInput | checkpointsWhereUniqueInput[]
    connect?: checkpointsWhereUniqueInput | checkpointsWhereUniqueInput[]
    update?: checkpointsUpdateWithWhereUniqueWithoutRoadmapInput | checkpointsUpdateWithWhereUniqueWithoutRoadmapInput[]
    updateMany?: checkpointsUpdateManyWithWhereWithoutRoadmapInput | checkpointsUpdateManyWithWhereWithoutRoadmapInput[]
    deleteMany?: checkpointsScalarWhereInput | checkpointsScalarWhereInput[]
  }

  export type roadmapsCreateNestedOneWithoutCheckpointsInput = {
    create?: XOR<roadmapsCreateWithoutCheckpointsInput, roadmapsUncheckedCreateWithoutCheckpointsInput>
    connectOrCreate?: roadmapsCreateOrConnectWithoutCheckpointsInput
    connect?: roadmapsWhereUniqueInput
  }

  export type studentLearningProgressCreateNestedManyWithoutCheckpointInput = {
    create?: XOR<studentLearningProgressCreateWithoutCheckpointInput, studentLearningProgressUncheckedCreateWithoutCheckpointInput> | studentLearningProgressCreateWithoutCheckpointInput[] | studentLearningProgressUncheckedCreateWithoutCheckpointInput[]
    connectOrCreate?: studentLearningProgressCreateOrConnectWithoutCheckpointInput | studentLearningProgressCreateOrConnectWithoutCheckpointInput[]
    createMany?: studentLearningProgressCreateManyCheckpointInputEnvelope
    connect?: studentLearningProgressWhereUniqueInput | studentLearningProgressWhereUniqueInput[]
  }

  export type studentLearningProgressUncheckedCreateNestedManyWithoutCheckpointInput = {
    create?: XOR<studentLearningProgressCreateWithoutCheckpointInput, studentLearningProgressUncheckedCreateWithoutCheckpointInput> | studentLearningProgressCreateWithoutCheckpointInput[] | studentLearningProgressUncheckedCreateWithoutCheckpointInput[]
    connectOrCreate?: studentLearningProgressCreateOrConnectWithoutCheckpointInput | studentLearningProgressCreateOrConnectWithoutCheckpointInput[]
    createMany?: studentLearningProgressCreateManyCheckpointInputEnvelope
    connect?: studentLearningProgressWhereUniqueInput | studentLearningProgressWhereUniqueInput[]
  }

  export type roadmapsUpdateOneRequiredWithoutCheckpointsNestedInput = {
    create?: XOR<roadmapsCreateWithoutCheckpointsInput, roadmapsUncheckedCreateWithoutCheckpointsInput>
    connectOrCreate?: roadmapsCreateOrConnectWithoutCheckpointsInput
    upsert?: roadmapsUpsertWithoutCheckpointsInput
    connect?: roadmapsWhereUniqueInput
    update?: XOR<XOR<roadmapsUpdateToOneWithWhereWithoutCheckpointsInput, roadmapsUpdateWithoutCheckpointsInput>, roadmapsUncheckedUpdateWithoutCheckpointsInput>
  }

  export type studentLearningProgressUpdateManyWithoutCheckpointNestedInput = {
    create?: XOR<studentLearningProgressCreateWithoutCheckpointInput, studentLearningProgressUncheckedCreateWithoutCheckpointInput> | studentLearningProgressCreateWithoutCheckpointInput[] | studentLearningProgressUncheckedCreateWithoutCheckpointInput[]
    connectOrCreate?: studentLearningProgressCreateOrConnectWithoutCheckpointInput | studentLearningProgressCreateOrConnectWithoutCheckpointInput[]
    upsert?: studentLearningProgressUpsertWithWhereUniqueWithoutCheckpointInput | studentLearningProgressUpsertWithWhereUniqueWithoutCheckpointInput[]
    createMany?: studentLearningProgressCreateManyCheckpointInputEnvelope
    set?: studentLearningProgressWhereUniqueInput | studentLearningProgressWhereUniqueInput[]
    disconnect?: studentLearningProgressWhereUniqueInput | studentLearningProgressWhereUniqueInput[]
    delete?: studentLearningProgressWhereUniqueInput | studentLearningProgressWhereUniqueInput[]
    connect?: studentLearningProgressWhereUniqueInput | studentLearningProgressWhereUniqueInput[]
    update?: studentLearningProgressUpdateWithWhereUniqueWithoutCheckpointInput | studentLearningProgressUpdateWithWhereUniqueWithoutCheckpointInput[]
    updateMany?: studentLearningProgressUpdateManyWithWhereWithoutCheckpointInput | studentLearningProgressUpdateManyWithWhereWithoutCheckpointInput[]
    deleteMany?: studentLearningProgressScalarWhereInput | studentLearningProgressScalarWhereInput[]
  }

  export type studentLearningProgressUncheckedUpdateManyWithoutCheckpointNestedInput = {
    create?: XOR<studentLearningProgressCreateWithoutCheckpointInput, studentLearningProgressUncheckedCreateWithoutCheckpointInput> | studentLearningProgressCreateWithoutCheckpointInput[] | studentLearningProgressUncheckedCreateWithoutCheckpointInput[]
    connectOrCreate?: studentLearningProgressCreateOrConnectWithoutCheckpointInput | studentLearningProgressCreateOrConnectWithoutCheckpointInput[]
    upsert?: studentLearningProgressUpsertWithWhereUniqueWithoutCheckpointInput | studentLearningProgressUpsertWithWhereUniqueWithoutCheckpointInput[]
    createMany?: studentLearningProgressCreateManyCheckpointInputEnvelope
    set?: studentLearningProgressWhereUniqueInput | studentLearningProgressWhereUniqueInput[]
    disconnect?: studentLearningProgressWhereUniqueInput | studentLearningProgressWhereUniqueInput[]
    delete?: studentLearningProgressWhereUniqueInput | studentLearningProgressWhereUniqueInput[]
    connect?: studentLearningProgressWhereUniqueInput | studentLearningProgressWhereUniqueInput[]
    update?: studentLearningProgressUpdateWithWhereUniqueWithoutCheckpointInput | studentLearningProgressUpdateWithWhereUniqueWithoutCheckpointInput[]
    updateMany?: studentLearningProgressUpdateManyWithWhereWithoutCheckpointInput | studentLearningProgressUpdateManyWithWhereWithoutCheckpointInput[]
    deleteMany?: studentLearningProgressScalarWhereInput | studentLearningProgressScalarWhereInput[]
  }

  export type checkpointsCreateNestedOneWithoutProgressInput = {
    create?: XOR<checkpointsCreateWithoutProgressInput, checkpointsUncheckedCreateWithoutProgressInput>
    connectOrCreate?: checkpointsCreateOrConnectWithoutProgressInput
    connect?: checkpointsWhereUniqueInput
  }

  export type profileCreateNestedOneWithoutLearningProgressInput = {
    create?: XOR<profileCreateWithoutLearningProgressInput, profileUncheckedCreateWithoutLearningProgressInput>
    connectOrCreate?: profileCreateOrConnectWithoutLearningProgressInput
    connect?: profileWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type checkpointsUpdateOneRequiredWithoutProgressNestedInput = {
    create?: XOR<checkpointsCreateWithoutProgressInput, checkpointsUncheckedCreateWithoutProgressInput>
    connectOrCreate?: checkpointsCreateOrConnectWithoutProgressInput
    upsert?: checkpointsUpsertWithoutProgressInput
    connect?: checkpointsWhereUniqueInput
    update?: XOR<XOR<checkpointsUpdateToOneWithWhereWithoutProgressInput, checkpointsUpdateWithoutProgressInput>, checkpointsUncheckedUpdateWithoutProgressInput>
  }

  export type profileUpdateOneRequiredWithoutLearningProgressNestedInput = {
    create?: XOR<profileCreateWithoutLearningProgressInput, profileUncheckedCreateWithoutLearningProgressInput>
    connectOrCreate?: profileCreateOrConnectWithoutLearningProgressInput
    upsert?: profileUpsertWithoutLearningProgressInput
    connect?: profileWhereUniqueInput
    update?: XOR<XOR<profileUpdateToOneWithWhereWithoutLearningProgressInput, profileUpdateWithoutLearningProgressInput>, profileUncheckedUpdateWithoutLearningProgressInput>
  }

  export type courseEnrollmentsCreateNestedManyWithoutCourseInput = {
    create?: XOR<courseEnrollmentsCreateWithoutCourseInput, courseEnrollmentsUncheckedCreateWithoutCourseInput> | courseEnrollmentsCreateWithoutCourseInput[] | courseEnrollmentsUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: courseEnrollmentsCreateOrConnectWithoutCourseInput | courseEnrollmentsCreateOrConnectWithoutCourseInput[]
    createMany?: courseEnrollmentsCreateManyCourseInputEnvelope
    connect?: courseEnrollmentsWhereUniqueInput | courseEnrollmentsWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutCourses_instructorInput = {
    create?: XOR<usersCreateWithoutCourses_instructorInput, usersUncheckedCreateWithoutCourses_instructorInput>
    connectOrCreate?: usersCreateOrConnectWithoutCourses_instructorInput
    connect?: usersWhereUniqueInput
  }

  export type courseEnrollmentsUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<courseEnrollmentsCreateWithoutCourseInput, courseEnrollmentsUncheckedCreateWithoutCourseInput> | courseEnrollmentsCreateWithoutCourseInput[] | courseEnrollmentsUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: courseEnrollmentsCreateOrConnectWithoutCourseInput | courseEnrollmentsCreateOrConnectWithoutCourseInput[]
    createMany?: courseEnrollmentsCreateManyCourseInputEnvelope
    connect?: courseEnrollmentsWhereUniqueInput | courseEnrollmentsWhereUniqueInput[]
  }

  export type EnumCourseTypeFieldUpdateOperationsInput = {
    set?: $Enums.CourseType
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type courseEnrollmentsUpdateManyWithoutCourseNestedInput = {
    create?: XOR<courseEnrollmentsCreateWithoutCourseInput, courseEnrollmentsUncheckedCreateWithoutCourseInput> | courseEnrollmentsCreateWithoutCourseInput[] | courseEnrollmentsUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: courseEnrollmentsCreateOrConnectWithoutCourseInput | courseEnrollmentsCreateOrConnectWithoutCourseInput[]
    upsert?: courseEnrollmentsUpsertWithWhereUniqueWithoutCourseInput | courseEnrollmentsUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: courseEnrollmentsCreateManyCourseInputEnvelope
    set?: courseEnrollmentsWhereUniqueInput | courseEnrollmentsWhereUniqueInput[]
    disconnect?: courseEnrollmentsWhereUniqueInput | courseEnrollmentsWhereUniqueInput[]
    delete?: courseEnrollmentsWhereUniqueInput | courseEnrollmentsWhereUniqueInput[]
    connect?: courseEnrollmentsWhereUniqueInput | courseEnrollmentsWhereUniqueInput[]
    update?: courseEnrollmentsUpdateWithWhereUniqueWithoutCourseInput | courseEnrollmentsUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: courseEnrollmentsUpdateManyWithWhereWithoutCourseInput | courseEnrollmentsUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: courseEnrollmentsScalarWhereInput | courseEnrollmentsScalarWhereInput[]
  }

  export type usersUpdateOneRequiredWithoutCourses_instructorNestedInput = {
    create?: XOR<usersCreateWithoutCourses_instructorInput, usersUncheckedCreateWithoutCourses_instructorInput>
    connectOrCreate?: usersCreateOrConnectWithoutCourses_instructorInput
    upsert?: usersUpsertWithoutCourses_instructorInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutCourses_instructorInput, usersUpdateWithoutCourses_instructorInput>, usersUncheckedUpdateWithoutCourses_instructorInput>
  }

  export type courseEnrollmentsUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<courseEnrollmentsCreateWithoutCourseInput, courseEnrollmentsUncheckedCreateWithoutCourseInput> | courseEnrollmentsCreateWithoutCourseInput[] | courseEnrollmentsUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: courseEnrollmentsCreateOrConnectWithoutCourseInput | courseEnrollmentsCreateOrConnectWithoutCourseInput[]
    upsert?: courseEnrollmentsUpsertWithWhereUniqueWithoutCourseInput | courseEnrollmentsUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: courseEnrollmentsCreateManyCourseInputEnvelope
    set?: courseEnrollmentsWhereUniqueInput | courseEnrollmentsWhereUniqueInput[]
    disconnect?: courseEnrollmentsWhereUniqueInput | courseEnrollmentsWhereUniqueInput[]
    delete?: courseEnrollmentsWhereUniqueInput | courseEnrollmentsWhereUniqueInput[]
    connect?: courseEnrollmentsWhereUniqueInput | courseEnrollmentsWhereUniqueInput[]
    update?: courseEnrollmentsUpdateWithWhereUniqueWithoutCourseInput | courseEnrollmentsUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: courseEnrollmentsUpdateManyWithWhereWithoutCourseInput | courseEnrollmentsUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: courseEnrollmentsScalarWhereInput | courseEnrollmentsScalarWhereInput[]
  }

  export type coursesCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<coursesCreateWithoutEnrollmentsInput, coursesUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: coursesCreateOrConnectWithoutEnrollmentsInput
    connect?: coursesWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutCourseEnrollmentsInput = {
    create?: XOR<usersCreateWithoutCourseEnrollmentsInput, usersUncheckedCreateWithoutCourseEnrollmentsInput>
    connectOrCreate?: usersCreateOrConnectWithoutCourseEnrollmentsInput
    connect?: usersWhereUniqueInput
  }

  export type coursesUpdateOneRequiredWithoutEnrollmentsNestedInput = {
    create?: XOR<coursesCreateWithoutEnrollmentsInput, coursesUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: coursesCreateOrConnectWithoutEnrollmentsInput
    upsert?: coursesUpsertWithoutEnrollmentsInput
    connect?: coursesWhereUniqueInput
    update?: XOR<XOR<coursesUpdateToOneWithWhereWithoutEnrollmentsInput, coursesUpdateWithoutEnrollmentsInput>, coursesUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type usersUpdateOneRequiredWithoutCourseEnrollmentsNestedInput = {
    create?: XOR<usersCreateWithoutCourseEnrollmentsInput, usersUncheckedCreateWithoutCourseEnrollmentsInput>
    connectOrCreate?: usersCreateOrConnectWithoutCourseEnrollmentsInput
    upsert?: usersUpsertWithoutCourseEnrollmentsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutCourseEnrollmentsInput, usersUpdateWithoutCourseEnrollmentsInput>, usersUncheckedUpdateWithoutCourseEnrollmentsInput>
  }

  export type mentorReviewsCreateNestedManyWithoutMentorInput = {
    create?: XOR<mentorReviewsCreateWithoutMentorInput, mentorReviewsUncheckedCreateWithoutMentorInput> | mentorReviewsCreateWithoutMentorInput[] | mentorReviewsUncheckedCreateWithoutMentorInput[]
    connectOrCreate?: mentorReviewsCreateOrConnectWithoutMentorInput | mentorReviewsCreateOrConnectWithoutMentorInput[]
    createMany?: mentorReviewsCreateManyMentorInputEnvelope
    connect?: mentorReviewsWhereUniqueInput | mentorReviewsWhereUniqueInput[]
  }

  export type mentorSessionsCreateNestedManyWithoutMentorInput = {
    create?: XOR<mentorSessionsCreateWithoutMentorInput, mentorSessionsUncheckedCreateWithoutMentorInput> | mentorSessionsCreateWithoutMentorInput[] | mentorSessionsUncheckedCreateWithoutMentorInput[]
    connectOrCreate?: mentorSessionsCreateOrConnectWithoutMentorInput | mentorSessionsCreateOrConnectWithoutMentorInput[]
    createMany?: mentorSessionsCreateManyMentorInputEnvelope
    connect?: mentorSessionsWhereUniqueInput | mentorSessionsWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutMentorsInput = {
    create?: XOR<usersCreateWithoutMentorsInput, usersUncheckedCreateWithoutMentorsInput>
    connectOrCreate?: usersCreateOrConnectWithoutMentorsInput
    connect?: usersWhereUniqueInput
  }

  export type mentorReviewsUncheckedCreateNestedManyWithoutMentorInput = {
    create?: XOR<mentorReviewsCreateWithoutMentorInput, mentorReviewsUncheckedCreateWithoutMentorInput> | mentorReviewsCreateWithoutMentorInput[] | mentorReviewsUncheckedCreateWithoutMentorInput[]
    connectOrCreate?: mentorReviewsCreateOrConnectWithoutMentorInput | mentorReviewsCreateOrConnectWithoutMentorInput[]
    createMany?: mentorReviewsCreateManyMentorInputEnvelope
    connect?: mentorReviewsWhereUniqueInput | mentorReviewsWhereUniqueInput[]
  }

  export type mentorSessionsUncheckedCreateNestedManyWithoutMentorInput = {
    create?: XOR<mentorSessionsCreateWithoutMentorInput, mentorSessionsUncheckedCreateWithoutMentorInput> | mentorSessionsCreateWithoutMentorInput[] | mentorSessionsUncheckedCreateWithoutMentorInput[]
    connectOrCreate?: mentorSessionsCreateOrConnectWithoutMentorInput | mentorSessionsCreateOrConnectWithoutMentorInput[]
    createMany?: mentorSessionsCreateManyMentorInputEnvelope
    connect?: mentorSessionsWhereUniqueInput | mentorSessionsWhereUniqueInput[]
  }

  export type mentorReviewsUpdateManyWithoutMentorNestedInput = {
    create?: XOR<mentorReviewsCreateWithoutMentorInput, mentorReviewsUncheckedCreateWithoutMentorInput> | mentorReviewsCreateWithoutMentorInput[] | mentorReviewsUncheckedCreateWithoutMentorInput[]
    connectOrCreate?: mentorReviewsCreateOrConnectWithoutMentorInput | mentorReviewsCreateOrConnectWithoutMentorInput[]
    upsert?: mentorReviewsUpsertWithWhereUniqueWithoutMentorInput | mentorReviewsUpsertWithWhereUniqueWithoutMentorInput[]
    createMany?: mentorReviewsCreateManyMentorInputEnvelope
    set?: mentorReviewsWhereUniqueInput | mentorReviewsWhereUniqueInput[]
    disconnect?: mentorReviewsWhereUniqueInput | mentorReviewsWhereUniqueInput[]
    delete?: mentorReviewsWhereUniqueInput | mentorReviewsWhereUniqueInput[]
    connect?: mentorReviewsWhereUniqueInput | mentorReviewsWhereUniqueInput[]
    update?: mentorReviewsUpdateWithWhereUniqueWithoutMentorInput | mentorReviewsUpdateWithWhereUniqueWithoutMentorInput[]
    updateMany?: mentorReviewsUpdateManyWithWhereWithoutMentorInput | mentorReviewsUpdateManyWithWhereWithoutMentorInput[]
    deleteMany?: mentorReviewsScalarWhereInput | mentorReviewsScalarWhereInput[]
  }

  export type mentorSessionsUpdateManyWithoutMentorNestedInput = {
    create?: XOR<mentorSessionsCreateWithoutMentorInput, mentorSessionsUncheckedCreateWithoutMentorInput> | mentorSessionsCreateWithoutMentorInput[] | mentorSessionsUncheckedCreateWithoutMentorInput[]
    connectOrCreate?: mentorSessionsCreateOrConnectWithoutMentorInput | mentorSessionsCreateOrConnectWithoutMentorInput[]
    upsert?: mentorSessionsUpsertWithWhereUniqueWithoutMentorInput | mentorSessionsUpsertWithWhereUniqueWithoutMentorInput[]
    createMany?: mentorSessionsCreateManyMentorInputEnvelope
    set?: mentorSessionsWhereUniqueInput | mentorSessionsWhereUniqueInput[]
    disconnect?: mentorSessionsWhereUniqueInput | mentorSessionsWhereUniqueInput[]
    delete?: mentorSessionsWhereUniqueInput | mentorSessionsWhereUniqueInput[]
    connect?: mentorSessionsWhereUniqueInput | mentorSessionsWhereUniqueInput[]
    update?: mentorSessionsUpdateWithWhereUniqueWithoutMentorInput | mentorSessionsUpdateWithWhereUniqueWithoutMentorInput[]
    updateMany?: mentorSessionsUpdateManyWithWhereWithoutMentorInput | mentorSessionsUpdateManyWithWhereWithoutMentorInput[]
    deleteMany?: mentorSessionsScalarWhereInput | mentorSessionsScalarWhereInput[]
  }

  export type usersUpdateOneRequiredWithoutMentorsNestedInput = {
    create?: XOR<usersCreateWithoutMentorsInput, usersUncheckedCreateWithoutMentorsInput>
    connectOrCreate?: usersCreateOrConnectWithoutMentorsInput
    upsert?: usersUpsertWithoutMentorsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutMentorsInput, usersUpdateWithoutMentorsInput>, usersUncheckedUpdateWithoutMentorsInput>
  }

  export type mentorReviewsUncheckedUpdateManyWithoutMentorNestedInput = {
    create?: XOR<mentorReviewsCreateWithoutMentorInput, mentorReviewsUncheckedCreateWithoutMentorInput> | mentorReviewsCreateWithoutMentorInput[] | mentorReviewsUncheckedCreateWithoutMentorInput[]
    connectOrCreate?: mentorReviewsCreateOrConnectWithoutMentorInput | mentorReviewsCreateOrConnectWithoutMentorInput[]
    upsert?: mentorReviewsUpsertWithWhereUniqueWithoutMentorInput | mentorReviewsUpsertWithWhereUniqueWithoutMentorInput[]
    createMany?: mentorReviewsCreateManyMentorInputEnvelope
    set?: mentorReviewsWhereUniqueInput | mentorReviewsWhereUniqueInput[]
    disconnect?: mentorReviewsWhereUniqueInput | mentorReviewsWhereUniqueInput[]
    delete?: mentorReviewsWhereUniqueInput | mentorReviewsWhereUniqueInput[]
    connect?: mentorReviewsWhereUniqueInput | mentorReviewsWhereUniqueInput[]
    update?: mentorReviewsUpdateWithWhereUniqueWithoutMentorInput | mentorReviewsUpdateWithWhereUniqueWithoutMentorInput[]
    updateMany?: mentorReviewsUpdateManyWithWhereWithoutMentorInput | mentorReviewsUpdateManyWithWhereWithoutMentorInput[]
    deleteMany?: mentorReviewsScalarWhereInput | mentorReviewsScalarWhereInput[]
  }

  export type mentorSessionsUncheckedUpdateManyWithoutMentorNestedInput = {
    create?: XOR<mentorSessionsCreateWithoutMentorInput, mentorSessionsUncheckedCreateWithoutMentorInput> | mentorSessionsCreateWithoutMentorInput[] | mentorSessionsUncheckedCreateWithoutMentorInput[]
    connectOrCreate?: mentorSessionsCreateOrConnectWithoutMentorInput | mentorSessionsCreateOrConnectWithoutMentorInput[]
    upsert?: mentorSessionsUpsertWithWhereUniqueWithoutMentorInput | mentorSessionsUpsertWithWhereUniqueWithoutMentorInput[]
    createMany?: mentorSessionsCreateManyMentorInputEnvelope
    set?: mentorSessionsWhereUniqueInput | mentorSessionsWhereUniqueInput[]
    disconnect?: mentorSessionsWhereUniqueInput | mentorSessionsWhereUniqueInput[]
    delete?: mentorSessionsWhereUniqueInput | mentorSessionsWhereUniqueInput[]
    connect?: mentorSessionsWhereUniqueInput | mentorSessionsWhereUniqueInput[]
    update?: mentorSessionsUpdateWithWhereUniqueWithoutMentorInput | mentorSessionsUpdateWithWhereUniqueWithoutMentorInput[]
    updateMany?: mentorSessionsUpdateManyWithWhereWithoutMentorInput | mentorSessionsUpdateManyWithWhereWithoutMentorInput[]
    deleteMany?: mentorSessionsScalarWhereInput | mentorSessionsScalarWhereInput[]
  }

  export type mentorsCreateNestedOneWithoutSessionsInput = {
    create?: XOR<mentorsCreateWithoutSessionsInput, mentorsUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: mentorsCreateOrConnectWithoutSessionsInput
    connect?: mentorsWhereUniqueInput
  }

  export type profileCreateNestedOneWithoutMentorSessionsInput = {
    create?: XOR<profileCreateWithoutMentorSessionsInput, profileUncheckedCreateWithoutMentorSessionsInput>
    connectOrCreate?: profileCreateOrConnectWithoutMentorSessionsInput
    connect?: profileWhereUniqueInput
  }

  export type EnumMentorSessionStatusFieldUpdateOperationsInput = {
    set?: $Enums.MentorSessionStatus
  }

  export type mentorsUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<mentorsCreateWithoutSessionsInput, mentorsUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: mentorsCreateOrConnectWithoutSessionsInput
    upsert?: mentorsUpsertWithoutSessionsInput
    connect?: mentorsWhereUniqueInput
    update?: XOR<XOR<mentorsUpdateToOneWithWhereWithoutSessionsInput, mentorsUpdateWithoutSessionsInput>, mentorsUncheckedUpdateWithoutSessionsInput>
  }

  export type profileUpdateOneRequiredWithoutMentorSessionsNestedInput = {
    create?: XOR<profileCreateWithoutMentorSessionsInput, profileUncheckedCreateWithoutMentorSessionsInput>
    connectOrCreate?: profileCreateOrConnectWithoutMentorSessionsInput
    upsert?: profileUpsertWithoutMentorSessionsInput
    connect?: profileWhereUniqueInput
    update?: XOR<XOR<profileUpdateToOneWithWhereWithoutMentorSessionsInput, profileUpdateWithoutMentorSessionsInput>, profileUncheckedUpdateWithoutMentorSessionsInput>
  }

  export type mentorsCreateNestedOneWithoutReviewsInput = {
    create?: XOR<mentorsCreateWithoutReviewsInput, mentorsUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: mentorsCreateOrConnectWithoutReviewsInput
    connect?: mentorsWhereUniqueInput
  }

  export type profileCreateNestedOneWithoutMentorReviewsInput = {
    create?: XOR<profileCreateWithoutMentorReviewsInput, profileUncheckedCreateWithoutMentorReviewsInput>
    connectOrCreate?: profileCreateOrConnectWithoutMentorReviewsInput
    connect?: profileWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type mentorsUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<mentorsCreateWithoutReviewsInput, mentorsUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: mentorsCreateOrConnectWithoutReviewsInput
    upsert?: mentorsUpsertWithoutReviewsInput
    connect?: mentorsWhereUniqueInput
    update?: XOR<XOR<mentorsUpdateToOneWithWhereWithoutReviewsInput, mentorsUpdateWithoutReviewsInput>, mentorsUncheckedUpdateWithoutReviewsInput>
  }

  export type profileUpdateOneRequiredWithoutMentorReviewsNestedInput = {
    create?: XOR<profileCreateWithoutMentorReviewsInput, profileUncheckedCreateWithoutMentorReviewsInput>
    connectOrCreate?: profileCreateOrConnectWithoutMentorReviewsInput
    upsert?: profileUpsertWithoutMentorReviewsInput
    connect?: profileWhereUniqueInput
    update?: XOR<XOR<profileUpdateToOneWithWhereWithoutMentorReviewsInput, profileUpdateWithoutMentorReviewsInput>, profileUncheckedUpdateWithoutMentorReviewsInput>
  }

  export type portfolioProjectsCreatetagsInput = {
    set: string[]
  }

  export type profileCreateNestedOneWithoutPortfolioProjectsInput = {
    create?: XOR<profileCreateWithoutPortfolioProjectsInput, profileUncheckedCreateWithoutPortfolioProjectsInput>
    connectOrCreate?: profileCreateOrConnectWithoutPortfolioProjectsInput
    connect?: profileWhereUniqueInput
  }

  export type portfolioProjectsUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type profileUpdateOneRequiredWithoutPortfolioProjectsNestedInput = {
    create?: XOR<profileCreateWithoutPortfolioProjectsInput, profileUncheckedCreateWithoutPortfolioProjectsInput>
    connectOrCreate?: profileCreateOrConnectWithoutPortfolioProjectsInput
    upsert?: profileUpsertWithoutPortfolioProjectsInput
    connect?: profileWhereUniqueInput
    update?: XOR<XOR<profileUpdateToOneWithWhereWithoutPortfolioProjectsInput, profileUpdateWithoutPortfolioProjectsInput>, profileUncheckedUpdateWithoutPortfolioProjectsInput>
  }

  export type internship_applicationsCreateNestedManyWithoutInternshipInput = {
    create?: XOR<internship_applicationsCreateWithoutInternshipInput, internship_applicationsUncheckedCreateWithoutInternshipInput> | internship_applicationsCreateWithoutInternshipInput[] | internship_applicationsUncheckedCreateWithoutInternshipInput[]
    connectOrCreate?: internship_applicationsCreateOrConnectWithoutInternshipInput | internship_applicationsCreateOrConnectWithoutInternshipInput[]
    createMany?: internship_applicationsCreateManyInternshipInputEnvelope
    connect?: internship_applicationsWhereUniqueInput | internship_applicationsWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutInternships_industryUserInput = {
    create?: XOR<usersCreateWithoutInternships_industryUserInput, usersUncheckedCreateWithoutInternships_industryUserInput>
    connectOrCreate?: usersCreateOrConnectWithoutInternships_industryUserInput
    connect?: usersWhereUniqueInput
  }

  export type internship_applicationsUncheckedCreateNestedManyWithoutInternshipInput = {
    create?: XOR<internship_applicationsCreateWithoutInternshipInput, internship_applicationsUncheckedCreateWithoutInternshipInput> | internship_applicationsCreateWithoutInternshipInput[] | internship_applicationsUncheckedCreateWithoutInternshipInput[]
    connectOrCreate?: internship_applicationsCreateOrConnectWithoutInternshipInput | internship_applicationsCreateOrConnectWithoutInternshipInput[]
    createMany?: internship_applicationsCreateManyInternshipInputEnvelope
    connect?: internship_applicationsWhereUniqueInput | internship_applicationsWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type internship_applicationsUpdateManyWithoutInternshipNestedInput = {
    create?: XOR<internship_applicationsCreateWithoutInternshipInput, internship_applicationsUncheckedCreateWithoutInternshipInput> | internship_applicationsCreateWithoutInternshipInput[] | internship_applicationsUncheckedCreateWithoutInternshipInput[]
    connectOrCreate?: internship_applicationsCreateOrConnectWithoutInternshipInput | internship_applicationsCreateOrConnectWithoutInternshipInput[]
    upsert?: internship_applicationsUpsertWithWhereUniqueWithoutInternshipInput | internship_applicationsUpsertWithWhereUniqueWithoutInternshipInput[]
    createMany?: internship_applicationsCreateManyInternshipInputEnvelope
    set?: internship_applicationsWhereUniqueInput | internship_applicationsWhereUniqueInput[]
    disconnect?: internship_applicationsWhereUniqueInput | internship_applicationsWhereUniqueInput[]
    delete?: internship_applicationsWhereUniqueInput | internship_applicationsWhereUniqueInput[]
    connect?: internship_applicationsWhereUniqueInput | internship_applicationsWhereUniqueInput[]
    update?: internship_applicationsUpdateWithWhereUniqueWithoutInternshipInput | internship_applicationsUpdateWithWhereUniqueWithoutInternshipInput[]
    updateMany?: internship_applicationsUpdateManyWithWhereWithoutInternshipInput | internship_applicationsUpdateManyWithWhereWithoutInternshipInput[]
    deleteMany?: internship_applicationsScalarWhereInput | internship_applicationsScalarWhereInput[]
  }

  export type usersUpdateOneRequiredWithoutInternships_industryUserNestedInput = {
    create?: XOR<usersCreateWithoutInternships_industryUserInput, usersUncheckedCreateWithoutInternships_industryUserInput>
    connectOrCreate?: usersCreateOrConnectWithoutInternships_industryUserInput
    upsert?: usersUpsertWithoutInternships_industryUserInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutInternships_industryUserInput, usersUpdateWithoutInternships_industryUserInput>, usersUncheckedUpdateWithoutInternships_industryUserInput>
  }

  export type internship_applicationsUncheckedUpdateManyWithoutInternshipNestedInput = {
    create?: XOR<internship_applicationsCreateWithoutInternshipInput, internship_applicationsUncheckedCreateWithoutInternshipInput> | internship_applicationsCreateWithoutInternshipInput[] | internship_applicationsUncheckedCreateWithoutInternshipInput[]
    connectOrCreate?: internship_applicationsCreateOrConnectWithoutInternshipInput | internship_applicationsCreateOrConnectWithoutInternshipInput[]
    upsert?: internship_applicationsUpsertWithWhereUniqueWithoutInternshipInput | internship_applicationsUpsertWithWhereUniqueWithoutInternshipInput[]
    createMany?: internship_applicationsCreateManyInternshipInputEnvelope
    set?: internship_applicationsWhereUniqueInput | internship_applicationsWhereUniqueInput[]
    disconnect?: internship_applicationsWhereUniqueInput | internship_applicationsWhereUniqueInput[]
    delete?: internship_applicationsWhereUniqueInput | internship_applicationsWhereUniqueInput[]
    connect?: internship_applicationsWhereUniqueInput | internship_applicationsWhereUniqueInput[]
    update?: internship_applicationsUpdateWithWhereUniqueWithoutInternshipInput | internship_applicationsUpdateWithWhereUniqueWithoutInternshipInput[]
    updateMany?: internship_applicationsUpdateManyWithWhereWithoutInternshipInput | internship_applicationsUpdateManyWithWhereWithoutInternshipInput[]
    deleteMany?: internship_applicationsScalarWhereInput | internship_applicationsScalarWhereInput[]
  }

  export type internshipsCreateNestedOneWithoutApplicationsInput = {
    create?: XOR<internshipsCreateWithoutApplicationsInput, internshipsUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: internshipsCreateOrConnectWithoutApplicationsInput
    connect?: internshipsWhereUniqueInput
  }

  export type profileCreateNestedOneWithoutInternshipApplicationsInput = {
    create?: XOR<profileCreateWithoutInternshipApplicationsInput, profileUncheckedCreateWithoutInternshipApplicationsInput>
    connectOrCreate?: profileCreateOrConnectWithoutInternshipApplicationsInput
    connect?: profileWhereUniqueInput
  }

  export type internship_evaluationCreateNestedManyWithoutApplicationInput = {
    create?: XOR<internship_evaluationCreateWithoutApplicationInput, internship_evaluationUncheckedCreateWithoutApplicationInput> | internship_evaluationCreateWithoutApplicationInput[] | internship_evaluationUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: internship_evaluationCreateOrConnectWithoutApplicationInput | internship_evaluationCreateOrConnectWithoutApplicationInput[]
    createMany?: internship_evaluationCreateManyApplicationInputEnvelope
    connect?: internship_evaluationWhereUniqueInput | internship_evaluationWhereUniqueInput[]
  }

  export type logbook_entriesCreateNestedManyWithoutApplicationInput = {
    create?: XOR<logbook_entriesCreateWithoutApplicationInput, logbook_entriesUncheckedCreateWithoutApplicationInput> | logbook_entriesCreateWithoutApplicationInput[] | logbook_entriesUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: logbook_entriesCreateOrConnectWithoutApplicationInput | logbook_entriesCreateOrConnectWithoutApplicationInput[]
    createMany?: logbook_entriesCreateManyApplicationInputEnvelope
    connect?: logbook_entriesWhereUniqueInput | logbook_entriesWhereUniqueInput[]
  }

  export type internship_evaluationUncheckedCreateNestedManyWithoutApplicationInput = {
    create?: XOR<internship_evaluationCreateWithoutApplicationInput, internship_evaluationUncheckedCreateWithoutApplicationInput> | internship_evaluationCreateWithoutApplicationInput[] | internship_evaluationUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: internship_evaluationCreateOrConnectWithoutApplicationInput | internship_evaluationCreateOrConnectWithoutApplicationInput[]
    createMany?: internship_evaluationCreateManyApplicationInputEnvelope
    connect?: internship_evaluationWhereUniqueInput | internship_evaluationWhereUniqueInput[]
  }

  export type logbook_entriesUncheckedCreateNestedManyWithoutApplicationInput = {
    create?: XOR<logbook_entriesCreateWithoutApplicationInput, logbook_entriesUncheckedCreateWithoutApplicationInput> | logbook_entriesCreateWithoutApplicationInput[] | logbook_entriesUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: logbook_entriesCreateOrConnectWithoutApplicationInput | logbook_entriesCreateOrConnectWithoutApplicationInput[]
    createMany?: logbook_entriesCreateManyApplicationInputEnvelope
    connect?: logbook_entriesWhereUniqueInput | logbook_entriesWhereUniqueInput[]
  }

  export type EnumInternshipStatusFieldUpdateOperationsInput = {
    set?: $Enums.InternshipStatus
  }

  export type internshipsUpdateOneRequiredWithoutApplicationsNestedInput = {
    create?: XOR<internshipsCreateWithoutApplicationsInput, internshipsUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: internshipsCreateOrConnectWithoutApplicationsInput
    upsert?: internshipsUpsertWithoutApplicationsInput
    connect?: internshipsWhereUniqueInput
    update?: XOR<XOR<internshipsUpdateToOneWithWhereWithoutApplicationsInput, internshipsUpdateWithoutApplicationsInput>, internshipsUncheckedUpdateWithoutApplicationsInput>
  }

  export type profileUpdateOneRequiredWithoutInternshipApplicationsNestedInput = {
    create?: XOR<profileCreateWithoutInternshipApplicationsInput, profileUncheckedCreateWithoutInternshipApplicationsInput>
    connectOrCreate?: profileCreateOrConnectWithoutInternshipApplicationsInput
    upsert?: profileUpsertWithoutInternshipApplicationsInput
    connect?: profileWhereUniqueInput
    update?: XOR<XOR<profileUpdateToOneWithWhereWithoutInternshipApplicationsInput, profileUpdateWithoutInternshipApplicationsInput>, profileUncheckedUpdateWithoutInternshipApplicationsInput>
  }

  export type internship_evaluationUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<internship_evaluationCreateWithoutApplicationInput, internship_evaluationUncheckedCreateWithoutApplicationInput> | internship_evaluationCreateWithoutApplicationInput[] | internship_evaluationUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: internship_evaluationCreateOrConnectWithoutApplicationInput | internship_evaluationCreateOrConnectWithoutApplicationInput[]
    upsert?: internship_evaluationUpsertWithWhereUniqueWithoutApplicationInput | internship_evaluationUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: internship_evaluationCreateManyApplicationInputEnvelope
    set?: internship_evaluationWhereUniqueInput | internship_evaluationWhereUniqueInput[]
    disconnect?: internship_evaluationWhereUniqueInput | internship_evaluationWhereUniqueInput[]
    delete?: internship_evaluationWhereUniqueInput | internship_evaluationWhereUniqueInput[]
    connect?: internship_evaluationWhereUniqueInput | internship_evaluationWhereUniqueInput[]
    update?: internship_evaluationUpdateWithWhereUniqueWithoutApplicationInput | internship_evaluationUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: internship_evaluationUpdateManyWithWhereWithoutApplicationInput | internship_evaluationUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: internship_evaluationScalarWhereInput | internship_evaluationScalarWhereInput[]
  }

  export type logbook_entriesUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<logbook_entriesCreateWithoutApplicationInput, logbook_entriesUncheckedCreateWithoutApplicationInput> | logbook_entriesCreateWithoutApplicationInput[] | logbook_entriesUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: logbook_entriesCreateOrConnectWithoutApplicationInput | logbook_entriesCreateOrConnectWithoutApplicationInput[]
    upsert?: logbook_entriesUpsertWithWhereUniqueWithoutApplicationInput | logbook_entriesUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: logbook_entriesCreateManyApplicationInputEnvelope
    set?: logbook_entriesWhereUniqueInput | logbook_entriesWhereUniqueInput[]
    disconnect?: logbook_entriesWhereUniqueInput | logbook_entriesWhereUniqueInput[]
    delete?: logbook_entriesWhereUniqueInput | logbook_entriesWhereUniqueInput[]
    connect?: logbook_entriesWhereUniqueInput | logbook_entriesWhereUniqueInput[]
    update?: logbook_entriesUpdateWithWhereUniqueWithoutApplicationInput | logbook_entriesUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: logbook_entriesUpdateManyWithWhereWithoutApplicationInput | logbook_entriesUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: logbook_entriesScalarWhereInput | logbook_entriesScalarWhereInput[]
  }

  export type internship_evaluationUncheckedUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<internship_evaluationCreateWithoutApplicationInput, internship_evaluationUncheckedCreateWithoutApplicationInput> | internship_evaluationCreateWithoutApplicationInput[] | internship_evaluationUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: internship_evaluationCreateOrConnectWithoutApplicationInput | internship_evaluationCreateOrConnectWithoutApplicationInput[]
    upsert?: internship_evaluationUpsertWithWhereUniqueWithoutApplicationInput | internship_evaluationUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: internship_evaluationCreateManyApplicationInputEnvelope
    set?: internship_evaluationWhereUniqueInput | internship_evaluationWhereUniqueInput[]
    disconnect?: internship_evaluationWhereUniqueInput | internship_evaluationWhereUniqueInput[]
    delete?: internship_evaluationWhereUniqueInput | internship_evaluationWhereUniqueInput[]
    connect?: internship_evaluationWhereUniqueInput | internship_evaluationWhereUniqueInput[]
    update?: internship_evaluationUpdateWithWhereUniqueWithoutApplicationInput | internship_evaluationUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: internship_evaluationUpdateManyWithWhereWithoutApplicationInput | internship_evaluationUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: internship_evaluationScalarWhereInput | internship_evaluationScalarWhereInput[]
  }

  export type logbook_entriesUncheckedUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<logbook_entriesCreateWithoutApplicationInput, logbook_entriesUncheckedCreateWithoutApplicationInput> | logbook_entriesCreateWithoutApplicationInput[] | logbook_entriesUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: logbook_entriesCreateOrConnectWithoutApplicationInput | logbook_entriesCreateOrConnectWithoutApplicationInput[]
    upsert?: logbook_entriesUpsertWithWhereUniqueWithoutApplicationInput | logbook_entriesUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: logbook_entriesCreateManyApplicationInputEnvelope
    set?: logbook_entriesWhereUniqueInput | logbook_entriesWhereUniqueInput[]
    disconnect?: logbook_entriesWhereUniqueInput | logbook_entriesWhereUniqueInput[]
    delete?: logbook_entriesWhereUniqueInput | logbook_entriesWhereUniqueInput[]
    connect?: logbook_entriesWhereUniqueInput | logbook_entriesWhereUniqueInput[]
    update?: logbook_entriesUpdateWithWhereUniqueWithoutApplicationInput | logbook_entriesUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: logbook_entriesUpdateManyWithWhereWithoutApplicationInput | logbook_entriesUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: logbook_entriesScalarWhereInput | logbook_entriesScalarWhereInput[]
  }

  export type internship_applicationsCreateNestedOneWithoutLogbookEntriesInput = {
    create?: XOR<internship_applicationsCreateWithoutLogbookEntriesInput, internship_applicationsUncheckedCreateWithoutLogbookEntriesInput>
    connectOrCreate?: internship_applicationsCreateOrConnectWithoutLogbookEntriesInput
    connect?: internship_applicationsWhereUniqueInput
  }

  export type internship_applicationsUpdateOneRequiredWithoutLogbookEntriesNestedInput = {
    create?: XOR<internship_applicationsCreateWithoutLogbookEntriesInput, internship_applicationsUncheckedCreateWithoutLogbookEntriesInput>
    connectOrCreate?: internship_applicationsCreateOrConnectWithoutLogbookEntriesInput
    upsert?: internship_applicationsUpsertWithoutLogbookEntriesInput
    connect?: internship_applicationsWhereUniqueInput
    update?: XOR<XOR<internship_applicationsUpdateToOneWithWhereWithoutLogbookEntriesInput, internship_applicationsUpdateWithoutLogbookEntriesInput>, internship_applicationsUncheckedUpdateWithoutLogbookEntriesInput>
  }

  export type internship_applicationsCreateNestedOneWithoutEvaluationsInput = {
    create?: XOR<internship_applicationsCreateWithoutEvaluationsInput, internship_applicationsUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: internship_applicationsCreateOrConnectWithoutEvaluationsInput
    connect?: internship_applicationsWhereUniqueInput
  }

  export type facultyCreateNestedOneWithoutEvaluationsInput = {
    create?: XOR<facultyCreateWithoutEvaluationsInput, facultyUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: facultyCreateOrConnectWithoutEvaluationsInput
    connect?: facultyWhereUniqueInput
  }

  export type internship_applicationsUpdateOneRequiredWithoutEvaluationsNestedInput = {
    create?: XOR<internship_applicationsCreateWithoutEvaluationsInput, internship_applicationsUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: internship_applicationsCreateOrConnectWithoutEvaluationsInput
    upsert?: internship_applicationsUpsertWithoutEvaluationsInput
    connect?: internship_applicationsWhereUniqueInput
    update?: XOR<XOR<internship_applicationsUpdateToOneWithWhereWithoutEvaluationsInput, internship_applicationsUpdateWithoutEvaluationsInput>, internship_applicationsUncheckedUpdateWithoutEvaluationsInput>
  }

  export type facultyUpdateOneRequiredWithoutEvaluationsNestedInput = {
    create?: XOR<facultyCreateWithoutEvaluationsInput, facultyUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: facultyCreateOrConnectWithoutEvaluationsInput
    upsert?: facultyUpsertWithoutEvaluationsInput
    connect?: facultyWhereUniqueInput
    update?: XOR<XOR<facultyUpdateToOneWithWhereWithoutEvaluationsInput, facultyUpdateWithoutEvaluationsInput>, facultyUncheckedUpdateWithoutEvaluationsInput>
  }

  export type institutionsCreateNestedOneWithoutFacultyInput = {
    create?: XOR<institutionsCreateWithoutFacultyInput, institutionsUncheckedCreateWithoutFacultyInput>
    connectOrCreate?: institutionsCreateOrConnectWithoutFacultyInput
    connect?: institutionsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutFacultyProfileInput = {
    create?: XOR<usersCreateWithoutFacultyProfileInput, usersUncheckedCreateWithoutFacultyProfileInput>
    connectOrCreate?: usersCreateOrConnectWithoutFacultyProfileInput
    connect?: usersWhereUniqueInput
  }

  export type internship_evaluationCreateNestedManyWithoutFacultyInput = {
    create?: XOR<internship_evaluationCreateWithoutFacultyInput, internship_evaluationUncheckedCreateWithoutFacultyInput> | internship_evaluationCreateWithoutFacultyInput[] | internship_evaluationUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: internship_evaluationCreateOrConnectWithoutFacultyInput | internship_evaluationCreateOrConnectWithoutFacultyInput[]
    createMany?: internship_evaluationCreateManyFacultyInputEnvelope
    connect?: internship_evaluationWhereUniqueInput | internship_evaluationWhereUniqueInput[]
  }

  export type profileCreateNestedManyWithoutFacultyInput = {
    create?: XOR<profileCreateWithoutFacultyInput, profileUncheckedCreateWithoutFacultyInput> | profileCreateWithoutFacultyInput[] | profileUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: profileCreateOrConnectWithoutFacultyInput | profileCreateOrConnectWithoutFacultyInput[]
    createMany?: profileCreateManyFacultyInputEnvelope
    connect?: profileWhereUniqueInput | profileWhereUniqueInput[]
  }

  export type internship_evaluationUncheckedCreateNestedManyWithoutFacultyInput = {
    create?: XOR<internship_evaluationCreateWithoutFacultyInput, internship_evaluationUncheckedCreateWithoutFacultyInput> | internship_evaluationCreateWithoutFacultyInput[] | internship_evaluationUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: internship_evaluationCreateOrConnectWithoutFacultyInput | internship_evaluationCreateOrConnectWithoutFacultyInput[]
    createMany?: internship_evaluationCreateManyFacultyInputEnvelope
    connect?: internship_evaluationWhereUniqueInput | internship_evaluationWhereUniqueInput[]
  }

  export type profileUncheckedCreateNestedManyWithoutFacultyInput = {
    create?: XOR<profileCreateWithoutFacultyInput, profileUncheckedCreateWithoutFacultyInput> | profileCreateWithoutFacultyInput[] | profileUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: profileCreateOrConnectWithoutFacultyInput | profileCreateOrConnectWithoutFacultyInput[]
    createMany?: profileCreateManyFacultyInputEnvelope
    connect?: profileWhereUniqueInput | profileWhereUniqueInput[]
  }

  export type institutionsUpdateOneRequiredWithoutFacultyNestedInput = {
    create?: XOR<institutionsCreateWithoutFacultyInput, institutionsUncheckedCreateWithoutFacultyInput>
    connectOrCreate?: institutionsCreateOrConnectWithoutFacultyInput
    upsert?: institutionsUpsertWithoutFacultyInput
    connect?: institutionsWhereUniqueInput
    update?: XOR<XOR<institutionsUpdateToOneWithWhereWithoutFacultyInput, institutionsUpdateWithoutFacultyInput>, institutionsUncheckedUpdateWithoutFacultyInput>
  }

  export type usersUpdateOneRequiredWithoutFacultyProfileNestedInput = {
    create?: XOR<usersCreateWithoutFacultyProfileInput, usersUncheckedCreateWithoutFacultyProfileInput>
    connectOrCreate?: usersCreateOrConnectWithoutFacultyProfileInput
    upsert?: usersUpsertWithoutFacultyProfileInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutFacultyProfileInput, usersUpdateWithoutFacultyProfileInput>, usersUncheckedUpdateWithoutFacultyProfileInput>
  }

  export type internship_evaluationUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<internship_evaluationCreateWithoutFacultyInput, internship_evaluationUncheckedCreateWithoutFacultyInput> | internship_evaluationCreateWithoutFacultyInput[] | internship_evaluationUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: internship_evaluationCreateOrConnectWithoutFacultyInput | internship_evaluationCreateOrConnectWithoutFacultyInput[]
    upsert?: internship_evaluationUpsertWithWhereUniqueWithoutFacultyInput | internship_evaluationUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: internship_evaluationCreateManyFacultyInputEnvelope
    set?: internship_evaluationWhereUniqueInput | internship_evaluationWhereUniqueInput[]
    disconnect?: internship_evaluationWhereUniqueInput | internship_evaluationWhereUniqueInput[]
    delete?: internship_evaluationWhereUniqueInput | internship_evaluationWhereUniqueInput[]
    connect?: internship_evaluationWhereUniqueInput | internship_evaluationWhereUniqueInput[]
    update?: internship_evaluationUpdateWithWhereUniqueWithoutFacultyInput | internship_evaluationUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: internship_evaluationUpdateManyWithWhereWithoutFacultyInput | internship_evaluationUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: internship_evaluationScalarWhereInput | internship_evaluationScalarWhereInput[]
  }

  export type profileUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<profileCreateWithoutFacultyInput, profileUncheckedCreateWithoutFacultyInput> | profileCreateWithoutFacultyInput[] | profileUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: profileCreateOrConnectWithoutFacultyInput | profileCreateOrConnectWithoutFacultyInput[]
    upsert?: profileUpsertWithWhereUniqueWithoutFacultyInput | profileUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: profileCreateManyFacultyInputEnvelope
    set?: profileWhereUniqueInput | profileWhereUniqueInput[]
    disconnect?: profileWhereUniqueInput | profileWhereUniqueInput[]
    delete?: profileWhereUniqueInput | profileWhereUniqueInput[]
    connect?: profileWhereUniqueInput | profileWhereUniqueInput[]
    update?: profileUpdateWithWhereUniqueWithoutFacultyInput | profileUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: profileUpdateManyWithWhereWithoutFacultyInput | profileUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: profileScalarWhereInput | profileScalarWhereInput[]
  }

  export type internship_evaluationUncheckedUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<internship_evaluationCreateWithoutFacultyInput, internship_evaluationUncheckedCreateWithoutFacultyInput> | internship_evaluationCreateWithoutFacultyInput[] | internship_evaluationUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: internship_evaluationCreateOrConnectWithoutFacultyInput | internship_evaluationCreateOrConnectWithoutFacultyInput[]
    upsert?: internship_evaluationUpsertWithWhereUniqueWithoutFacultyInput | internship_evaluationUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: internship_evaluationCreateManyFacultyInputEnvelope
    set?: internship_evaluationWhereUniqueInput | internship_evaluationWhereUniqueInput[]
    disconnect?: internship_evaluationWhereUniqueInput | internship_evaluationWhereUniqueInput[]
    delete?: internship_evaluationWhereUniqueInput | internship_evaluationWhereUniqueInput[]
    connect?: internship_evaluationWhereUniqueInput | internship_evaluationWhereUniqueInput[]
    update?: internship_evaluationUpdateWithWhereUniqueWithoutFacultyInput | internship_evaluationUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: internship_evaluationUpdateManyWithWhereWithoutFacultyInput | internship_evaluationUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: internship_evaluationScalarWhereInput | internship_evaluationScalarWhereInput[]
  }

  export type profileUncheckedUpdateManyWithoutFacultyNestedInput = {
    create?: XOR<profileCreateWithoutFacultyInput, profileUncheckedCreateWithoutFacultyInput> | profileCreateWithoutFacultyInput[] | profileUncheckedCreateWithoutFacultyInput[]
    connectOrCreate?: profileCreateOrConnectWithoutFacultyInput | profileCreateOrConnectWithoutFacultyInput[]
    upsert?: profileUpsertWithWhereUniqueWithoutFacultyInput | profileUpsertWithWhereUniqueWithoutFacultyInput[]
    createMany?: profileCreateManyFacultyInputEnvelope
    set?: profileWhereUniqueInput | profileWhereUniqueInput[]
    disconnect?: profileWhereUniqueInput | profileWhereUniqueInput[]
    delete?: profileWhereUniqueInput | profileWhereUniqueInput[]
    connect?: profileWhereUniqueInput | profileWhereUniqueInput[]
    update?: profileUpdateWithWhereUniqueWithoutFacultyInput | profileUpdateWithWhereUniqueWithoutFacultyInput[]
    updateMany?: profileUpdateManyWithWhereWithoutFacultyInput | profileUpdateManyWithWhereWithoutFacultyInput[]
    deleteMany?: profileScalarWhereInput | profileScalarWhereInput[]
  }

  export type profileCreateNestedOneWithoutCreditsInput = {
    create?: XOR<profileCreateWithoutCreditsInput, profileUncheckedCreateWithoutCreditsInput>
    connectOrCreate?: profileCreateOrConnectWithoutCreditsInput
    connect?: profileWhereUniqueInput
  }

  export type profileUpdateOneRequiredWithoutCreditsNestedInput = {
    create?: XOR<profileCreateWithoutCreditsInput, profileUncheckedCreateWithoutCreditsInput>
    connectOrCreate?: profileCreateOrConnectWithoutCreditsInput
    upsert?: profileUpsertWithoutCreditsInput
    connect?: profileWhereUniqueInput
    update?: XOR<XOR<profileUpdateToOneWithWhereWithoutCreditsInput, profileUpdateWithoutCreditsInput>, profileUncheckedUpdateWithoutCreditsInput>
  }

  export type profileCreateNestedOneWithoutCertificatesInput = {
    create?: XOR<profileCreateWithoutCertificatesInput, profileUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: profileCreateOrConnectWithoutCertificatesInput
    connect?: profileWhereUniqueInput
  }

  export type profileUpdateOneRequiredWithoutCertificatesNestedInput = {
    create?: XOR<profileCreateWithoutCertificatesInput, profileUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: profileCreateOrConnectWithoutCertificatesInput
    upsert?: profileUpsertWithoutCertificatesInput
    connect?: profileWhereUniqueInput
    update?: XOR<XOR<profileUpdateToOneWithWhereWithoutCertificatesInput, profileUpdateWithoutCertificatesInput>, profileUncheckedUpdateWithoutCertificatesInput>
  }

  export type user_notificationsCreateNestedManyWithoutNotificationInput = {
    create?: XOR<user_notificationsCreateWithoutNotificationInput, user_notificationsUncheckedCreateWithoutNotificationInput> | user_notificationsCreateWithoutNotificationInput[] | user_notificationsUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: user_notificationsCreateOrConnectWithoutNotificationInput | user_notificationsCreateOrConnectWithoutNotificationInput[]
    createMany?: user_notificationsCreateManyNotificationInputEnvelope
    connect?: user_notificationsWhereUniqueInput | user_notificationsWhereUniqueInput[]
  }

  export type user_notificationsUncheckedCreateNestedManyWithoutNotificationInput = {
    create?: XOR<user_notificationsCreateWithoutNotificationInput, user_notificationsUncheckedCreateWithoutNotificationInput> | user_notificationsCreateWithoutNotificationInput[] | user_notificationsUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: user_notificationsCreateOrConnectWithoutNotificationInput | user_notificationsCreateOrConnectWithoutNotificationInput[]
    createMany?: user_notificationsCreateManyNotificationInputEnvelope
    connect?: user_notificationsWhereUniqueInput | user_notificationsWhereUniqueInput[]
  }

  export type user_notificationsUpdateManyWithoutNotificationNestedInput = {
    create?: XOR<user_notificationsCreateWithoutNotificationInput, user_notificationsUncheckedCreateWithoutNotificationInput> | user_notificationsCreateWithoutNotificationInput[] | user_notificationsUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: user_notificationsCreateOrConnectWithoutNotificationInput | user_notificationsCreateOrConnectWithoutNotificationInput[]
    upsert?: user_notificationsUpsertWithWhereUniqueWithoutNotificationInput | user_notificationsUpsertWithWhereUniqueWithoutNotificationInput[]
    createMany?: user_notificationsCreateManyNotificationInputEnvelope
    set?: user_notificationsWhereUniqueInput | user_notificationsWhereUniqueInput[]
    disconnect?: user_notificationsWhereUniqueInput | user_notificationsWhereUniqueInput[]
    delete?: user_notificationsWhereUniqueInput | user_notificationsWhereUniqueInput[]
    connect?: user_notificationsWhereUniqueInput | user_notificationsWhereUniqueInput[]
    update?: user_notificationsUpdateWithWhereUniqueWithoutNotificationInput | user_notificationsUpdateWithWhereUniqueWithoutNotificationInput[]
    updateMany?: user_notificationsUpdateManyWithWhereWithoutNotificationInput | user_notificationsUpdateManyWithWhereWithoutNotificationInput[]
    deleteMany?: user_notificationsScalarWhereInput | user_notificationsScalarWhereInput[]
  }

  export type user_notificationsUncheckedUpdateManyWithoutNotificationNestedInput = {
    create?: XOR<user_notificationsCreateWithoutNotificationInput, user_notificationsUncheckedCreateWithoutNotificationInput> | user_notificationsCreateWithoutNotificationInput[] | user_notificationsUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: user_notificationsCreateOrConnectWithoutNotificationInput | user_notificationsCreateOrConnectWithoutNotificationInput[]
    upsert?: user_notificationsUpsertWithWhereUniqueWithoutNotificationInput | user_notificationsUpsertWithWhereUniqueWithoutNotificationInput[]
    createMany?: user_notificationsCreateManyNotificationInputEnvelope
    set?: user_notificationsWhereUniqueInput | user_notificationsWhereUniqueInput[]
    disconnect?: user_notificationsWhereUniqueInput | user_notificationsWhereUniqueInput[]
    delete?: user_notificationsWhereUniqueInput | user_notificationsWhereUniqueInput[]
    connect?: user_notificationsWhereUniqueInput | user_notificationsWhereUniqueInput[]
    update?: user_notificationsUpdateWithWhereUniqueWithoutNotificationInput | user_notificationsUpdateWithWhereUniqueWithoutNotificationInput[]
    updateMany?: user_notificationsUpdateManyWithWhereWithoutNotificationInput | user_notificationsUpdateManyWithWhereWithoutNotificationInput[]
    deleteMany?: user_notificationsScalarWhereInput | user_notificationsScalarWhereInput[]
  }

  export type notificationsCreateNestedOneWithoutUserNotificationsInput = {
    create?: XOR<notificationsCreateWithoutUserNotificationsInput, notificationsUncheckedCreateWithoutUserNotificationsInput>
    connectOrCreate?: notificationsCreateOrConnectWithoutUserNotificationsInput
    connect?: notificationsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutUser_notificationsInput = {
    create?: XOR<usersCreateWithoutUser_notificationsInput, usersUncheckedCreateWithoutUser_notificationsInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_notificationsInput
    connect?: usersWhereUniqueInput
  }

  export type notificationsUpdateOneRequiredWithoutUserNotificationsNestedInput = {
    create?: XOR<notificationsCreateWithoutUserNotificationsInput, notificationsUncheckedCreateWithoutUserNotificationsInput>
    connectOrCreate?: notificationsCreateOrConnectWithoutUserNotificationsInput
    upsert?: notificationsUpsertWithoutUserNotificationsInput
    connect?: notificationsWhereUniqueInput
    update?: XOR<XOR<notificationsUpdateToOneWithWhereWithoutUserNotificationsInput, notificationsUpdateWithoutUserNotificationsInput>, notificationsUncheckedUpdateWithoutUserNotificationsInput>
  }

  export type usersUpdateOneRequiredWithoutUser_notificationsNestedInput = {
    create?: XOR<usersCreateWithoutUser_notificationsInput, usersUncheckedCreateWithoutUser_notificationsInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_notificationsInput
    upsert?: usersUpsertWithoutUser_notificationsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutUser_notificationsInput, usersUpdateWithoutUser_notificationsInput>, usersUncheckedUpdateWithoutUser_notificationsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumCourseTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseType | EnumCourseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CourseType[] | ListEnumCourseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseType[] | ListEnumCourseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseTypeFilter<$PrismaModel> | $Enums.CourseType
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumCourseTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CourseType | EnumCourseTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CourseType[] | ListEnumCourseTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourseType[] | ListEnumCourseTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCourseTypeWithAggregatesFilter<$PrismaModel> | $Enums.CourseType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCourseTypeFilter<$PrismaModel>
    _max?: NestedEnumCourseTypeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumMentorSessionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MentorSessionStatus | EnumMentorSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MentorSessionStatus[] | ListEnumMentorSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MentorSessionStatus[] | ListEnumMentorSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMentorSessionStatusFilter<$PrismaModel> | $Enums.MentorSessionStatus
  }

  export type NestedEnumMentorSessionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MentorSessionStatus | EnumMentorSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MentorSessionStatus[] | ListEnumMentorSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MentorSessionStatus[] | ListEnumMentorSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMentorSessionStatusWithAggregatesFilter<$PrismaModel> | $Enums.MentorSessionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMentorSessionStatusFilter<$PrismaModel>
    _max?: NestedEnumMentorSessionStatusFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumInternshipStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InternshipStatus | EnumInternshipStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InternshipStatus[] | ListEnumInternshipStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InternshipStatus[] | ListEnumInternshipStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInternshipStatusFilter<$PrismaModel> | $Enums.InternshipStatus
  }

  export type NestedEnumInternshipStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InternshipStatus | EnumInternshipStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InternshipStatus[] | ListEnumInternshipStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InternshipStatus[] | ListEnumInternshipStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInternshipStatusWithAggregatesFilter<$PrismaModel> | $Enums.InternshipStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInternshipStatusFilter<$PrismaModel>
    _max?: NestedEnumInternshipStatusFilter<$PrismaModel>
  }

  export type courseEnrollmentsCreateWithoutUserInput = {
    id?: string
    progressPercent?: number | null
    enrolledAt: Date | string
    course: coursesCreateNestedOneWithoutEnrollmentsInput
  }

  export type courseEnrollmentsUncheckedCreateWithoutUserInput = {
    id?: string
    courseId: string
    progressPercent?: number | null
    enrolledAt: Date | string
  }

  export type courseEnrollmentsCreateOrConnectWithoutUserInput = {
    where: courseEnrollmentsWhereUniqueInput
    create: XOR<courseEnrollmentsCreateWithoutUserInput, courseEnrollmentsUncheckedCreateWithoutUserInput>
  }

  export type courseEnrollmentsCreateManyUserInputEnvelope = {
    data: courseEnrollmentsCreateManyUserInput | courseEnrollmentsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type coursesCreateWithoutInstructorInput = {
    id?: string
    title: string
    description: string
    type: $Enums.CourseType
    price?: number | null
    thumbnail_url?: string | null
    created_at: Date | string
    enrollments?: courseEnrollmentsCreateNestedManyWithoutCourseInput
  }

  export type coursesUncheckedCreateWithoutInstructorInput = {
    id?: string
    title: string
    description: string
    type: $Enums.CourseType
    price?: number | null
    thumbnail_url?: string | null
    created_at: Date | string
    enrollments?: courseEnrollmentsUncheckedCreateNestedManyWithoutCourseInput
  }

  export type coursesCreateOrConnectWithoutInstructorInput = {
    where: coursesWhereUniqueInput
    create: XOR<coursesCreateWithoutInstructorInput, coursesUncheckedCreateWithoutInstructorInput>
  }

  export type coursesCreateManyInstructorInputEnvelope = {
    data: coursesCreateManyInstructorInput | coursesCreateManyInstructorInput[]
    skipDuplicates?: boolean
  }

  export type facultyCreateWithoutUserInput = {
    id?: string
    name: string
    department: string
    institution: institutionsCreateNestedOneWithoutFacultyInput
    evaluations?: internship_evaluationCreateNestedManyWithoutFacultyInput
    students?: profileCreateNestedManyWithoutFacultyInput
  }

  export type facultyUncheckedCreateWithoutUserInput = {
    id?: string
    instituteId: string
    name: string
    department: string
    evaluations?: internship_evaluationUncheckedCreateNestedManyWithoutFacultyInput
    students?: profileUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type facultyCreateOrConnectWithoutUserInput = {
    where: facultyWhereUniqueInput
    create: XOR<facultyCreateWithoutUserInput, facultyUncheckedCreateWithoutUserInput>
  }

  export type institutionsCreateWithoutAdminUserInput = {
    id?: string
    instituteName: string
    state: string
    createdAt: Date | string
    faculty?: facultyCreateNestedManyWithoutInstitutionInput
    profiles?: profileCreateNestedManyWithoutInstitutionInput
  }

  export type institutionsUncheckedCreateWithoutAdminUserInput = {
    id?: string
    instituteName: string
    state: string
    createdAt: Date | string
    faculty?: facultyUncheckedCreateNestedManyWithoutInstitutionInput
    profiles?: profileUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type institutionsCreateOrConnectWithoutAdminUserInput = {
    where: institutionsWhereUniqueInput
    create: XOR<institutionsCreateWithoutAdminUserInput, institutionsUncheckedCreateWithoutAdminUserInput>
  }

  export type institutionsCreateManyAdminUserInputEnvelope = {
    data: institutionsCreateManyAdminUserInput | institutionsCreateManyAdminUserInput[]
    skipDuplicates?: boolean
  }

  export type internshipsCreateWithoutIndustryUserInput = {
    id?: string
    title: string
    description: string
    type: string
    stipend?: number | null
    location: string
    required_skills: JsonNullValueInput | InputJsonValue
    duration_weeks: number
    created_at: Date | string
    applications?: internship_applicationsCreateNestedManyWithoutInternshipInput
  }

  export type internshipsUncheckedCreateWithoutIndustryUserInput = {
    id?: string
    title: string
    description: string
    type: string
    stipend?: number | null
    location: string
    required_skills: JsonNullValueInput | InputJsonValue
    duration_weeks: number
    created_at: Date | string
    applications?: internship_applicationsUncheckedCreateNestedManyWithoutInternshipInput
  }

  export type internshipsCreateOrConnectWithoutIndustryUserInput = {
    where: internshipsWhereUniqueInput
    create: XOR<internshipsCreateWithoutIndustryUserInput, internshipsUncheckedCreateWithoutIndustryUserInput>
  }

  export type internshipsCreateManyIndustryUserInputEnvelope = {
    data: internshipsCreateManyIndustryUserInput | internshipsCreateManyIndustryUserInput[]
    skipDuplicates?: boolean
  }

  export type mentorsCreateWithoutUserInput = {
    id?: string
    expertise?: NullableJsonNullValueInput | InputJsonValue
    rating?: number | null
    bio?: string | null
    reviews?: mentorReviewsCreateNestedManyWithoutMentorInput
    sessions?: mentorSessionsCreateNestedManyWithoutMentorInput
  }

  export type mentorsUncheckedCreateWithoutUserInput = {
    id?: string
    expertise?: NullableJsonNullValueInput | InputJsonValue
    rating?: number | null
    bio?: string | null
    reviews?: mentorReviewsUncheckedCreateNestedManyWithoutMentorInput
    sessions?: mentorSessionsUncheckedCreateNestedManyWithoutMentorInput
  }

  export type mentorsCreateOrConnectWithoutUserInput = {
    where: mentorsWhereUniqueInput
    create: XOR<mentorsCreateWithoutUserInput, mentorsUncheckedCreateWithoutUserInput>
  }

  export type profileCreateWithoutUserInput = {
    id?: string
    bio?: string | null
    gender?: string | null
    DOB?: Date | string | null
    avatarURL?: string | null
    github?: string | null
    linkedin?: string | null
    skills?: profileCreateskillsInput | string[]
    interests?: profileCreateinterestsInput | string[]
    department?: string | null
    resourceId?: string | null
    certificates?: certificatesCreateNestedManyWithoutStudentInput
    credits?: creditsCreateNestedManyWithoutStudentInput
    internshipApplications?: internship_applicationsCreateNestedManyWithoutStudentInput
    mentorReviews?: mentorReviewsCreateNestedManyWithoutStudentInput
    mentorSessions?: mentorSessionsCreateNestedManyWithoutStudentInput
    portfolioProjects?: portfolioProjectsCreateNestedManyWithoutUserInput
    faculty?: facultyCreateNestedOneWithoutStudentsInput
    institution: institutionsCreateNestedOneWithoutProfilesInput
    learningProgress?: studentLearningProgressCreateNestedManyWithoutProfileInput
  }

  export type profileUncheckedCreateWithoutUserInput = {
    id?: string
    bio?: string | null
    gender?: string | null
    DOB?: Date | string | null
    avatarURL?: string | null
    github?: string | null
    linkedin?: string | null
    skills?: profileCreateskillsInput | string[]
    interests?: profileCreateinterestsInput | string[]
    department?: string | null
    resourceId?: string | null
    instituteId: string
    facultyId?: string | null
    certificates?: certificatesUncheckedCreateNestedManyWithoutStudentInput
    credits?: creditsUncheckedCreateNestedManyWithoutStudentInput
    internshipApplications?: internship_applicationsUncheckedCreateNestedManyWithoutStudentInput
    mentorReviews?: mentorReviewsUncheckedCreateNestedManyWithoutStudentInput
    mentorSessions?: mentorSessionsUncheckedCreateNestedManyWithoutStudentInput
    portfolioProjects?: portfolioProjectsUncheckedCreateNestedManyWithoutUserInput
    learningProgress?: studentLearningProgressUncheckedCreateNestedManyWithoutProfileInput
  }

  export type profileCreateOrConnectWithoutUserInput = {
    where: profileWhereUniqueInput
    create: XOR<profileCreateWithoutUserInput, profileUncheckedCreateWithoutUserInput>
  }

  export type user_notificationsCreateWithoutUserInput = {
    id?: string
    isRead: boolean
    read_at?: Date | string | null
    notification: notificationsCreateNestedOneWithoutUserNotificationsInput
  }

  export type user_notificationsUncheckedCreateWithoutUserInput = {
    id?: string
    notification_id: string
    isRead: boolean
    read_at?: Date | string | null
  }

  export type user_notificationsCreateOrConnectWithoutUserInput = {
    where: user_notificationsWhereUniqueInput
    create: XOR<user_notificationsCreateWithoutUserInput, user_notificationsUncheckedCreateWithoutUserInput>
  }

  export type user_notificationsCreateManyUserInputEnvelope = {
    data: user_notificationsCreateManyUserInput | user_notificationsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type courseEnrollmentsUpsertWithWhereUniqueWithoutUserInput = {
    where: courseEnrollmentsWhereUniqueInput
    update: XOR<courseEnrollmentsUpdateWithoutUserInput, courseEnrollmentsUncheckedUpdateWithoutUserInput>
    create: XOR<courseEnrollmentsCreateWithoutUserInput, courseEnrollmentsUncheckedCreateWithoutUserInput>
  }

  export type courseEnrollmentsUpdateWithWhereUniqueWithoutUserInput = {
    where: courseEnrollmentsWhereUniqueInput
    data: XOR<courseEnrollmentsUpdateWithoutUserInput, courseEnrollmentsUncheckedUpdateWithoutUserInput>
  }

  export type courseEnrollmentsUpdateManyWithWhereWithoutUserInput = {
    where: courseEnrollmentsScalarWhereInput
    data: XOR<courseEnrollmentsUpdateManyMutationInput, courseEnrollmentsUncheckedUpdateManyWithoutUserInput>
  }

  export type courseEnrollmentsScalarWhereInput = {
    AND?: courseEnrollmentsScalarWhereInput | courseEnrollmentsScalarWhereInput[]
    OR?: courseEnrollmentsScalarWhereInput[]
    NOT?: courseEnrollmentsScalarWhereInput | courseEnrollmentsScalarWhereInput[]
    id?: StringFilter<"courseEnrollments"> | string
    courseId?: StringFilter<"courseEnrollments"> | string
    userId?: StringFilter<"courseEnrollments"> | string
    progressPercent?: FloatNullableFilter<"courseEnrollments"> | number | null
    enrolledAt?: DateTimeFilter<"courseEnrollments"> | Date | string
  }

  export type coursesUpsertWithWhereUniqueWithoutInstructorInput = {
    where: coursesWhereUniqueInput
    update: XOR<coursesUpdateWithoutInstructorInput, coursesUncheckedUpdateWithoutInstructorInput>
    create: XOR<coursesCreateWithoutInstructorInput, coursesUncheckedCreateWithoutInstructorInput>
  }

  export type coursesUpdateWithWhereUniqueWithoutInstructorInput = {
    where: coursesWhereUniqueInput
    data: XOR<coursesUpdateWithoutInstructorInput, coursesUncheckedUpdateWithoutInstructorInput>
  }

  export type coursesUpdateManyWithWhereWithoutInstructorInput = {
    where: coursesScalarWhereInput
    data: XOR<coursesUpdateManyMutationInput, coursesUncheckedUpdateManyWithoutInstructorInput>
  }

  export type coursesScalarWhereInput = {
    AND?: coursesScalarWhereInput | coursesScalarWhereInput[]
    OR?: coursesScalarWhereInput[]
    NOT?: coursesScalarWhereInput | coursesScalarWhereInput[]
    id?: StringFilter<"courses"> | string
    title?: StringFilter<"courses"> | string
    description?: StringFilter<"courses"> | string
    type?: EnumCourseTypeFilter<"courses"> | $Enums.CourseType
    price?: FloatNullableFilter<"courses"> | number | null
    instructorId?: StringFilter<"courses"> | string
    thumbnail_url?: StringNullableFilter<"courses"> | string | null
    created_at?: DateTimeFilter<"courses"> | Date | string
  }

  export type facultyUpsertWithoutUserInput = {
    update: XOR<facultyUpdateWithoutUserInput, facultyUncheckedUpdateWithoutUserInput>
    create: XOR<facultyCreateWithoutUserInput, facultyUncheckedCreateWithoutUserInput>
    where?: facultyWhereInput
  }

  export type facultyUpdateToOneWithWhereWithoutUserInput = {
    where?: facultyWhereInput
    data: XOR<facultyUpdateWithoutUserInput, facultyUncheckedUpdateWithoutUserInput>
  }

  export type facultyUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    institution?: institutionsUpdateOneRequiredWithoutFacultyNestedInput
    evaluations?: internship_evaluationUpdateManyWithoutFacultyNestedInput
    students?: profileUpdateManyWithoutFacultyNestedInput
  }

  export type facultyUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    evaluations?: internship_evaluationUncheckedUpdateManyWithoutFacultyNestedInput
    students?: profileUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type institutionsUpsertWithWhereUniqueWithoutAdminUserInput = {
    where: institutionsWhereUniqueInput
    update: XOR<institutionsUpdateWithoutAdminUserInput, institutionsUncheckedUpdateWithoutAdminUserInput>
    create: XOR<institutionsCreateWithoutAdminUserInput, institutionsUncheckedCreateWithoutAdminUserInput>
  }

  export type institutionsUpdateWithWhereUniqueWithoutAdminUserInput = {
    where: institutionsWhereUniqueInput
    data: XOR<institutionsUpdateWithoutAdminUserInput, institutionsUncheckedUpdateWithoutAdminUserInput>
  }

  export type institutionsUpdateManyWithWhereWithoutAdminUserInput = {
    where: institutionsScalarWhereInput
    data: XOR<institutionsUpdateManyMutationInput, institutionsUncheckedUpdateManyWithoutAdminUserInput>
  }

  export type institutionsScalarWhereInput = {
    AND?: institutionsScalarWhereInput | institutionsScalarWhereInput[]
    OR?: institutionsScalarWhereInput[]
    NOT?: institutionsScalarWhereInput | institutionsScalarWhereInput[]
    id?: StringFilter<"institutions"> | string
    instituteName?: StringFilter<"institutions"> | string
    state?: StringFilter<"institutions"> | string
    adminUserId?: StringFilter<"institutions"> | string
    createdAt?: DateTimeFilter<"institutions"> | Date | string
  }

  export type internshipsUpsertWithWhereUniqueWithoutIndustryUserInput = {
    where: internshipsWhereUniqueInput
    update: XOR<internshipsUpdateWithoutIndustryUserInput, internshipsUncheckedUpdateWithoutIndustryUserInput>
    create: XOR<internshipsCreateWithoutIndustryUserInput, internshipsUncheckedCreateWithoutIndustryUserInput>
  }

  export type internshipsUpdateWithWhereUniqueWithoutIndustryUserInput = {
    where: internshipsWhereUniqueInput
    data: XOR<internshipsUpdateWithoutIndustryUserInput, internshipsUncheckedUpdateWithoutIndustryUserInput>
  }

  export type internshipsUpdateManyWithWhereWithoutIndustryUserInput = {
    where: internshipsScalarWhereInput
    data: XOR<internshipsUpdateManyMutationInput, internshipsUncheckedUpdateManyWithoutIndustryUserInput>
  }

  export type internshipsScalarWhereInput = {
    AND?: internshipsScalarWhereInput | internshipsScalarWhereInput[]
    OR?: internshipsScalarWhereInput[]
    NOT?: internshipsScalarWhereInput | internshipsScalarWhereInput[]
    id?: StringFilter<"internships"> | string
    industry_user_id?: StringFilter<"internships"> | string
    title?: StringFilter<"internships"> | string
    description?: StringFilter<"internships"> | string
    type?: StringFilter<"internships"> | string
    stipend?: FloatNullableFilter<"internships"> | number | null
    location?: StringFilter<"internships"> | string
    required_skills?: JsonFilter<"internships">
    duration_weeks?: IntFilter<"internships"> | number
    created_at?: DateTimeFilter<"internships"> | Date | string
  }

  export type mentorsUpsertWithoutUserInput = {
    update: XOR<mentorsUpdateWithoutUserInput, mentorsUncheckedUpdateWithoutUserInput>
    create: XOR<mentorsCreateWithoutUserInput, mentorsUncheckedCreateWithoutUserInput>
    where?: mentorsWhereInput
  }

  export type mentorsUpdateToOneWithWhereWithoutUserInput = {
    where?: mentorsWhereInput
    data: XOR<mentorsUpdateWithoutUserInput, mentorsUncheckedUpdateWithoutUserInput>
  }

  export type mentorsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expertise?: NullableJsonNullValueInput | InputJsonValue
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    reviews?: mentorReviewsUpdateManyWithoutMentorNestedInput
    sessions?: mentorSessionsUpdateManyWithoutMentorNestedInput
  }

  export type mentorsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expertise?: NullableJsonNullValueInput | InputJsonValue
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    reviews?: mentorReviewsUncheckedUpdateManyWithoutMentorNestedInput
    sessions?: mentorSessionsUncheckedUpdateManyWithoutMentorNestedInput
  }

  export type profileUpsertWithoutUserInput = {
    update: XOR<profileUpdateWithoutUserInput, profileUncheckedUpdateWithoutUserInput>
    create: XOR<profileCreateWithoutUserInput, profileUncheckedCreateWithoutUserInput>
    where?: profileWhereInput
  }

  export type profileUpdateToOneWithWhereWithoutUserInput = {
    where?: profileWhereInput
    data: XOR<profileUpdateWithoutUserInput, profileUncheckedUpdateWithoutUserInput>
  }

  export type profileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarURL?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: profileUpdateskillsInput | string[]
    interests?: profileUpdateinterestsInput | string[]
    department?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    certificates?: certificatesUpdateManyWithoutStudentNestedInput
    credits?: creditsUpdateManyWithoutStudentNestedInput
    internshipApplications?: internship_applicationsUpdateManyWithoutStudentNestedInput
    mentorReviews?: mentorReviewsUpdateManyWithoutStudentNestedInput
    mentorSessions?: mentorSessionsUpdateManyWithoutStudentNestedInput
    portfolioProjects?: portfolioProjectsUpdateManyWithoutUserNestedInput
    faculty?: facultyUpdateOneWithoutStudentsNestedInput
    institution?: institutionsUpdateOneRequiredWithoutProfilesNestedInput
    learningProgress?: studentLearningProgressUpdateManyWithoutProfileNestedInput
  }

  export type profileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarURL?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: profileUpdateskillsInput | string[]
    interests?: profileUpdateinterestsInput | string[]
    department?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    instituteId?: StringFieldUpdateOperationsInput | string
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
    certificates?: certificatesUncheckedUpdateManyWithoutStudentNestedInput
    credits?: creditsUncheckedUpdateManyWithoutStudentNestedInput
    internshipApplications?: internship_applicationsUncheckedUpdateManyWithoutStudentNestedInput
    mentorReviews?: mentorReviewsUncheckedUpdateManyWithoutStudentNestedInput
    mentorSessions?: mentorSessionsUncheckedUpdateManyWithoutStudentNestedInput
    portfolioProjects?: portfolioProjectsUncheckedUpdateManyWithoutUserNestedInput
    learningProgress?: studentLearningProgressUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type user_notificationsUpsertWithWhereUniqueWithoutUserInput = {
    where: user_notificationsWhereUniqueInput
    update: XOR<user_notificationsUpdateWithoutUserInput, user_notificationsUncheckedUpdateWithoutUserInput>
    create: XOR<user_notificationsCreateWithoutUserInput, user_notificationsUncheckedCreateWithoutUserInput>
  }

  export type user_notificationsUpdateWithWhereUniqueWithoutUserInput = {
    where: user_notificationsWhereUniqueInput
    data: XOR<user_notificationsUpdateWithoutUserInput, user_notificationsUncheckedUpdateWithoutUserInput>
  }

  export type user_notificationsUpdateManyWithWhereWithoutUserInput = {
    where: user_notificationsScalarWhereInput
    data: XOR<user_notificationsUpdateManyMutationInput, user_notificationsUncheckedUpdateManyWithoutUserInput>
  }

  export type user_notificationsScalarWhereInput = {
    AND?: user_notificationsScalarWhereInput | user_notificationsScalarWhereInput[]
    OR?: user_notificationsScalarWhereInput[]
    NOT?: user_notificationsScalarWhereInput | user_notificationsScalarWhereInput[]
    id?: StringFilter<"user_notifications"> | string
    user_id?: StringFilter<"user_notifications"> | string
    notification_id?: StringFilter<"user_notifications"> | string
    isRead?: BoolFilter<"user_notifications"> | boolean
    read_at?: DateTimeNullableFilter<"user_notifications"> | Date | string | null
  }

  export type facultyCreateWithoutInstitutionInput = {
    id?: string
    name: string
    department: string
    user: usersCreateNestedOneWithoutFacultyProfileInput
    evaluations?: internship_evaluationCreateNestedManyWithoutFacultyInput
    students?: profileCreateNestedManyWithoutFacultyInput
  }

  export type facultyUncheckedCreateWithoutInstitutionInput = {
    id?: string
    userId: string
    name: string
    department: string
    evaluations?: internship_evaluationUncheckedCreateNestedManyWithoutFacultyInput
    students?: profileUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type facultyCreateOrConnectWithoutInstitutionInput = {
    where: facultyWhereUniqueInput
    create: XOR<facultyCreateWithoutInstitutionInput, facultyUncheckedCreateWithoutInstitutionInput>
  }

  export type facultyCreateManyInstitutionInputEnvelope = {
    data: facultyCreateManyInstitutionInput | facultyCreateManyInstitutionInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutInstitutions_adminInput = {
    id?: string
    displayName: string
    role?: usersCreateroleInput | string[]
    email: string
    salt: string
    phone: string
    hashPassword: string
    courseEnrollments?: courseEnrollmentsCreateNestedManyWithoutUserInput
    courses_instructor?: coursesCreateNestedManyWithoutInstructorInput
    facultyProfile?: facultyCreateNestedOneWithoutUserInput
    internships_industryUser?: internshipsCreateNestedManyWithoutIndustryUserInput
    mentors?: mentorsCreateNestedOneWithoutUserInput
    profiles?: profileCreateNestedOneWithoutUserInput
    user_notifications?: user_notificationsCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutInstitutions_adminInput = {
    id?: string
    displayName: string
    role?: usersCreateroleInput | string[]
    email: string
    salt: string
    phone: string
    hashPassword: string
    courseEnrollments?: courseEnrollmentsUncheckedCreateNestedManyWithoutUserInput
    courses_instructor?: coursesUncheckedCreateNestedManyWithoutInstructorInput
    facultyProfile?: facultyUncheckedCreateNestedOneWithoutUserInput
    internships_industryUser?: internshipsUncheckedCreateNestedManyWithoutIndustryUserInput
    mentors?: mentorsUncheckedCreateNestedOneWithoutUserInput
    profiles?: profileUncheckedCreateNestedOneWithoutUserInput
    user_notifications?: user_notificationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutInstitutions_adminInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutInstitutions_adminInput, usersUncheckedCreateWithoutInstitutions_adminInput>
  }

  export type profileCreateWithoutInstitutionInput = {
    id?: string
    bio?: string | null
    gender?: string | null
    DOB?: Date | string | null
    avatarURL?: string | null
    github?: string | null
    linkedin?: string | null
    skills?: profileCreateskillsInput | string[]
    interests?: profileCreateinterestsInput | string[]
    department?: string | null
    resourceId?: string | null
    certificates?: certificatesCreateNestedManyWithoutStudentInput
    credits?: creditsCreateNestedManyWithoutStudentInput
    internshipApplications?: internship_applicationsCreateNestedManyWithoutStudentInput
    mentorReviews?: mentorReviewsCreateNestedManyWithoutStudentInput
    mentorSessions?: mentorSessionsCreateNestedManyWithoutStudentInput
    portfolioProjects?: portfolioProjectsCreateNestedManyWithoutUserInput
    faculty?: facultyCreateNestedOneWithoutStudentsInput
    user: usersCreateNestedOneWithoutProfilesInput
    learningProgress?: studentLearningProgressCreateNestedManyWithoutProfileInput
  }

  export type profileUncheckedCreateWithoutInstitutionInput = {
    id?: string
    userId: string
    bio?: string | null
    gender?: string | null
    DOB?: Date | string | null
    avatarURL?: string | null
    github?: string | null
    linkedin?: string | null
    skills?: profileCreateskillsInput | string[]
    interests?: profileCreateinterestsInput | string[]
    department?: string | null
    resourceId?: string | null
    facultyId?: string | null
    certificates?: certificatesUncheckedCreateNestedManyWithoutStudentInput
    credits?: creditsUncheckedCreateNestedManyWithoutStudentInput
    internshipApplications?: internship_applicationsUncheckedCreateNestedManyWithoutStudentInput
    mentorReviews?: mentorReviewsUncheckedCreateNestedManyWithoutStudentInput
    mentorSessions?: mentorSessionsUncheckedCreateNestedManyWithoutStudentInput
    portfolioProjects?: portfolioProjectsUncheckedCreateNestedManyWithoutUserInput
    learningProgress?: studentLearningProgressUncheckedCreateNestedManyWithoutProfileInput
  }

  export type profileCreateOrConnectWithoutInstitutionInput = {
    where: profileWhereUniqueInput
    create: XOR<profileCreateWithoutInstitutionInput, profileUncheckedCreateWithoutInstitutionInput>
  }

  export type profileCreateManyInstitutionInputEnvelope = {
    data: profileCreateManyInstitutionInput | profileCreateManyInstitutionInput[]
    skipDuplicates?: boolean
  }

  export type facultyUpsertWithWhereUniqueWithoutInstitutionInput = {
    where: facultyWhereUniqueInput
    update: XOR<facultyUpdateWithoutInstitutionInput, facultyUncheckedUpdateWithoutInstitutionInput>
    create: XOR<facultyCreateWithoutInstitutionInput, facultyUncheckedCreateWithoutInstitutionInput>
  }

  export type facultyUpdateWithWhereUniqueWithoutInstitutionInput = {
    where: facultyWhereUniqueInput
    data: XOR<facultyUpdateWithoutInstitutionInput, facultyUncheckedUpdateWithoutInstitutionInput>
  }

  export type facultyUpdateManyWithWhereWithoutInstitutionInput = {
    where: facultyScalarWhereInput
    data: XOR<facultyUpdateManyMutationInput, facultyUncheckedUpdateManyWithoutInstitutionInput>
  }

  export type facultyScalarWhereInput = {
    AND?: facultyScalarWhereInput | facultyScalarWhereInput[]
    OR?: facultyScalarWhereInput[]
    NOT?: facultyScalarWhereInput | facultyScalarWhereInput[]
    id?: StringFilter<"faculty"> | string
    instituteId?: StringFilter<"faculty"> | string
    userId?: StringFilter<"faculty"> | string
    name?: StringFilter<"faculty"> | string
    department?: StringFilter<"faculty"> | string
  }

  export type usersUpsertWithoutInstitutions_adminInput = {
    update: XOR<usersUpdateWithoutInstitutions_adminInput, usersUncheckedUpdateWithoutInstitutions_adminInput>
    create: XOR<usersCreateWithoutInstitutions_adminInput, usersUncheckedCreateWithoutInstitutions_adminInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutInstitutions_adminInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutInstitutions_adminInput, usersUncheckedUpdateWithoutInstitutions_adminInput>
  }

  export type usersUpdateWithoutInstitutions_adminInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    role?: usersUpdateroleInput | string[]
    email?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    hashPassword?: StringFieldUpdateOperationsInput | string
    courseEnrollments?: courseEnrollmentsUpdateManyWithoutUserNestedInput
    courses_instructor?: coursesUpdateManyWithoutInstructorNestedInput
    facultyProfile?: facultyUpdateOneWithoutUserNestedInput
    internships_industryUser?: internshipsUpdateManyWithoutIndustryUserNestedInput
    mentors?: mentorsUpdateOneWithoutUserNestedInput
    profiles?: profileUpdateOneWithoutUserNestedInput
    user_notifications?: user_notificationsUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutInstitutions_adminInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    role?: usersUpdateroleInput | string[]
    email?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    hashPassword?: StringFieldUpdateOperationsInput | string
    courseEnrollments?: courseEnrollmentsUncheckedUpdateManyWithoutUserNestedInput
    courses_instructor?: coursesUncheckedUpdateManyWithoutInstructorNestedInput
    facultyProfile?: facultyUncheckedUpdateOneWithoutUserNestedInput
    internships_industryUser?: internshipsUncheckedUpdateManyWithoutIndustryUserNestedInput
    mentors?: mentorsUncheckedUpdateOneWithoutUserNestedInput
    profiles?: profileUncheckedUpdateOneWithoutUserNestedInput
    user_notifications?: user_notificationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type profileUpsertWithWhereUniqueWithoutInstitutionInput = {
    where: profileWhereUniqueInput
    update: XOR<profileUpdateWithoutInstitutionInput, profileUncheckedUpdateWithoutInstitutionInput>
    create: XOR<profileCreateWithoutInstitutionInput, profileUncheckedCreateWithoutInstitutionInput>
  }

  export type profileUpdateWithWhereUniqueWithoutInstitutionInput = {
    where: profileWhereUniqueInput
    data: XOR<profileUpdateWithoutInstitutionInput, profileUncheckedUpdateWithoutInstitutionInput>
  }

  export type profileUpdateManyWithWhereWithoutInstitutionInput = {
    where: profileScalarWhereInput
    data: XOR<profileUpdateManyMutationInput, profileUncheckedUpdateManyWithoutInstitutionInput>
  }

  export type profileScalarWhereInput = {
    AND?: profileScalarWhereInput | profileScalarWhereInput[]
    OR?: profileScalarWhereInput[]
    NOT?: profileScalarWhereInput | profileScalarWhereInput[]
    id?: StringFilter<"profile"> | string
    userId?: StringFilter<"profile"> | string
    bio?: StringNullableFilter<"profile"> | string | null
    gender?: StringNullableFilter<"profile"> | string | null
    DOB?: DateTimeNullableFilter<"profile"> | Date | string | null
    avatarURL?: StringNullableFilter<"profile"> | string | null
    github?: StringNullableFilter<"profile"> | string | null
    linkedin?: StringNullableFilter<"profile"> | string | null
    skills?: StringNullableListFilter<"profile">
    interests?: StringNullableListFilter<"profile">
    department?: StringNullableFilter<"profile"> | string | null
    resourceId?: StringNullableFilter<"profile"> | string | null
    instituteId?: StringFilter<"profile"> | string
    facultyId?: StringNullableFilter<"profile"> | string | null
  }

  export type certificatesCreateWithoutStudentInput = {
    id?: string
    title: string
    certificateUrl: string
    issuedAt: Date | string
  }

  export type certificatesUncheckedCreateWithoutStudentInput = {
    id?: string
    title: string
    certificateUrl: string
    issuedAt: Date | string
  }

  export type certificatesCreateOrConnectWithoutStudentInput = {
    where: certificatesWhereUniqueInput
    create: XOR<certificatesCreateWithoutStudentInput, certificatesUncheckedCreateWithoutStudentInput>
  }

  export type certificatesCreateManyStudentInputEnvelope = {
    data: certificatesCreateManyStudentInput | certificatesCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type creditsCreateWithoutStudentInput = {
    id?: string
    credits_earned: number
  }

  export type creditsUncheckedCreateWithoutStudentInput = {
    id?: string
    credits_earned: number
  }

  export type creditsCreateOrConnectWithoutStudentInput = {
    where: creditsWhereUniqueInput
    create: XOR<creditsCreateWithoutStudentInput, creditsUncheckedCreateWithoutStudentInput>
  }

  export type creditsCreateManyStudentInputEnvelope = {
    data: creditsCreateManyStudentInput | creditsCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type internship_applicationsCreateWithoutStudentInput = {
    id?: string
    status: $Enums.InternshipStatus
    submission_url?: string | null
    score?: number | null
    applied_at: Date | string
    internship: internshipsCreateNestedOneWithoutApplicationsInput
    evaluations?: internship_evaluationCreateNestedManyWithoutApplicationInput
    logbookEntries?: logbook_entriesCreateNestedManyWithoutApplicationInput
  }

  export type internship_applicationsUncheckedCreateWithoutStudentInput = {
    id?: string
    internship_id: string
    status: $Enums.InternshipStatus
    submission_url?: string | null
    score?: number | null
    applied_at: Date | string
    evaluations?: internship_evaluationUncheckedCreateNestedManyWithoutApplicationInput
    logbookEntries?: logbook_entriesUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type internship_applicationsCreateOrConnectWithoutStudentInput = {
    where: internship_applicationsWhereUniqueInput
    create: XOR<internship_applicationsCreateWithoutStudentInput, internship_applicationsUncheckedCreateWithoutStudentInput>
  }

  export type internship_applicationsCreateManyStudentInputEnvelope = {
    data: internship_applicationsCreateManyStudentInput | internship_applicationsCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type mentorReviewsCreateWithoutStudentInput = {
    id?: string
    rating: number
    reviews?: string | null
    mentor: mentorsCreateNestedOneWithoutReviewsInput
  }

  export type mentorReviewsUncheckedCreateWithoutStudentInput = {
    id?: string
    mentorId: string
    rating: number
    reviews?: string | null
  }

  export type mentorReviewsCreateOrConnectWithoutStudentInput = {
    where: mentorReviewsWhereUniqueInput
    create: XOR<mentorReviewsCreateWithoutStudentInput, mentorReviewsUncheckedCreateWithoutStudentInput>
  }

  export type mentorReviewsCreateManyStudentInputEnvelope = {
    data: mentorReviewsCreateManyStudentInput | mentorReviewsCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type mentorSessionsCreateWithoutStudentInput = {
    id?: string
    scheduled_at: Date | string
    status: $Enums.MentorSessionStatus
    meeting_link?: string | null
    mentor: mentorsCreateNestedOneWithoutSessionsInput
  }

  export type mentorSessionsUncheckedCreateWithoutStudentInput = {
    id?: string
    mentorId: string
    scheduled_at: Date | string
    status: $Enums.MentorSessionStatus
    meeting_link?: string | null
  }

  export type mentorSessionsCreateOrConnectWithoutStudentInput = {
    where: mentorSessionsWhereUniqueInput
    create: XOR<mentorSessionsCreateWithoutStudentInput, mentorSessionsUncheckedCreateWithoutStudentInput>
  }

  export type mentorSessionsCreateManyStudentInputEnvelope = {
    data: mentorSessionsCreateManyStudentInput | mentorSessionsCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type portfolioProjectsCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    github_url?: string | null
    live_url?: string | null
    tags?: portfolioProjectsCreatetagsInput | string[]
  }

  export type portfolioProjectsUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    github_url?: string | null
    live_url?: string | null
    tags?: portfolioProjectsCreatetagsInput | string[]
  }

  export type portfolioProjectsCreateOrConnectWithoutUserInput = {
    where: portfolioProjectsWhereUniqueInput
    create: XOR<portfolioProjectsCreateWithoutUserInput, portfolioProjectsUncheckedCreateWithoutUserInput>
  }

  export type portfolioProjectsCreateManyUserInputEnvelope = {
    data: portfolioProjectsCreateManyUserInput | portfolioProjectsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type facultyCreateWithoutStudentsInput = {
    id?: string
    name: string
    department: string
    institution: institutionsCreateNestedOneWithoutFacultyInput
    user: usersCreateNestedOneWithoutFacultyProfileInput
    evaluations?: internship_evaluationCreateNestedManyWithoutFacultyInput
  }

  export type facultyUncheckedCreateWithoutStudentsInput = {
    id?: string
    instituteId: string
    userId: string
    name: string
    department: string
    evaluations?: internship_evaluationUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type facultyCreateOrConnectWithoutStudentsInput = {
    where: facultyWhereUniqueInput
    create: XOR<facultyCreateWithoutStudentsInput, facultyUncheckedCreateWithoutStudentsInput>
  }

  export type institutionsCreateWithoutProfilesInput = {
    id?: string
    instituteName: string
    state: string
    createdAt: Date | string
    faculty?: facultyCreateNestedManyWithoutInstitutionInput
    adminUser: usersCreateNestedOneWithoutInstitutions_adminInput
  }

  export type institutionsUncheckedCreateWithoutProfilesInput = {
    id?: string
    instituteName: string
    state: string
    adminUserId: string
    createdAt: Date | string
    faculty?: facultyUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type institutionsCreateOrConnectWithoutProfilesInput = {
    where: institutionsWhereUniqueInput
    create: XOR<institutionsCreateWithoutProfilesInput, institutionsUncheckedCreateWithoutProfilesInput>
  }

  export type usersCreateWithoutProfilesInput = {
    id?: string
    displayName: string
    role?: usersCreateroleInput | string[]
    email: string
    salt: string
    phone: string
    hashPassword: string
    courseEnrollments?: courseEnrollmentsCreateNestedManyWithoutUserInput
    courses_instructor?: coursesCreateNestedManyWithoutInstructorInput
    facultyProfile?: facultyCreateNestedOneWithoutUserInput
    institutions_admin?: institutionsCreateNestedManyWithoutAdminUserInput
    internships_industryUser?: internshipsCreateNestedManyWithoutIndustryUserInput
    mentors?: mentorsCreateNestedOneWithoutUserInput
    user_notifications?: user_notificationsCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutProfilesInput = {
    id?: string
    displayName: string
    role?: usersCreateroleInput | string[]
    email: string
    salt: string
    phone: string
    hashPassword: string
    courseEnrollments?: courseEnrollmentsUncheckedCreateNestedManyWithoutUserInput
    courses_instructor?: coursesUncheckedCreateNestedManyWithoutInstructorInput
    facultyProfile?: facultyUncheckedCreateNestedOneWithoutUserInput
    institutions_admin?: institutionsUncheckedCreateNestedManyWithoutAdminUserInput
    internships_industryUser?: internshipsUncheckedCreateNestedManyWithoutIndustryUserInput
    mentors?: mentorsUncheckedCreateNestedOneWithoutUserInput
    user_notifications?: user_notificationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutProfilesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutProfilesInput, usersUncheckedCreateWithoutProfilesInput>
  }

  export type studentLearningProgressCreateWithoutProfileInput = {
    id?: string
    isCompleted: boolean
    completedAt?: Date | string | null
    checkpoint: checkpointsCreateNestedOneWithoutProgressInput
  }

  export type studentLearningProgressUncheckedCreateWithoutProfileInput = {
    id?: string
    checkpointId: string
    isCompleted: boolean
    completedAt?: Date | string | null
  }

  export type studentLearningProgressCreateOrConnectWithoutProfileInput = {
    where: studentLearningProgressWhereUniqueInput
    create: XOR<studentLearningProgressCreateWithoutProfileInput, studentLearningProgressUncheckedCreateWithoutProfileInput>
  }

  export type studentLearningProgressCreateManyProfileInputEnvelope = {
    data: studentLearningProgressCreateManyProfileInput | studentLearningProgressCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type certificatesUpsertWithWhereUniqueWithoutStudentInput = {
    where: certificatesWhereUniqueInput
    update: XOR<certificatesUpdateWithoutStudentInput, certificatesUncheckedUpdateWithoutStudentInput>
    create: XOR<certificatesCreateWithoutStudentInput, certificatesUncheckedCreateWithoutStudentInput>
  }

  export type certificatesUpdateWithWhereUniqueWithoutStudentInput = {
    where: certificatesWhereUniqueInput
    data: XOR<certificatesUpdateWithoutStudentInput, certificatesUncheckedUpdateWithoutStudentInput>
  }

  export type certificatesUpdateManyWithWhereWithoutStudentInput = {
    where: certificatesScalarWhereInput
    data: XOR<certificatesUpdateManyMutationInput, certificatesUncheckedUpdateManyWithoutStudentInput>
  }

  export type certificatesScalarWhereInput = {
    AND?: certificatesScalarWhereInput | certificatesScalarWhereInput[]
    OR?: certificatesScalarWhereInput[]
    NOT?: certificatesScalarWhereInput | certificatesScalarWhereInput[]
    id?: StringFilter<"certificates"> | string
    student_id?: StringFilter<"certificates"> | string
    title?: StringFilter<"certificates"> | string
    certificateUrl?: StringFilter<"certificates"> | string
    issuedAt?: DateTimeFilter<"certificates"> | Date | string
  }

  export type creditsUpsertWithWhereUniqueWithoutStudentInput = {
    where: creditsWhereUniqueInput
    update: XOR<creditsUpdateWithoutStudentInput, creditsUncheckedUpdateWithoutStudentInput>
    create: XOR<creditsCreateWithoutStudentInput, creditsUncheckedCreateWithoutStudentInput>
  }

  export type creditsUpdateWithWhereUniqueWithoutStudentInput = {
    where: creditsWhereUniqueInput
    data: XOR<creditsUpdateWithoutStudentInput, creditsUncheckedUpdateWithoutStudentInput>
  }

  export type creditsUpdateManyWithWhereWithoutStudentInput = {
    where: creditsScalarWhereInput
    data: XOR<creditsUpdateManyMutationInput, creditsUncheckedUpdateManyWithoutStudentInput>
  }

  export type creditsScalarWhereInput = {
    AND?: creditsScalarWhereInput | creditsScalarWhereInput[]
    OR?: creditsScalarWhereInput[]
    NOT?: creditsScalarWhereInput | creditsScalarWhereInput[]
    id?: StringFilter<"credits"> | string
    student_id?: StringFilter<"credits"> | string
    credits_earned?: FloatFilter<"credits"> | number
  }

  export type internship_applicationsUpsertWithWhereUniqueWithoutStudentInput = {
    where: internship_applicationsWhereUniqueInput
    update: XOR<internship_applicationsUpdateWithoutStudentInput, internship_applicationsUncheckedUpdateWithoutStudentInput>
    create: XOR<internship_applicationsCreateWithoutStudentInput, internship_applicationsUncheckedCreateWithoutStudentInput>
  }

  export type internship_applicationsUpdateWithWhereUniqueWithoutStudentInput = {
    where: internship_applicationsWhereUniqueInput
    data: XOR<internship_applicationsUpdateWithoutStudentInput, internship_applicationsUncheckedUpdateWithoutStudentInput>
  }

  export type internship_applicationsUpdateManyWithWhereWithoutStudentInput = {
    where: internship_applicationsScalarWhereInput
    data: XOR<internship_applicationsUpdateManyMutationInput, internship_applicationsUncheckedUpdateManyWithoutStudentInput>
  }

  export type internship_applicationsScalarWhereInput = {
    AND?: internship_applicationsScalarWhereInput | internship_applicationsScalarWhereInput[]
    OR?: internship_applicationsScalarWhereInput[]
    NOT?: internship_applicationsScalarWhereInput | internship_applicationsScalarWhereInput[]
    id?: StringFilter<"internship_applications"> | string
    internship_id?: StringFilter<"internship_applications"> | string
    student_id?: StringFilter<"internship_applications"> | string
    status?: EnumInternshipStatusFilter<"internship_applications"> | $Enums.InternshipStatus
    submission_url?: StringNullableFilter<"internship_applications"> | string | null
    score?: FloatNullableFilter<"internship_applications"> | number | null
    applied_at?: DateTimeFilter<"internship_applications"> | Date | string
  }

  export type mentorReviewsUpsertWithWhereUniqueWithoutStudentInput = {
    where: mentorReviewsWhereUniqueInput
    update: XOR<mentorReviewsUpdateWithoutStudentInput, mentorReviewsUncheckedUpdateWithoutStudentInput>
    create: XOR<mentorReviewsCreateWithoutStudentInput, mentorReviewsUncheckedCreateWithoutStudentInput>
  }

  export type mentorReviewsUpdateWithWhereUniqueWithoutStudentInput = {
    where: mentorReviewsWhereUniqueInput
    data: XOR<mentorReviewsUpdateWithoutStudentInput, mentorReviewsUncheckedUpdateWithoutStudentInput>
  }

  export type mentorReviewsUpdateManyWithWhereWithoutStudentInput = {
    where: mentorReviewsScalarWhereInput
    data: XOR<mentorReviewsUpdateManyMutationInput, mentorReviewsUncheckedUpdateManyWithoutStudentInput>
  }

  export type mentorReviewsScalarWhereInput = {
    AND?: mentorReviewsScalarWhereInput | mentorReviewsScalarWhereInput[]
    OR?: mentorReviewsScalarWhereInput[]
    NOT?: mentorReviewsScalarWhereInput | mentorReviewsScalarWhereInput[]
    id?: StringFilter<"mentorReviews"> | string
    mentorId?: StringFilter<"mentorReviews"> | string
    rating?: FloatFilter<"mentorReviews"> | number
    reviews?: StringNullableFilter<"mentorReviews"> | string | null
    studentId?: StringFilter<"mentorReviews"> | string
  }

  export type mentorSessionsUpsertWithWhereUniqueWithoutStudentInput = {
    where: mentorSessionsWhereUniqueInput
    update: XOR<mentorSessionsUpdateWithoutStudentInput, mentorSessionsUncheckedUpdateWithoutStudentInput>
    create: XOR<mentorSessionsCreateWithoutStudentInput, mentorSessionsUncheckedCreateWithoutStudentInput>
  }

  export type mentorSessionsUpdateWithWhereUniqueWithoutStudentInput = {
    where: mentorSessionsWhereUniqueInput
    data: XOR<mentorSessionsUpdateWithoutStudentInput, mentorSessionsUncheckedUpdateWithoutStudentInput>
  }

  export type mentorSessionsUpdateManyWithWhereWithoutStudentInput = {
    where: mentorSessionsScalarWhereInput
    data: XOR<mentorSessionsUpdateManyMutationInput, mentorSessionsUncheckedUpdateManyWithoutStudentInput>
  }

  export type mentorSessionsScalarWhereInput = {
    AND?: mentorSessionsScalarWhereInput | mentorSessionsScalarWhereInput[]
    OR?: mentorSessionsScalarWhereInput[]
    NOT?: mentorSessionsScalarWhereInput | mentorSessionsScalarWhereInput[]
    id?: StringFilter<"mentorSessions"> | string
    studentId?: StringFilter<"mentorSessions"> | string
    mentorId?: StringFilter<"mentorSessions"> | string
    scheduled_at?: DateTimeFilter<"mentorSessions"> | Date | string
    status?: EnumMentorSessionStatusFilter<"mentorSessions"> | $Enums.MentorSessionStatus
    meeting_link?: StringNullableFilter<"mentorSessions"> | string | null
  }

  export type portfolioProjectsUpsertWithWhereUniqueWithoutUserInput = {
    where: portfolioProjectsWhereUniqueInput
    update: XOR<portfolioProjectsUpdateWithoutUserInput, portfolioProjectsUncheckedUpdateWithoutUserInput>
    create: XOR<portfolioProjectsCreateWithoutUserInput, portfolioProjectsUncheckedCreateWithoutUserInput>
  }

  export type portfolioProjectsUpdateWithWhereUniqueWithoutUserInput = {
    where: portfolioProjectsWhereUniqueInput
    data: XOR<portfolioProjectsUpdateWithoutUserInput, portfolioProjectsUncheckedUpdateWithoutUserInput>
  }

  export type portfolioProjectsUpdateManyWithWhereWithoutUserInput = {
    where: portfolioProjectsScalarWhereInput
    data: XOR<portfolioProjectsUpdateManyMutationInput, portfolioProjectsUncheckedUpdateManyWithoutUserInput>
  }

  export type portfolioProjectsScalarWhereInput = {
    AND?: portfolioProjectsScalarWhereInput | portfolioProjectsScalarWhereInput[]
    OR?: portfolioProjectsScalarWhereInput[]
    NOT?: portfolioProjectsScalarWhereInput | portfolioProjectsScalarWhereInput[]
    id?: StringFilter<"portfolioProjects"> | string
    user_id?: StringFilter<"portfolioProjects"> | string
    title?: StringFilter<"portfolioProjects"> | string
    description?: StringNullableFilter<"portfolioProjects"> | string | null
    github_url?: StringNullableFilter<"portfolioProjects"> | string | null
    live_url?: StringNullableFilter<"portfolioProjects"> | string | null
    tags?: StringNullableListFilter<"portfolioProjects">
  }

  export type facultyUpsertWithoutStudentsInput = {
    update: XOR<facultyUpdateWithoutStudentsInput, facultyUncheckedUpdateWithoutStudentsInput>
    create: XOR<facultyCreateWithoutStudentsInput, facultyUncheckedCreateWithoutStudentsInput>
    where?: facultyWhereInput
  }

  export type facultyUpdateToOneWithWhereWithoutStudentsInput = {
    where?: facultyWhereInput
    data: XOR<facultyUpdateWithoutStudentsInput, facultyUncheckedUpdateWithoutStudentsInput>
  }

  export type facultyUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    institution?: institutionsUpdateOneRequiredWithoutFacultyNestedInput
    user?: usersUpdateOneRequiredWithoutFacultyProfileNestedInput
    evaluations?: internship_evaluationUpdateManyWithoutFacultyNestedInput
  }

  export type facultyUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    evaluations?: internship_evaluationUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type institutionsUpsertWithoutProfilesInput = {
    update: XOR<institutionsUpdateWithoutProfilesInput, institutionsUncheckedUpdateWithoutProfilesInput>
    create: XOR<institutionsCreateWithoutProfilesInput, institutionsUncheckedCreateWithoutProfilesInput>
    where?: institutionsWhereInput
  }

  export type institutionsUpdateToOneWithWhereWithoutProfilesInput = {
    where?: institutionsWhereInput
    data: XOR<institutionsUpdateWithoutProfilesInput, institutionsUncheckedUpdateWithoutProfilesInput>
  }

  export type institutionsUpdateWithoutProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    faculty?: facultyUpdateManyWithoutInstitutionNestedInput
    adminUser?: usersUpdateOneRequiredWithoutInstitutions_adminNestedInput
  }

  export type institutionsUncheckedUpdateWithoutProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    adminUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    faculty?: facultyUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type usersUpsertWithoutProfilesInput = {
    update: XOR<usersUpdateWithoutProfilesInput, usersUncheckedUpdateWithoutProfilesInput>
    create: XOR<usersCreateWithoutProfilesInput, usersUncheckedCreateWithoutProfilesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutProfilesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutProfilesInput, usersUncheckedUpdateWithoutProfilesInput>
  }

  export type usersUpdateWithoutProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    role?: usersUpdateroleInput | string[]
    email?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    hashPassword?: StringFieldUpdateOperationsInput | string
    courseEnrollments?: courseEnrollmentsUpdateManyWithoutUserNestedInput
    courses_instructor?: coursesUpdateManyWithoutInstructorNestedInput
    facultyProfile?: facultyUpdateOneWithoutUserNestedInput
    institutions_admin?: institutionsUpdateManyWithoutAdminUserNestedInput
    internships_industryUser?: internshipsUpdateManyWithoutIndustryUserNestedInput
    mentors?: mentorsUpdateOneWithoutUserNestedInput
    user_notifications?: user_notificationsUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutProfilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    role?: usersUpdateroleInput | string[]
    email?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    hashPassword?: StringFieldUpdateOperationsInput | string
    courseEnrollments?: courseEnrollmentsUncheckedUpdateManyWithoutUserNestedInput
    courses_instructor?: coursesUncheckedUpdateManyWithoutInstructorNestedInput
    facultyProfile?: facultyUncheckedUpdateOneWithoutUserNestedInput
    institutions_admin?: institutionsUncheckedUpdateManyWithoutAdminUserNestedInput
    internships_industryUser?: internshipsUncheckedUpdateManyWithoutIndustryUserNestedInput
    mentors?: mentorsUncheckedUpdateOneWithoutUserNestedInput
    user_notifications?: user_notificationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type studentLearningProgressUpsertWithWhereUniqueWithoutProfileInput = {
    where: studentLearningProgressWhereUniqueInput
    update: XOR<studentLearningProgressUpdateWithoutProfileInput, studentLearningProgressUncheckedUpdateWithoutProfileInput>
    create: XOR<studentLearningProgressCreateWithoutProfileInput, studentLearningProgressUncheckedCreateWithoutProfileInput>
  }

  export type studentLearningProgressUpdateWithWhereUniqueWithoutProfileInput = {
    where: studentLearningProgressWhereUniqueInput
    data: XOR<studentLearningProgressUpdateWithoutProfileInput, studentLearningProgressUncheckedUpdateWithoutProfileInput>
  }

  export type studentLearningProgressUpdateManyWithWhereWithoutProfileInput = {
    where: studentLearningProgressScalarWhereInput
    data: XOR<studentLearningProgressUpdateManyMutationInput, studentLearningProgressUncheckedUpdateManyWithoutProfileInput>
  }

  export type studentLearningProgressScalarWhereInput = {
    AND?: studentLearningProgressScalarWhereInput | studentLearningProgressScalarWhereInput[]
    OR?: studentLearningProgressScalarWhereInput[]
    NOT?: studentLearningProgressScalarWhereInput | studentLearningProgressScalarWhereInput[]
    id?: StringFilter<"studentLearningProgress"> | string
    profileId?: StringFilter<"studentLearningProgress"> | string
    checkpointId?: StringFilter<"studentLearningProgress"> | string
    isCompleted?: BoolFilter<"studentLearningProgress"> | boolean
    completedAt?: DateTimeNullableFilter<"studentLearningProgress"> | Date | string | null
  }

  export type checkpointsCreateWithoutRoadmapInput = {
    id?: string
    title: string
    description: string
    resourceType: string
    resourceUrl: string
    progress?: studentLearningProgressCreateNestedManyWithoutCheckpointInput
  }

  export type checkpointsUncheckedCreateWithoutRoadmapInput = {
    id?: string
    title: string
    description: string
    resourceType: string
    resourceUrl: string
    progress?: studentLearningProgressUncheckedCreateNestedManyWithoutCheckpointInput
  }

  export type checkpointsCreateOrConnectWithoutRoadmapInput = {
    where: checkpointsWhereUniqueInput
    create: XOR<checkpointsCreateWithoutRoadmapInput, checkpointsUncheckedCreateWithoutRoadmapInput>
  }

  export type checkpointsCreateManyRoadmapInputEnvelope = {
    data: checkpointsCreateManyRoadmapInput | checkpointsCreateManyRoadmapInput[]
    skipDuplicates?: boolean
  }

  export type checkpointsUpsertWithWhereUniqueWithoutRoadmapInput = {
    where: checkpointsWhereUniqueInput
    update: XOR<checkpointsUpdateWithoutRoadmapInput, checkpointsUncheckedUpdateWithoutRoadmapInput>
    create: XOR<checkpointsCreateWithoutRoadmapInput, checkpointsUncheckedCreateWithoutRoadmapInput>
  }

  export type checkpointsUpdateWithWhereUniqueWithoutRoadmapInput = {
    where: checkpointsWhereUniqueInput
    data: XOR<checkpointsUpdateWithoutRoadmapInput, checkpointsUncheckedUpdateWithoutRoadmapInput>
  }

  export type checkpointsUpdateManyWithWhereWithoutRoadmapInput = {
    where: checkpointsScalarWhereInput
    data: XOR<checkpointsUpdateManyMutationInput, checkpointsUncheckedUpdateManyWithoutRoadmapInput>
  }

  export type checkpointsScalarWhereInput = {
    AND?: checkpointsScalarWhereInput | checkpointsScalarWhereInput[]
    OR?: checkpointsScalarWhereInput[]
    NOT?: checkpointsScalarWhereInput | checkpointsScalarWhereInput[]
    id?: StringFilter<"checkpoints"> | string
    roadmapId?: StringFilter<"checkpoints"> | string
    title?: StringFilter<"checkpoints"> | string
    description?: StringFilter<"checkpoints"> | string
    resourceType?: StringFilter<"checkpoints"> | string
    resourceUrl?: StringFilter<"checkpoints"> | string
  }

  export type roadmapsCreateWithoutCheckpointsInput = {
    id?: string
    title: string
    description: string
    domain: string
  }

  export type roadmapsUncheckedCreateWithoutCheckpointsInput = {
    id?: string
    title: string
    description: string
    domain: string
  }

  export type roadmapsCreateOrConnectWithoutCheckpointsInput = {
    where: roadmapsWhereUniqueInput
    create: XOR<roadmapsCreateWithoutCheckpointsInput, roadmapsUncheckedCreateWithoutCheckpointsInput>
  }

  export type studentLearningProgressCreateWithoutCheckpointInput = {
    id?: string
    isCompleted: boolean
    completedAt?: Date | string | null
    profile: profileCreateNestedOneWithoutLearningProgressInput
  }

  export type studentLearningProgressUncheckedCreateWithoutCheckpointInput = {
    id?: string
    profileId: string
    isCompleted: boolean
    completedAt?: Date | string | null
  }

  export type studentLearningProgressCreateOrConnectWithoutCheckpointInput = {
    where: studentLearningProgressWhereUniqueInput
    create: XOR<studentLearningProgressCreateWithoutCheckpointInput, studentLearningProgressUncheckedCreateWithoutCheckpointInput>
  }

  export type studentLearningProgressCreateManyCheckpointInputEnvelope = {
    data: studentLearningProgressCreateManyCheckpointInput | studentLearningProgressCreateManyCheckpointInput[]
    skipDuplicates?: boolean
  }

  export type roadmapsUpsertWithoutCheckpointsInput = {
    update: XOR<roadmapsUpdateWithoutCheckpointsInput, roadmapsUncheckedUpdateWithoutCheckpointsInput>
    create: XOR<roadmapsCreateWithoutCheckpointsInput, roadmapsUncheckedCreateWithoutCheckpointsInput>
    where?: roadmapsWhereInput
  }

  export type roadmapsUpdateToOneWithWhereWithoutCheckpointsInput = {
    where?: roadmapsWhereInput
    data: XOR<roadmapsUpdateWithoutCheckpointsInput, roadmapsUncheckedUpdateWithoutCheckpointsInput>
  }

  export type roadmapsUpdateWithoutCheckpointsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
  }

  export type roadmapsUncheckedUpdateWithoutCheckpointsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
  }

  export type studentLearningProgressUpsertWithWhereUniqueWithoutCheckpointInput = {
    where: studentLearningProgressWhereUniqueInput
    update: XOR<studentLearningProgressUpdateWithoutCheckpointInput, studentLearningProgressUncheckedUpdateWithoutCheckpointInput>
    create: XOR<studentLearningProgressCreateWithoutCheckpointInput, studentLearningProgressUncheckedCreateWithoutCheckpointInput>
  }

  export type studentLearningProgressUpdateWithWhereUniqueWithoutCheckpointInput = {
    where: studentLearningProgressWhereUniqueInput
    data: XOR<studentLearningProgressUpdateWithoutCheckpointInput, studentLearningProgressUncheckedUpdateWithoutCheckpointInput>
  }

  export type studentLearningProgressUpdateManyWithWhereWithoutCheckpointInput = {
    where: studentLearningProgressScalarWhereInput
    data: XOR<studentLearningProgressUpdateManyMutationInput, studentLearningProgressUncheckedUpdateManyWithoutCheckpointInput>
  }

  export type checkpointsCreateWithoutProgressInput = {
    id?: string
    title: string
    description: string
    resourceType: string
    resourceUrl: string
    roadmap: roadmapsCreateNestedOneWithoutCheckpointsInput
  }

  export type checkpointsUncheckedCreateWithoutProgressInput = {
    id?: string
    roadmapId: string
    title: string
    description: string
    resourceType: string
    resourceUrl: string
  }

  export type checkpointsCreateOrConnectWithoutProgressInput = {
    where: checkpointsWhereUniqueInput
    create: XOR<checkpointsCreateWithoutProgressInput, checkpointsUncheckedCreateWithoutProgressInput>
  }

  export type profileCreateWithoutLearningProgressInput = {
    id?: string
    bio?: string | null
    gender?: string | null
    DOB?: Date | string | null
    avatarURL?: string | null
    github?: string | null
    linkedin?: string | null
    skills?: profileCreateskillsInput | string[]
    interests?: profileCreateinterestsInput | string[]
    department?: string | null
    resourceId?: string | null
    certificates?: certificatesCreateNestedManyWithoutStudentInput
    credits?: creditsCreateNestedManyWithoutStudentInput
    internshipApplications?: internship_applicationsCreateNestedManyWithoutStudentInput
    mentorReviews?: mentorReviewsCreateNestedManyWithoutStudentInput
    mentorSessions?: mentorSessionsCreateNestedManyWithoutStudentInput
    portfolioProjects?: portfolioProjectsCreateNestedManyWithoutUserInput
    faculty?: facultyCreateNestedOneWithoutStudentsInput
    institution: institutionsCreateNestedOneWithoutProfilesInput
    user: usersCreateNestedOneWithoutProfilesInput
  }

  export type profileUncheckedCreateWithoutLearningProgressInput = {
    id?: string
    userId: string
    bio?: string | null
    gender?: string | null
    DOB?: Date | string | null
    avatarURL?: string | null
    github?: string | null
    linkedin?: string | null
    skills?: profileCreateskillsInput | string[]
    interests?: profileCreateinterestsInput | string[]
    department?: string | null
    resourceId?: string | null
    instituteId: string
    facultyId?: string | null
    certificates?: certificatesUncheckedCreateNestedManyWithoutStudentInput
    credits?: creditsUncheckedCreateNestedManyWithoutStudentInput
    internshipApplications?: internship_applicationsUncheckedCreateNestedManyWithoutStudentInput
    mentorReviews?: mentorReviewsUncheckedCreateNestedManyWithoutStudentInput
    mentorSessions?: mentorSessionsUncheckedCreateNestedManyWithoutStudentInput
    portfolioProjects?: portfolioProjectsUncheckedCreateNestedManyWithoutUserInput
  }

  export type profileCreateOrConnectWithoutLearningProgressInput = {
    where: profileWhereUniqueInput
    create: XOR<profileCreateWithoutLearningProgressInput, profileUncheckedCreateWithoutLearningProgressInput>
  }

  export type checkpointsUpsertWithoutProgressInput = {
    update: XOR<checkpointsUpdateWithoutProgressInput, checkpointsUncheckedUpdateWithoutProgressInput>
    create: XOR<checkpointsCreateWithoutProgressInput, checkpointsUncheckedCreateWithoutProgressInput>
    where?: checkpointsWhereInput
  }

  export type checkpointsUpdateToOneWithWhereWithoutProgressInput = {
    where?: checkpointsWhereInput
    data: XOR<checkpointsUpdateWithoutProgressInput, checkpointsUncheckedUpdateWithoutProgressInput>
  }

  export type checkpointsUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceUrl?: StringFieldUpdateOperationsInput | string
    roadmap?: roadmapsUpdateOneRequiredWithoutCheckpointsNestedInput
  }

  export type checkpointsUncheckedUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    roadmapId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceUrl?: StringFieldUpdateOperationsInput | string
  }

  export type profileUpsertWithoutLearningProgressInput = {
    update: XOR<profileUpdateWithoutLearningProgressInput, profileUncheckedUpdateWithoutLearningProgressInput>
    create: XOR<profileCreateWithoutLearningProgressInput, profileUncheckedCreateWithoutLearningProgressInput>
    where?: profileWhereInput
  }

  export type profileUpdateToOneWithWhereWithoutLearningProgressInput = {
    where?: profileWhereInput
    data: XOR<profileUpdateWithoutLearningProgressInput, profileUncheckedUpdateWithoutLearningProgressInput>
  }

  export type profileUpdateWithoutLearningProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarURL?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: profileUpdateskillsInput | string[]
    interests?: profileUpdateinterestsInput | string[]
    department?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    certificates?: certificatesUpdateManyWithoutStudentNestedInput
    credits?: creditsUpdateManyWithoutStudentNestedInput
    internshipApplications?: internship_applicationsUpdateManyWithoutStudentNestedInput
    mentorReviews?: mentorReviewsUpdateManyWithoutStudentNestedInput
    mentorSessions?: mentorSessionsUpdateManyWithoutStudentNestedInput
    portfolioProjects?: portfolioProjectsUpdateManyWithoutUserNestedInput
    faculty?: facultyUpdateOneWithoutStudentsNestedInput
    institution?: institutionsUpdateOneRequiredWithoutProfilesNestedInput
    user?: usersUpdateOneRequiredWithoutProfilesNestedInput
  }

  export type profileUncheckedUpdateWithoutLearningProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarURL?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: profileUpdateskillsInput | string[]
    interests?: profileUpdateinterestsInput | string[]
    department?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    instituteId?: StringFieldUpdateOperationsInput | string
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
    certificates?: certificatesUncheckedUpdateManyWithoutStudentNestedInput
    credits?: creditsUncheckedUpdateManyWithoutStudentNestedInput
    internshipApplications?: internship_applicationsUncheckedUpdateManyWithoutStudentNestedInput
    mentorReviews?: mentorReviewsUncheckedUpdateManyWithoutStudentNestedInput
    mentorSessions?: mentorSessionsUncheckedUpdateManyWithoutStudentNestedInput
    portfolioProjects?: portfolioProjectsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type courseEnrollmentsCreateWithoutCourseInput = {
    id?: string
    progressPercent?: number | null
    enrolledAt: Date | string
    user: usersCreateNestedOneWithoutCourseEnrollmentsInput
  }

  export type courseEnrollmentsUncheckedCreateWithoutCourseInput = {
    id?: string
    userId: string
    progressPercent?: number | null
    enrolledAt: Date | string
  }

  export type courseEnrollmentsCreateOrConnectWithoutCourseInput = {
    where: courseEnrollmentsWhereUniqueInput
    create: XOR<courseEnrollmentsCreateWithoutCourseInput, courseEnrollmentsUncheckedCreateWithoutCourseInput>
  }

  export type courseEnrollmentsCreateManyCourseInputEnvelope = {
    data: courseEnrollmentsCreateManyCourseInput | courseEnrollmentsCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutCourses_instructorInput = {
    id?: string
    displayName: string
    role?: usersCreateroleInput | string[]
    email: string
    salt: string
    phone: string
    hashPassword: string
    courseEnrollments?: courseEnrollmentsCreateNestedManyWithoutUserInput
    facultyProfile?: facultyCreateNestedOneWithoutUserInput
    institutions_admin?: institutionsCreateNestedManyWithoutAdminUserInput
    internships_industryUser?: internshipsCreateNestedManyWithoutIndustryUserInput
    mentors?: mentorsCreateNestedOneWithoutUserInput
    profiles?: profileCreateNestedOneWithoutUserInput
    user_notifications?: user_notificationsCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutCourses_instructorInput = {
    id?: string
    displayName: string
    role?: usersCreateroleInput | string[]
    email: string
    salt: string
    phone: string
    hashPassword: string
    courseEnrollments?: courseEnrollmentsUncheckedCreateNestedManyWithoutUserInput
    facultyProfile?: facultyUncheckedCreateNestedOneWithoutUserInput
    institutions_admin?: institutionsUncheckedCreateNestedManyWithoutAdminUserInput
    internships_industryUser?: internshipsUncheckedCreateNestedManyWithoutIndustryUserInput
    mentors?: mentorsUncheckedCreateNestedOneWithoutUserInput
    profiles?: profileUncheckedCreateNestedOneWithoutUserInput
    user_notifications?: user_notificationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutCourses_instructorInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutCourses_instructorInput, usersUncheckedCreateWithoutCourses_instructorInput>
  }

  export type courseEnrollmentsUpsertWithWhereUniqueWithoutCourseInput = {
    where: courseEnrollmentsWhereUniqueInput
    update: XOR<courseEnrollmentsUpdateWithoutCourseInput, courseEnrollmentsUncheckedUpdateWithoutCourseInput>
    create: XOR<courseEnrollmentsCreateWithoutCourseInput, courseEnrollmentsUncheckedCreateWithoutCourseInput>
  }

  export type courseEnrollmentsUpdateWithWhereUniqueWithoutCourseInput = {
    where: courseEnrollmentsWhereUniqueInput
    data: XOR<courseEnrollmentsUpdateWithoutCourseInput, courseEnrollmentsUncheckedUpdateWithoutCourseInput>
  }

  export type courseEnrollmentsUpdateManyWithWhereWithoutCourseInput = {
    where: courseEnrollmentsScalarWhereInput
    data: XOR<courseEnrollmentsUpdateManyMutationInput, courseEnrollmentsUncheckedUpdateManyWithoutCourseInput>
  }

  export type usersUpsertWithoutCourses_instructorInput = {
    update: XOR<usersUpdateWithoutCourses_instructorInput, usersUncheckedUpdateWithoutCourses_instructorInput>
    create: XOR<usersCreateWithoutCourses_instructorInput, usersUncheckedCreateWithoutCourses_instructorInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutCourses_instructorInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutCourses_instructorInput, usersUncheckedUpdateWithoutCourses_instructorInput>
  }

  export type usersUpdateWithoutCourses_instructorInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    role?: usersUpdateroleInput | string[]
    email?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    hashPassword?: StringFieldUpdateOperationsInput | string
    courseEnrollments?: courseEnrollmentsUpdateManyWithoutUserNestedInput
    facultyProfile?: facultyUpdateOneWithoutUserNestedInput
    institutions_admin?: institutionsUpdateManyWithoutAdminUserNestedInput
    internships_industryUser?: internshipsUpdateManyWithoutIndustryUserNestedInput
    mentors?: mentorsUpdateOneWithoutUserNestedInput
    profiles?: profileUpdateOneWithoutUserNestedInput
    user_notifications?: user_notificationsUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutCourses_instructorInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    role?: usersUpdateroleInput | string[]
    email?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    hashPassword?: StringFieldUpdateOperationsInput | string
    courseEnrollments?: courseEnrollmentsUncheckedUpdateManyWithoutUserNestedInput
    facultyProfile?: facultyUncheckedUpdateOneWithoutUserNestedInput
    institutions_admin?: institutionsUncheckedUpdateManyWithoutAdminUserNestedInput
    internships_industryUser?: internshipsUncheckedUpdateManyWithoutIndustryUserNestedInput
    mentors?: mentorsUncheckedUpdateOneWithoutUserNestedInput
    profiles?: profileUncheckedUpdateOneWithoutUserNestedInput
    user_notifications?: user_notificationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type coursesCreateWithoutEnrollmentsInput = {
    id?: string
    title: string
    description: string
    type: $Enums.CourseType
    price?: number | null
    thumbnail_url?: string | null
    created_at: Date | string
    instructor: usersCreateNestedOneWithoutCourses_instructorInput
  }

  export type coursesUncheckedCreateWithoutEnrollmentsInput = {
    id?: string
    title: string
    description: string
    type: $Enums.CourseType
    price?: number | null
    instructorId: string
    thumbnail_url?: string | null
    created_at: Date | string
  }

  export type coursesCreateOrConnectWithoutEnrollmentsInput = {
    where: coursesWhereUniqueInput
    create: XOR<coursesCreateWithoutEnrollmentsInput, coursesUncheckedCreateWithoutEnrollmentsInput>
  }

  export type usersCreateWithoutCourseEnrollmentsInput = {
    id?: string
    displayName: string
    role?: usersCreateroleInput | string[]
    email: string
    salt: string
    phone: string
    hashPassword: string
    courses_instructor?: coursesCreateNestedManyWithoutInstructorInput
    facultyProfile?: facultyCreateNestedOneWithoutUserInput
    institutions_admin?: institutionsCreateNestedManyWithoutAdminUserInput
    internships_industryUser?: internshipsCreateNestedManyWithoutIndustryUserInput
    mentors?: mentorsCreateNestedOneWithoutUserInput
    profiles?: profileCreateNestedOneWithoutUserInput
    user_notifications?: user_notificationsCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutCourseEnrollmentsInput = {
    id?: string
    displayName: string
    role?: usersCreateroleInput | string[]
    email: string
    salt: string
    phone: string
    hashPassword: string
    courses_instructor?: coursesUncheckedCreateNestedManyWithoutInstructorInput
    facultyProfile?: facultyUncheckedCreateNestedOneWithoutUserInput
    institutions_admin?: institutionsUncheckedCreateNestedManyWithoutAdminUserInput
    internships_industryUser?: internshipsUncheckedCreateNestedManyWithoutIndustryUserInput
    mentors?: mentorsUncheckedCreateNestedOneWithoutUserInput
    profiles?: profileUncheckedCreateNestedOneWithoutUserInput
    user_notifications?: user_notificationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutCourseEnrollmentsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutCourseEnrollmentsInput, usersUncheckedCreateWithoutCourseEnrollmentsInput>
  }

  export type coursesUpsertWithoutEnrollmentsInput = {
    update: XOR<coursesUpdateWithoutEnrollmentsInput, coursesUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<coursesCreateWithoutEnrollmentsInput, coursesUncheckedCreateWithoutEnrollmentsInput>
    where?: coursesWhereInput
  }

  export type coursesUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: coursesWhereInput
    data: XOR<coursesUpdateWithoutEnrollmentsInput, coursesUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type coursesUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    instructor?: usersUpdateOneRequiredWithoutCourses_instructorNestedInput
  }

  export type coursesUncheckedUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    instructorId?: StringFieldUpdateOperationsInput | string
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUpsertWithoutCourseEnrollmentsInput = {
    update: XOR<usersUpdateWithoutCourseEnrollmentsInput, usersUncheckedUpdateWithoutCourseEnrollmentsInput>
    create: XOR<usersCreateWithoutCourseEnrollmentsInput, usersUncheckedCreateWithoutCourseEnrollmentsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutCourseEnrollmentsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutCourseEnrollmentsInput, usersUncheckedUpdateWithoutCourseEnrollmentsInput>
  }

  export type usersUpdateWithoutCourseEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    role?: usersUpdateroleInput | string[]
    email?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    hashPassword?: StringFieldUpdateOperationsInput | string
    courses_instructor?: coursesUpdateManyWithoutInstructorNestedInput
    facultyProfile?: facultyUpdateOneWithoutUserNestedInput
    institutions_admin?: institutionsUpdateManyWithoutAdminUserNestedInput
    internships_industryUser?: internshipsUpdateManyWithoutIndustryUserNestedInput
    mentors?: mentorsUpdateOneWithoutUserNestedInput
    profiles?: profileUpdateOneWithoutUserNestedInput
    user_notifications?: user_notificationsUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutCourseEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    role?: usersUpdateroleInput | string[]
    email?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    hashPassword?: StringFieldUpdateOperationsInput | string
    courses_instructor?: coursesUncheckedUpdateManyWithoutInstructorNestedInput
    facultyProfile?: facultyUncheckedUpdateOneWithoutUserNestedInput
    institutions_admin?: institutionsUncheckedUpdateManyWithoutAdminUserNestedInput
    internships_industryUser?: internshipsUncheckedUpdateManyWithoutIndustryUserNestedInput
    mentors?: mentorsUncheckedUpdateOneWithoutUserNestedInput
    profiles?: profileUncheckedUpdateOneWithoutUserNestedInput
    user_notifications?: user_notificationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type mentorReviewsCreateWithoutMentorInput = {
    id?: string
    rating: number
    reviews?: string | null
    student: profileCreateNestedOneWithoutMentorReviewsInput
  }

  export type mentorReviewsUncheckedCreateWithoutMentorInput = {
    id?: string
    rating: number
    reviews?: string | null
    studentId: string
  }

  export type mentorReviewsCreateOrConnectWithoutMentorInput = {
    where: mentorReviewsWhereUniqueInput
    create: XOR<mentorReviewsCreateWithoutMentorInput, mentorReviewsUncheckedCreateWithoutMentorInput>
  }

  export type mentorReviewsCreateManyMentorInputEnvelope = {
    data: mentorReviewsCreateManyMentorInput | mentorReviewsCreateManyMentorInput[]
    skipDuplicates?: boolean
  }

  export type mentorSessionsCreateWithoutMentorInput = {
    id?: string
    scheduled_at: Date | string
    status: $Enums.MentorSessionStatus
    meeting_link?: string | null
    student: profileCreateNestedOneWithoutMentorSessionsInput
  }

  export type mentorSessionsUncheckedCreateWithoutMentorInput = {
    id?: string
    studentId: string
    scheduled_at: Date | string
    status: $Enums.MentorSessionStatus
    meeting_link?: string | null
  }

  export type mentorSessionsCreateOrConnectWithoutMentorInput = {
    where: mentorSessionsWhereUniqueInput
    create: XOR<mentorSessionsCreateWithoutMentorInput, mentorSessionsUncheckedCreateWithoutMentorInput>
  }

  export type mentorSessionsCreateManyMentorInputEnvelope = {
    data: mentorSessionsCreateManyMentorInput | mentorSessionsCreateManyMentorInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutMentorsInput = {
    id?: string
    displayName: string
    role?: usersCreateroleInput | string[]
    email: string
    salt: string
    phone: string
    hashPassword: string
    courseEnrollments?: courseEnrollmentsCreateNestedManyWithoutUserInput
    courses_instructor?: coursesCreateNestedManyWithoutInstructorInput
    facultyProfile?: facultyCreateNestedOneWithoutUserInput
    institutions_admin?: institutionsCreateNestedManyWithoutAdminUserInput
    internships_industryUser?: internshipsCreateNestedManyWithoutIndustryUserInput
    profiles?: profileCreateNestedOneWithoutUserInput
    user_notifications?: user_notificationsCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutMentorsInput = {
    id?: string
    displayName: string
    role?: usersCreateroleInput | string[]
    email: string
    salt: string
    phone: string
    hashPassword: string
    courseEnrollments?: courseEnrollmentsUncheckedCreateNestedManyWithoutUserInput
    courses_instructor?: coursesUncheckedCreateNestedManyWithoutInstructorInput
    facultyProfile?: facultyUncheckedCreateNestedOneWithoutUserInput
    institutions_admin?: institutionsUncheckedCreateNestedManyWithoutAdminUserInput
    internships_industryUser?: internshipsUncheckedCreateNestedManyWithoutIndustryUserInput
    profiles?: profileUncheckedCreateNestedOneWithoutUserInput
    user_notifications?: user_notificationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutMentorsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutMentorsInput, usersUncheckedCreateWithoutMentorsInput>
  }

  export type mentorReviewsUpsertWithWhereUniqueWithoutMentorInput = {
    where: mentorReviewsWhereUniqueInput
    update: XOR<mentorReviewsUpdateWithoutMentorInput, mentorReviewsUncheckedUpdateWithoutMentorInput>
    create: XOR<mentorReviewsCreateWithoutMentorInput, mentorReviewsUncheckedCreateWithoutMentorInput>
  }

  export type mentorReviewsUpdateWithWhereUniqueWithoutMentorInput = {
    where: mentorReviewsWhereUniqueInput
    data: XOR<mentorReviewsUpdateWithoutMentorInput, mentorReviewsUncheckedUpdateWithoutMentorInput>
  }

  export type mentorReviewsUpdateManyWithWhereWithoutMentorInput = {
    where: mentorReviewsScalarWhereInput
    data: XOR<mentorReviewsUpdateManyMutationInput, mentorReviewsUncheckedUpdateManyWithoutMentorInput>
  }

  export type mentorSessionsUpsertWithWhereUniqueWithoutMentorInput = {
    where: mentorSessionsWhereUniqueInput
    update: XOR<mentorSessionsUpdateWithoutMentorInput, mentorSessionsUncheckedUpdateWithoutMentorInput>
    create: XOR<mentorSessionsCreateWithoutMentorInput, mentorSessionsUncheckedCreateWithoutMentorInput>
  }

  export type mentorSessionsUpdateWithWhereUniqueWithoutMentorInput = {
    where: mentorSessionsWhereUniqueInput
    data: XOR<mentorSessionsUpdateWithoutMentorInput, mentorSessionsUncheckedUpdateWithoutMentorInput>
  }

  export type mentorSessionsUpdateManyWithWhereWithoutMentorInput = {
    where: mentorSessionsScalarWhereInput
    data: XOR<mentorSessionsUpdateManyMutationInput, mentorSessionsUncheckedUpdateManyWithoutMentorInput>
  }

  export type usersUpsertWithoutMentorsInput = {
    update: XOR<usersUpdateWithoutMentorsInput, usersUncheckedUpdateWithoutMentorsInput>
    create: XOR<usersCreateWithoutMentorsInput, usersUncheckedCreateWithoutMentorsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutMentorsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutMentorsInput, usersUncheckedUpdateWithoutMentorsInput>
  }

  export type usersUpdateWithoutMentorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    role?: usersUpdateroleInput | string[]
    email?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    hashPassword?: StringFieldUpdateOperationsInput | string
    courseEnrollments?: courseEnrollmentsUpdateManyWithoutUserNestedInput
    courses_instructor?: coursesUpdateManyWithoutInstructorNestedInput
    facultyProfile?: facultyUpdateOneWithoutUserNestedInput
    institutions_admin?: institutionsUpdateManyWithoutAdminUserNestedInput
    internships_industryUser?: internshipsUpdateManyWithoutIndustryUserNestedInput
    profiles?: profileUpdateOneWithoutUserNestedInput
    user_notifications?: user_notificationsUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutMentorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    role?: usersUpdateroleInput | string[]
    email?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    hashPassword?: StringFieldUpdateOperationsInput | string
    courseEnrollments?: courseEnrollmentsUncheckedUpdateManyWithoutUserNestedInput
    courses_instructor?: coursesUncheckedUpdateManyWithoutInstructorNestedInput
    facultyProfile?: facultyUncheckedUpdateOneWithoutUserNestedInput
    institutions_admin?: institutionsUncheckedUpdateManyWithoutAdminUserNestedInput
    internships_industryUser?: internshipsUncheckedUpdateManyWithoutIndustryUserNestedInput
    profiles?: profileUncheckedUpdateOneWithoutUserNestedInput
    user_notifications?: user_notificationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type mentorsCreateWithoutSessionsInput = {
    id?: string
    expertise?: NullableJsonNullValueInput | InputJsonValue
    rating?: number | null
    bio?: string | null
    reviews?: mentorReviewsCreateNestedManyWithoutMentorInput
    user: usersCreateNestedOneWithoutMentorsInput
  }

  export type mentorsUncheckedCreateWithoutSessionsInput = {
    id?: string
    user_id: string
    expertise?: NullableJsonNullValueInput | InputJsonValue
    rating?: number | null
    bio?: string | null
    reviews?: mentorReviewsUncheckedCreateNestedManyWithoutMentorInput
  }

  export type mentorsCreateOrConnectWithoutSessionsInput = {
    where: mentorsWhereUniqueInput
    create: XOR<mentorsCreateWithoutSessionsInput, mentorsUncheckedCreateWithoutSessionsInput>
  }

  export type profileCreateWithoutMentorSessionsInput = {
    id?: string
    bio?: string | null
    gender?: string | null
    DOB?: Date | string | null
    avatarURL?: string | null
    github?: string | null
    linkedin?: string | null
    skills?: profileCreateskillsInput | string[]
    interests?: profileCreateinterestsInput | string[]
    department?: string | null
    resourceId?: string | null
    certificates?: certificatesCreateNestedManyWithoutStudentInput
    credits?: creditsCreateNestedManyWithoutStudentInput
    internshipApplications?: internship_applicationsCreateNestedManyWithoutStudentInput
    mentorReviews?: mentorReviewsCreateNestedManyWithoutStudentInput
    portfolioProjects?: portfolioProjectsCreateNestedManyWithoutUserInput
    faculty?: facultyCreateNestedOneWithoutStudentsInput
    institution: institutionsCreateNestedOneWithoutProfilesInput
    user: usersCreateNestedOneWithoutProfilesInput
    learningProgress?: studentLearningProgressCreateNestedManyWithoutProfileInput
  }

  export type profileUncheckedCreateWithoutMentorSessionsInput = {
    id?: string
    userId: string
    bio?: string | null
    gender?: string | null
    DOB?: Date | string | null
    avatarURL?: string | null
    github?: string | null
    linkedin?: string | null
    skills?: profileCreateskillsInput | string[]
    interests?: profileCreateinterestsInput | string[]
    department?: string | null
    resourceId?: string | null
    instituteId: string
    facultyId?: string | null
    certificates?: certificatesUncheckedCreateNestedManyWithoutStudentInput
    credits?: creditsUncheckedCreateNestedManyWithoutStudentInput
    internshipApplications?: internship_applicationsUncheckedCreateNestedManyWithoutStudentInput
    mentorReviews?: mentorReviewsUncheckedCreateNestedManyWithoutStudentInput
    portfolioProjects?: portfolioProjectsUncheckedCreateNestedManyWithoutUserInput
    learningProgress?: studentLearningProgressUncheckedCreateNestedManyWithoutProfileInput
  }

  export type profileCreateOrConnectWithoutMentorSessionsInput = {
    where: profileWhereUniqueInput
    create: XOR<profileCreateWithoutMentorSessionsInput, profileUncheckedCreateWithoutMentorSessionsInput>
  }

  export type mentorsUpsertWithoutSessionsInput = {
    update: XOR<mentorsUpdateWithoutSessionsInput, mentorsUncheckedUpdateWithoutSessionsInput>
    create: XOR<mentorsCreateWithoutSessionsInput, mentorsUncheckedCreateWithoutSessionsInput>
    where?: mentorsWhereInput
  }

  export type mentorsUpdateToOneWithWhereWithoutSessionsInput = {
    where?: mentorsWhereInput
    data: XOR<mentorsUpdateWithoutSessionsInput, mentorsUncheckedUpdateWithoutSessionsInput>
  }

  export type mentorsUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    expertise?: NullableJsonNullValueInput | InputJsonValue
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    reviews?: mentorReviewsUpdateManyWithoutMentorNestedInput
    user?: usersUpdateOneRequiredWithoutMentorsNestedInput
  }

  export type mentorsUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    expertise?: NullableJsonNullValueInput | InputJsonValue
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    reviews?: mentorReviewsUncheckedUpdateManyWithoutMentorNestedInput
  }

  export type profileUpsertWithoutMentorSessionsInput = {
    update: XOR<profileUpdateWithoutMentorSessionsInput, profileUncheckedUpdateWithoutMentorSessionsInput>
    create: XOR<profileCreateWithoutMentorSessionsInput, profileUncheckedCreateWithoutMentorSessionsInput>
    where?: profileWhereInput
  }

  export type profileUpdateToOneWithWhereWithoutMentorSessionsInput = {
    where?: profileWhereInput
    data: XOR<profileUpdateWithoutMentorSessionsInput, profileUncheckedUpdateWithoutMentorSessionsInput>
  }

  export type profileUpdateWithoutMentorSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarURL?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: profileUpdateskillsInput | string[]
    interests?: profileUpdateinterestsInput | string[]
    department?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    certificates?: certificatesUpdateManyWithoutStudentNestedInput
    credits?: creditsUpdateManyWithoutStudentNestedInput
    internshipApplications?: internship_applicationsUpdateManyWithoutStudentNestedInput
    mentorReviews?: mentorReviewsUpdateManyWithoutStudentNestedInput
    portfolioProjects?: portfolioProjectsUpdateManyWithoutUserNestedInput
    faculty?: facultyUpdateOneWithoutStudentsNestedInput
    institution?: institutionsUpdateOneRequiredWithoutProfilesNestedInput
    user?: usersUpdateOneRequiredWithoutProfilesNestedInput
    learningProgress?: studentLearningProgressUpdateManyWithoutProfileNestedInput
  }

  export type profileUncheckedUpdateWithoutMentorSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarURL?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: profileUpdateskillsInput | string[]
    interests?: profileUpdateinterestsInput | string[]
    department?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    instituteId?: StringFieldUpdateOperationsInput | string
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
    certificates?: certificatesUncheckedUpdateManyWithoutStudentNestedInput
    credits?: creditsUncheckedUpdateManyWithoutStudentNestedInput
    internshipApplications?: internship_applicationsUncheckedUpdateManyWithoutStudentNestedInput
    mentorReviews?: mentorReviewsUncheckedUpdateManyWithoutStudentNestedInput
    portfolioProjects?: portfolioProjectsUncheckedUpdateManyWithoutUserNestedInput
    learningProgress?: studentLearningProgressUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type mentorsCreateWithoutReviewsInput = {
    id?: string
    expertise?: NullableJsonNullValueInput | InputJsonValue
    rating?: number | null
    bio?: string | null
    sessions?: mentorSessionsCreateNestedManyWithoutMentorInput
    user: usersCreateNestedOneWithoutMentorsInput
  }

  export type mentorsUncheckedCreateWithoutReviewsInput = {
    id?: string
    user_id: string
    expertise?: NullableJsonNullValueInput | InputJsonValue
    rating?: number | null
    bio?: string | null
    sessions?: mentorSessionsUncheckedCreateNestedManyWithoutMentorInput
  }

  export type mentorsCreateOrConnectWithoutReviewsInput = {
    where: mentorsWhereUniqueInput
    create: XOR<mentorsCreateWithoutReviewsInput, mentorsUncheckedCreateWithoutReviewsInput>
  }

  export type profileCreateWithoutMentorReviewsInput = {
    id?: string
    bio?: string | null
    gender?: string | null
    DOB?: Date | string | null
    avatarURL?: string | null
    github?: string | null
    linkedin?: string | null
    skills?: profileCreateskillsInput | string[]
    interests?: profileCreateinterestsInput | string[]
    department?: string | null
    resourceId?: string | null
    certificates?: certificatesCreateNestedManyWithoutStudentInput
    credits?: creditsCreateNestedManyWithoutStudentInput
    internshipApplications?: internship_applicationsCreateNestedManyWithoutStudentInput
    mentorSessions?: mentorSessionsCreateNestedManyWithoutStudentInput
    portfolioProjects?: portfolioProjectsCreateNestedManyWithoutUserInput
    faculty?: facultyCreateNestedOneWithoutStudentsInput
    institution: institutionsCreateNestedOneWithoutProfilesInput
    user: usersCreateNestedOneWithoutProfilesInput
    learningProgress?: studentLearningProgressCreateNestedManyWithoutProfileInput
  }

  export type profileUncheckedCreateWithoutMentorReviewsInput = {
    id?: string
    userId: string
    bio?: string | null
    gender?: string | null
    DOB?: Date | string | null
    avatarURL?: string | null
    github?: string | null
    linkedin?: string | null
    skills?: profileCreateskillsInput | string[]
    interests?: profileCreateinterestsInput | string[]
    department?: string | null
    resourceId?: string | null
    instituteId: string
    facultyId?: string | null
    certificates?: certificatesUncheckedCreateNestedManyWithoutStudentInput
    credits?: creditsUncheckedCreateNestedManyWithoutStudentInput
    internshipApplications?: internship_applicationsUncheckedCreateNestedManyWithoutStudentInput
    mentorSessions?: mentorSessionsUncheckedCreateNestedManyWithoutStudentInput
    portfolioProjects?: portfolioProjectsUncheckedCreateNestedManyWithoutUserInput
    learningProgress?: studentLearningProgressUncheckedCreateNestedManyWithoutProfileInput
  }

  export type profileCreateOrConnectWithoutMentorReviewsInput = {
    where: profileWhereUniqueInput
    create: XOR<profileCreateWithoutMentorReviewsInput, profileUncheckedCreateWithoutMentorReviewsInput>
  }

  export type mentorsUpsertWithoutReviewsInput = {
    update: XOR<mentorsUpdateWithoutReviewsInput, mentorsUncheckedUpdateWithoutReviewsInput>
    create: XOR<mentorsCreateWithoutReviewsInput, mentorsUncheckedCreateWithoutReviewsInput>
    where?: mentorsWhereInput
  }

  export type mentorsUpdateToOneWithWhereWithoutReviewsInput = {
    where?: mentorsWhereInput
    data: XOR<mentorsUpdateWithoutReviewsInput, mentorsUncheckedUpdateWithoutReviewsInput>
  }

  export type mentorsUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    expertise?: NullableJsonNullValueInput | InputJsonValue
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: mentorSessionsUpdateManyWithoutMentorNestedInput
    user?: usersUpdateOneRequiredWithoutMentorsNestedInput
  }

  export type mentorsUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    expertise?: NullableJsonNullValueInput | InputJsonValue
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: mentorSessionsUncheckedUpdateManyWithoutMentorNestedInput
  }

  export type profileUpsertWithoutMentorReviewsInput = {
    update: XOR<profileUpdateWithoutMentorReviewsInput, profileUncheckedUpdateWithoutMentorReviewsInput>
    create: XOR<profileCreateWithoutMentorReviewsInput, profileUncheckedCreateWithoutMentorReviewsInput>
    where?: profileWhereInput
  }

  export type profileUpdateToOneWithWhereWithoutMentorReviewsInput = {
    where?: profileWhereInput
    data: XOR<profileUpdateWithoutMentorReviewsInput, profileUncheckedUpdateWithoutMentorReviewsInput>
  }

  export type profileUpdateWithoutMentorReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarURL?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: profileUpdateskillsInput | string[]
    interests?: profileUpdateinterestsInput | string[]
    department?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    certificates?: certificatesUpdateManyWithoutStudentNestedInput
    credits?: creditsUpdateManyWithoutStudentNestedInput
    internshipApplications?: internship_applicationsUpdateManyWithoutStudentNestedInput
    mentorSessions?: mentorSessionsUpdateManyWithoutStudentNestedInput
    portfolioProjects?: portfolioProjectsUpdateManyWithoutUserNestedInput
    faculty?: facultyUpdateOneWithoutStudentsNestedInput
    institution?: institutionsUpdateOneRequiredWithoutProfilesNestedInput
    user?: usersUpdateOneRequiredWithoutProfilesNestedInput
    learningProgress?: studentLearningProgressUpdateManyWithoutProfileNestedInput
  }

  export type profileUncheckedUpdateWithoutMentorReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarURL?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: profileUpdateskillsInput | string[]
    interests?: profileUpdateinterestsInput | string[]
    department?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    instituteId?: StringFieldUpdateOperationsInput | string
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
    certificates?: certificatesUncheckedUpdateManyWithoutStudentNestedInput
    credits?: creditsUncheckedUpdateManyWithoutStudentNestedInput
    internshipApplications?: internship_applicationsUncheckedUpdateManyWithoutStudentNestedInput
    mentorSessions?: mentorSessionsUncheckedUpdateManyWithoutStudentNestedInput
    portfolioProjects?: portfolioProjectsUncheckedUpdateManyWithoutUserNestedInput
    learningProgress?: studentLearningProgressUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type profileCreateWithoutPortfolioProjectsInput = {
    id?: string
    bio?: string | null
    gender?: string | null
    DOB?: Date | string | null
    avatarURL?: string | null
    github?: string | null
    linkedin?: string | null
    skills?: profileCreateskillsInput | string[]
    interests?: profileCreateinterestsInput | string[]
    department?: string | null
    resourceId?: string | null
    certificates?: certificatesCreateNestedManyWithoutStudentInput
    credits?: creditsCreateNestedManyWithoutStudentInput
    internshipApplications?: internship_applicationsCreateNestedManyWithoutStudentInput
    mentorReviews?: mentorReviewsCreateNestedManyWithoutStudentInput
    mentorSessions?: mentorSessionsCreateNestedManyWithoutStudentInput
    faculty?: facultyCreateNestedOneWithoutStudentsInput
    institution: institutionsCreateNestedOneWithoutProfilesInput
    user: usersCreateNestedOneWithoutProfilesInput
    learningProgress?: studentLearningProgressCreateNestedManyWithoutProfileInput
  }

  export type profileUncheckedCreateWithoutPortfolioProjectsInput = {
    id?: string
    userId: string
    bio?: string | null
    gender?: string | null
    DOB?: Date | string | null
    avatarURL?: string | null
    github?: string | null
    linkedin?: string | null
    skills?: profileCreateskillsInput | string[]
    interests?: profileCreateinterestsInput | string[]
    department?: string | null
    resourceId?: string | null
    instituteId: string
    facultyId?: string | null
    certificates?: certificatesUncheckedCreateNestedManyWithoutStudentInput
    credits?: creditsUncheckedCreateNestedManyWithoutStudentInput
    internshipApplications?: internship_applicationsUncheckedCreateNestedManyWithoutStudentInput
    mentorReviews?: mentorReviewsUncheckedCreateNestedManyWithoutStudentInput
    mentorSessions?: mentorSessionsUncheckedCreateNestedManyWithoutStudentInput
    learningProgress?: studentLearningProgressUncheckedCreateNestedManyWithoutProfileInput
  }

  export type profileCreateOrConnectWithoutPortfolioProjectsInput = {
    where: profileWhereUniqueInput
    create: XOR<profileCreateWithoutPortfolioProjectsInput, profileUncheckedCreateWithoutPortfolioProjectsInput>
  }

  export type profileUpsertWithoutPortfolioProjectsInput = {
    update: XOR<profileUpdateWithoutPortfolioProjectsInput, profileUncheckedUpdateWithoutPortfolioProjectsInput>
    create: XOR<profileCreateWithoutPortfolioProjectsInput, profileUncheckedCreateWithoutPortfolioProjectsInput>
    where?: profileWhereInput
  }

  export type profileUpdateToOneWithWhereWithoutPortfolioProjectsInput = {
    where?: profileWhereInput
    data: XOR<profileUpdateWithoutPortfolioProjectsInput, profileUncheckedUpdateWithoutPortfolioProjectsInput>
  }

  export type profileUpdateWithoutPortfolioProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarURL?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: profileUpdateskillsInput | string[]
    interests?: profileUpdateinterestsInput | string[]
    department?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    certificates?: certificatesUpdateManyWithoutStudentNestedInput
    credits?: creditsUpdateManyWithoutStudentNestedInput
    internshipApplications?: internship_applicationsUpdateManyWithoutStudentNestedInput
    mentorReviews?: mentorReviewsUpdateManyWithoutStudentNestedInput
    mentorSessions?: mentorSessionsUpdateManyWithoutStudentNestedInput
    faculty?: facultyUpdateOneWithoutStudentsNestedInput
    institution?: institutionsUpdateOneRequiredWithoutProfilesNestedInput
    user?: usersUpdateOneRequiredWithoutProfilesNestedInput
    learningProgress?: studentLearningProgressUpdateManyWithoutProfileNestedInput
  }

  export type profileUncheckedUpdateWithoutPortfolioProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarURL?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: profileUpdateskillsInput | string[]
    interests?: profileUpdateinterestsInput | string[]
    department?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    instituteId?: StringFieldUpdateOperationsInput | string
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
    certificates?: certificatesUncheckedUpdateManyWithoutStudentNestedInput
    credits?: creditsUncheckedUpdateManyWithoutStudentNestedInput
    internshipApplications?: internship_applicationsUncheckedUpdateManyWithoutStudentNestedInput
    mentorReviews?: mentorReviewsUncheckedUpdateManyWithoutStudentNestedInput
    mentorSessions?: mentorSessionsUncheckedUpdateManyWithoutStudentNestedInput
    learningProgress?: studentLearningProgressUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type internship_applicationsCreateWithoutInternshipInput = {
    id?: string
    status: $Enums.InternshipStatus
    submission_url?: string | null
    score?: number | null
    applied_at: Date | string
    student: profileCreateNestedOneWithoutInternshipApplicationsInput
    evaluations?: internship_evaluationCreateNestedManyWithoutApplicationInput
    logbookEntries?: logbook_entriesCreateNestedManyWithoutApplicationInput
  }

  export type internship_applicationsUncheckedCreateWithoutInternshipInput = {
    id?: string
    student_id: string
    status: $Enums.InternshipStatus
    submission_url?: string | null
    score?: number | null
    applied_at: Date | string
    evaluations?: internship_evaluationUncheckedCreateNestedManyWithoutApplicationInput
    logbookEntries?: logbook_entriesUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type internship_applicationsCreateOrConnectWithoutInternshipInput = {
    where: internship_applicationsWhereUniqueInput
    create: XOR<internship_applicationsCreateWithoutInternshipInput, internship_applicationsUncheckedCreateWithoutInternshipInput>
  }

  export type internship_applicationsCreateManyInternshipInputEnvelope = {
    data: internship_applicationsCreateManyInternshipInput | internship_applicationsCreateManyInternshipInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutInternships_industryUserInput = {
    id?: string
    displayName: string
    role?: usersCreateroleInput | string[]
    email: string
    salt: string
    phone: string
    hashPassword: string
    courseEnrollments?: courseEnrollmentsCreateNestedManyWithoutUserInput
    courses_instructor?: coursesCreateNestedManyWithoutInstructorInput
    facultyProfile?: facultyCreateNestedOneWithoutUserInput
    institutions_admin?: institutionsCreateNestedManyWithoutAdminUserInput
    mentors?: mentorsCreateNestedOneWithoutUserInput
    profiles?: profileCreateNestedOneWithoutUserInput
    user_notifications?: user_notificationsCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutInternships_industryUserInput = {
    id?: string
    displayName: string
    role?: usersCreateroleInput | string[]
    email: string
    salt: string
    phone: string
    hashPassword: string
    courseEnrollments?: courseEnrollmentsUncheckedCreateNestedManyWithoutUserInput
    courses_instructor?: coursesUncheckedCreateNestedManyWithoutInstructorInput
    facultyProfile?: facultyUncheckedCreateNestedOneWithoutUserInput
    institutions_admin?: institutionsUncheckedCreateNestedManyWithoutAdminUserInput
    mentors?: mentorsUncheckedCreateNestedOneWithoutUserInput
    profiles?: profileUncheckedCreateNestedOneWithoutUserInput
    user_notifications?: user_notificationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutInternships_industryUserInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutInternships_industryUserInput, usersUncheckedCreateWithoutInternships_industryUserInput>
  }

  export type internship_applicationsUpsertWithWhereUniqueWithoutInternshipInput = {
    where: internship_applicationsWhereUniqueInput
    update: XOR<internship_applicationsUpdateWithoutInternshipInput, internship_applicationsUncheckedUpdateWithoutInternshipInput>
    create: XOR<internship_applicationsCreateWithoutInternshipInput, internship_applicationsUncheckedCreateWithoutInternshipInput>
  }

  export type internship_applicationsUpdateWithWhereUniqueWithoutInternshipInput = {
    where: internship_applicationsWhereUniqueInput
    data: XOR<internship_applicationsUpdateWithoutInternshipInput, internship_applicationsUncheckedUpdateWithoutInternshipInput>
  }

  export type internship_applicationsUpdateManyWithWhereWithoutInternshipInput = {
    where: internship_applicationsScalarWhereInput
    data: XOR<internship_applicationsUpdateManyMutationInput, internship_applicationsUncheckedUpdateManyWithoutInternshipInput>
  }

  export type usersUpsertWithoutInternships_industryUserInput = {
    update: XOR<usersUpdateWithoutInternships_industryUserInput, usersUncheckedUpdateWithoutInternships_industryUserInput>
    create: XOR<usersCreateWithoutInternships_industryUserInput, usersUncheckedCreateWithoutInternships_industryUserInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutInternships_industryUserInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutInternships_industryUserInput, usersUncheckedUpdateWithoutInternships_industryUserInput>
  }

  export type usersUpdateWithoutInternships_industryUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    role?: usersUpdateroleInput | string[]
    email?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    hashPassword?: StringFieldUpdateOperationsInput | string
    courseEnrollments?: courseEnrollmentsUpdateManyWithoutUserNestedInput
    courses_instructor?: coursesUpdateManyWithoutInstructorNestedInput
    facultyProfile?: facultyUpdateOneWithoutUserNestedInput
    institutions_admin?: institutionsUpdateManyWithoutAdminUserNestedInput
    mentors?: mentorsUpdateOneWithoutUserNestedInput
    profiles?: profileUpdateOneWithoutUserNestedInput
    user_notifications?: user_notificationsUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutInternships_industryUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    role?: usersUpdateroleInput | string[]
    email?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    hashPassword?: StringFieldUpdateOperationsInput | string
    courseEnrollments?: courseEnrollmentsUncheckedUpdateManyWithoutUserNestedInput
    courses_instructor?: coursesUncheckedUpdateManyWithoutInstructorNestedInput
    facultyProfile?: facultyUncheckedUpdateOneWithoutUserNestedInput
    institutions_admin?: institutionsUncheckedUpdateManyWithoutAdminUserNestedInput
    mentors?: mentorsUncheckedUpdateOneWithoutUserNestedInput
    profiles?: profileUncheckedUpdateOneWithoutUserNestedInput
    user_notifications?: user_notificationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type internshipsCreateWithoutApplicationsInput = {
    id?: string
    title: string
    description: string
    type: string
    stipend?: number | null
    location: string
    required_skills: JsonNullValueInput | InputJsonValue
    duration_weeks: number
    created_at: Date | string
    industryUser: usersCreateNestedOneWithoutInternships_industryUserInput
  }

  export type internshipsUncheckedCreateWithoutApplicationsInput = {
    id?: string
    industry_user_id: string
    title: string
    description: string
    type: string
    stipend?: number | null
    location: string
    required_skills: JsonNullValueInput | InputJsonValue
    duration_weeks: number
    created_at: Date | string
  }

  export type internshipsCreateOrConnectWithoutApplicationsInput = {
    where: internshipsWhereUniqueInput
    create: XOR<internshipsCreateWithoutApplicationsInput, internshipsUncheckedCreateWithoutApplicationsInput>
  }

  export type profileCreateWithoutInternshipApplicationsInput = {
    id?: string
    bio?: string | null
    gender?: string | null
    DOB?: Date | string | null
    avatarURL?: string | null
    github?: string | null
    linkedin?: string | null
    skills?: profileCreateskillsInput | string[]
    interests?: profileCreateinterestsInput | string[]
    department?: string | null
    resourceId?: string | null
    certificates?: certificatesCreateNestedManyWithoutStudentInput
    credits?: creditsCreateNestedManyWithoutStudentInput
    mentorReviews?: mentorReviewsCreateNestedManyWithoutStudentInput
    mentorSessions?: mentorSessionsCreateNestedManyWithoutStudentInput
    portfolioProjects?: portfolioProjectsCreateNestedManyWithoutUserInput
    faculty?: facultyCreateNestedOneWithoutStudentsInput
    institution: institutionsCreateNestedOneWithoutProfilesInput
    user: usersCreateNestedOneWithoutProfilesInput
    learningProgress?: studentLearningProgressCreateNestedManyWithoutProfileInput
  }

  export type profileUncheckedCreateWithoutInternshipApplicationsInput = {
    id?: string
    userId: string
    bio?: string | null
    gender?: string | null
    DOB?: Date | string | null
    avatarURL?: string | null
    github?: string | null
    linkedin?: string | null
    skills?: profileCreateskillsInput | string[]
    interests?: profileCreateinterestsInput | string[]
    department?: string | null
    resourceId?: string | null
    instituteId: string
    facultyId?: string | null
    certificates?: certificatesUncheckedCreateNestedManyWithoutStudentInput
    credits?: creditsUncheckedCreateNestedManyWithoutStudentInput
    mentorReviews?: mentorReviewsUncheckedCreateNestedManyWithoutStudentInput
    mentorSessions?: mentorSessionsUncheckedCreateNestedManyWithoutStudentInput
    portfolioProjects?: portfolioProjectsUncheckedCreateNestedManyWithoutUserInput
    learningProgress?: studentLearningProgressUncheckedCreateNestedManyWithoutProfileInput
  }

  export type profileCreateOrConnectWithoutInternshipApplicationsInput = {
    where: profileWhereUniqueInput
    create: XOR<profileCreateWithoutInternshipApplicationsInput, profileUncheckedCreateWithoutInternshipApplicationsInput>
  }

  export type internship_evaluationCreateWithoutApplicationInput = {
    id?: string
    rubric_json?: NullableJsonNullValueInput | InputJsonValue
    comments?: string | null
    final_score?: number | null
    faculty: facultyCreateNestedOneWithoutEvaluationsInput
  }

  export type internship_evaluationUncheckedCreateWithoutApplicationInput = {
    id?: string
    faculty_id: string
    rubric_json?: NullableJsonNullValueInput | InputJsonValue
    comments?: string | null
    final_score?: number | null
  }

  export type internship_evaluationCreateOrConnectWithoutApplicationInput = {
    where: internship_evaluationWhereUniqueInput
    create: XOR<internship_evaluationCreateWithoutApplicationInput, internship_evaluationUncheckedCreateWithoutApplicationInput>
  }

  export type internship_evaluationCreateManyApplicationInputEnvelope = {
    data: internship_evaluationCreateManyApplicationInput | internship_evaluationCreateManyApplicationInput[]
    skipDuplicates?: boolean
  }

  export type logbook_entriesCreateWithoutApplicationInput = {
    id?: string
    date: Date | string
    taskDone: string
    proofUrl?: string | null
    hours_spent: number
  }

  export type logbook_entriesUncheckedCreateWithoutApplicationInput = {
    id?: string
    date: Date | string
    taskDone: string
    proofUrl?: string | null
    hours_spent: number
  }

  export type logbook_entriesCreateOrConnectWithoutApplicationInput = {
    where: logbook_entriesWhereUniqueInput
    create: XOR<logbook_entriesCreateWithoutApplicationInput, logbook_entriesUncheckedCreateWithoutApplicationInput>
  }

  export type logbook_entriesCreateManyApplicationInputEnvelope = {
    data: logbook_entriesCreateManyApplicationInput | logbook_entriesCreateManyApplicationInput[]
    skipDuplicates?: boolean
  }

  export type internshipsUpsertWithoutApplicationsInput = {
    update: XOR<internshipsUpdateWithoutApplicationsInput, internshipsUncheckedUpdateWithoutApplicationsInput>
    create: XOR<internshipsCreateWithoutApplicationsInput, internshipsUncheckedCreateWithoutApplicationsInput>
    where?: internshipsWhereInput
  }

  export type internshipsUpdateToOneWithWhereWithoutApplicationsInput = {
    where?: internshipsWhereInput
    data: XOR<internshipsUpdateWithoutApplicationsInput, internshipsUncheckedUpdateWithoutApplicationsInput>
  }

  export type internshipsUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    stipend?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: StringFieldUpdateOperationsInput | string
    required_skills?: JsonNullValueInput | InputJsonValue
    duration_weeks?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    industryUser?: usersUpdateOneRequiredWithoutInternships_industryUserNestedInput
  }

  export type internshipsUncheckedUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    industry_user_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    stipend?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: StringFieldUpdateOperationsInput | string
    required_skills?: JsonNullValueInput | InputJsonValue
    duration_weeks?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type profileUpsertWithoutInternshipApplicationsInput = {
    update: XOR<profileUpdateWithoutInternshipApplicationsInput, profileUncheckedUpdateWithoutInternshipApplicationsInput>
    create: XOR<profileCreateWithoutInternshipApplicationsInput, profileUncheckedCreateWithoutInternshipApplicationsInput>
    where?: profileWhereInput
  }

  export type profileUpdateToOneWithWhereWithoutInternshipApplicationsInput = {
    where?: profileWhereInput
    data: XOR<profileUpdateWithoutInternshipApplicationsInput, profileUncheckedUpdateWithoutInternshipApplicationsInput>
  }

  export type profileUpdateWithoutInternshipApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarURL?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: profileUpdateskillsInput | string[]
    interests?: profileUpdateinterestsInput | string[]
    department?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    certificates?: certificatesUpdateManyWithoutStudentNestedInput
    credits?: creditsUpdateManyWithoutStudentNestedInput
    mentorReviews?: mentorReviewsUpdateManyWithoutStudentNestedInput
    mentorSessions?: mentorSessionsUpdateManyWithoutStudentNestedInput
    portfolioProjects?: portfolioProjectsUpdateManyWithoutUserNestedInput
    faculty?: facultyUpdateOneWithoutStudentsNestedInput
    institution?: institutionsUpdateOneRequiredWithoutProfilesNestedInput
    user?: usersUpdateOneRequiredWithoutProfilesNestedInput
    learningProgress?: studentLearningProgressUpdateManyWithoutProfileNestedInput
  }

  export type profileUncheckedUpdateWithoutInternshipApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarURL?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: profileUpdateskillsInput | string[]
    interests?: profileUpdateinterestsInput | string[]
    department?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    instituteId?: StringFieldUpdateOperationsInput | string
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
    certificates?: certificatesUncheckedUpdateManyWithoutStudentNestedInput
    credits?: creditsUncheckedUpdateManyWithoutStudentNestedInput
    mentorReviews?: mentorReviewsUncheckedUpdateManyWithoutStudentNestedInput
    mentorSessions?: mentorSessionsUncheckedUpdateManyWithoutStudentNestedInput
    portfolioProjects?: portfolioProjectsUncheckedUpdateManyWithoutUserNestedInput
    learningProgress?: studentLearningProgressUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type internship_evaluationUpsertWithWhereUniqueWithoutApplicationInput = {
    where: internship_evaluationWhereUniqueInput
    update: XOR<internship_evaluationUpdateWithoutApplicationInput, internship_evaluationUncheckedUpdateWithoutApplicationInput>
    create: XOR<internship_evaluationCreateWithoutApplicationInput, internship_evaluationUncheckedCreateWithoutApplicationInput>
  }

  export type internship_evaluationUpdateWithWhereUniqueWithoutApplicationInput = {
    where: internship_evaluationWhereUniqueInput
    data: XOR<internship_evaluationUpdateWithoutApplicationInput, internship_evaluationUncheckedUpdateWithoutApplicationInput>
  }

  export type internship_evaluationUpdateManyWithWhereWithoutApplicationInput = {
    where: internship_evaluationScalarWhereInput
    data: XOR<internship_evaluationUpdateManyMutationInput, internship_evaluationUncheckedUpdateManyWithoutApplicationInput>
  }

  export type internship_evaluationScalarWhereInput = {
    AND?: internship_evaluationScalarWhereInput | internship_evaluationScalarWhereInput[]
    OR?: internship_evaluationScalarWhereInput[]
    NOT?: internship_evaluationScalarWhereInput | internship_evaluationScalarWhereInput[]
    id?: StringFilter<"internship_evaluation"> | string
    application_id?: StringFilter<"internship_evaluation"> | string
    faculty_id?: StringFilter<"internship_evaluation"> | string
    rubric_json?: JsonNullableFilter<"internship_evaluation">
    comments?: StringNullableFilter<"internship_evaluation"> | string | null
    final_score?: FloatNullableFilter<"internship_evaluation"> | number | null
  }

  export type logbook_entriesUpsertWithWhereUniqueWithoutApplicationInput = {
    where: logbook_entriesWhereUniqueInput
    update: XOR<logbook_entriesUpdateWithoutApplicationInput, logbook_entriesUncheckedUpdateWithoutApplicationInput>
    create: XOR<logbook_entriesCreateWithoutApplicationInput, logbook_entriesUncheckedCreateWithoutApplicationInput>
  }

  export type logbook_entriesUpdateWithWhereUniqueWithoutApplicationInput = {
    where: logbook_entriesWhereUniqueInput
    data: XOR<logbook_entriesUpdateWithoutApplicationInput, logbook_entriesUncheckedUpdateWithoutApplicationInput>
  }

  export type logbook_entriesUpdateManyWithWhereWithoutApplicationInput = {
    where: logbook_entriesScalarWhereInput
    data: XOR<logbook_entriesUpdateManyMutationInput, logbook_entriesUncheckedUpdateManyWithoutApplicationInput>
  }

  export type logbook_entriesScalarWhereInput = {
    AND?: logbook_entriesScalarWhereInput | logbook_entriesScalarWhereInput[]
    OR?: logbook_entriesScalarWhereInput[]
    NOT?: logbook_entriesScalarWhereInput | logbook_entriesScalarWhereInput[]
    id?: StringFilter<"logbook_entries"> | string
    applicationId?: StringFilter<"logbook_entries"> | string
    date?: DateTimeFilter<"logbook_entries"> | Date | string
    taskDone?: StringFilter<"logbook_entries"> | string
    proofUrl?: StringNullableFilter<"logbook_entries"> | string | null
    hours_spent?: IntFilter<"logbook_entries"> | number
  }

  export type internship_applicationsCreateWithoutLogbookEntriesInput = {
    id?: string
    status: $Enums.InternshipStatus
    submission_url?: string | null
    score?: number | null
    applied_at: Date | string
    internship: internshipsCreateNestedOneWithoutApplicationsInput
    student: profileCreateNestedOneWithoutInternshipApplicationsInput
    evaluations?: internship_evaluationCreateNestedManyWithoutApplicationInput
  }

  export type internship_applicationsUncheckedCreateWithoutLogbookEntriesInput = {
    id?: string
    internship_id: string
    student_id: string
    status: $Enums.InternshipStatus
    submission_url?: string | null
    score?: number | null
    applied_at: Date | string
    evaluations?: internship_evaluationUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type internship_applicationsCreateOrConnectWithoutLogbookEntriesInput = {
    where: internship_applicationsWhereUniqueInput
    create: XOR<internship_applicationsCreateWithoutLogbookEntriesInput, internship_applicationsUncheckedCreateWithoutLogbookEntriesInput>
  }

  export type internship_applicationsUpsertWithoutLogbookEntriesInput = {
    update: XOR<internship_applicationsUpdateWithoutLogbookEntriesInput, internship_applicationsUncheckedUpdateWithoutLogbookEntriesInput>
    create: XOR<internship_applicationsCreateWithoutLogbookEntriesInput, internship_applicationsUncheckedCreateWithoutLogbookEntriesInput>
    where?: internship_applicationsWhereInput
  }

  export type internship_applicationsUpdateToOneWithWhereWithoutLogbookEntriesInput = {
    where?: internship_applicationsWhereInput
    data: XOR<internship_applicationsUpdateWithoutLogbookEntriesInput, internship_applicationsUncheckedUpdateWithoutLogbookEntriesInput>
  }

  export type internship_applicationsUpdateWithoutLogbookEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInternshipStatusFieldUpdateOperationsInput | $Enums.InternshipStatus
    submission_url?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    applied_at?: DateTimeFieldUpdateOperationsInput | Date | string
    internship?: internshipsUpdateOneRequiredWithoutApplicationsNestedInput
    student?: profileUpdateOneRequiredWithoutInternshipApplicationsNestedInput
    evaluations?: internship_evaluationUpdateManyWithoutApplicationNestedInput
  }

  export type internship_applicationsUncheckedUpdateWithoutLogbookEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    internship_id?: StringFieldUpdateOperationsInput | string
    student_id?: StringFieldUpdateOperationsInput | string
    status?: EnumInternshipStatusFieldUpdateOperationsInput | $Enums.InternshipStatus
    submission_url?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    applied_at?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: internship_evaluationUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type internship_applicationsCreateWithoutEvaluationsInput = {
    id?: string
    status: $Enums.InternshipStatus
    submission_url?: string | null
    score?: number | null
    applied_at: Date | string
    internship: internshipsCreateNestedOneWithoutApplicationsInput
    student: profileCreateNestedOneWithoutInternshipApplicationsInput
    logbookEntries?: logbook_entriesCreateNestedManyWithoutApplicationInput
  }

  export type internship_applicationsUncheckedCreateWithoutEvaluationsInput = {
    id?: string
    internship_id: string
    student_id: string
    status: $Enums.InternshipStatus
    submission_url?: string | null
    score?: number | null
    applied_at: Date | string
    logbookEntries?: logbook_entriesUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type internship_applicationsCreateOrConnectWithoutEvaluationsInput = {
    where: internship_applicationsWhereUniqueInput
    create: XOR<internship_applicationsCreateWithoutEvaluationsInput, internship_applicationsUncheckedCreateWithoutEvaluationsInput>
  }

  export type facultyCreateWithoutEvaluationsInput = {
    id?: string
    name: string
    department: string
    institution: institutionsCreateNestedOneWithoutFacultyInput
    user: usersCreateNestedOneWithoutFacultyProfileInput
    students?: profileCreateNestedManyWithoutFacultyInput
  }

  export type facultyUncheckedCreateWithoutEvaluationsInput = {
    id?: string
    instituteId: string
    userId: string
    name: string
    department: string
    students?: profileUncheckedCreateNestedManyWithoutFacultyInput
  }

  export type facultyCreateOrConnectWithoutEvaluationsInput = {
    where: facultyWhereUniqueInput
    create: XOR<facultyCreateWithoutEvaluationsInput, facultyUncheckedCreateWithoutEvaluationsInput>
  }

  export type internship_applicationsUpsertWithoutEvaluationsInput = {
    update: XOR<internship_applicationsUpdateWithoutEvaluationsInput, internship_applicationsUncheckedUpdateWithoutEvaluationsInput>
    create: XOR<internship_applicationsCreateWithoutEvaluationsInput, internship_applicationsUncheckedCreateWithoutEvaluationsInput>
    where?: internship_applicationsWhereInput
  }

  export type internship_applicationsUpdateToOneWithWhereWithoutEvaluationsInput = {
    where?: internship_applicationsWhereInput
    data: XOR<internship_applicationsUpdateWithoutEvaluationsInput, internship_applicationsUncheckedUpdateWithoutEvaluationsInput>
  }

  export type internship_applicationsUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInternshipStatusFieldUpdateOperationsInput | $Enums.InternshipStatus
    submission_url?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    applied_at?: DateTimeFieldUpdateOperationsInput | Date | string
    internship?: internshipsUpdateOneRequiredWithoutApplicationsNestedInput
    student?: profileUpdateOneRequiredWithoutInternshipApplicationsNestedInput
    logbookEntries?: logbook_entriesUpdateManyWithoutApplicationNestedInput
  }

  export type internship_applicationsUncheckedUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    internship_id?: StringFieldUpdateOperationsInput | string
    student_id?: StringFieldUpdateOperationsInput | string
    status?: EnumInternshipStatusFieldUpdateOperationsInput | $Enums.InternshipStatus
    submission_url?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    applied_at?: DateTimeFieldUpdateOperationsInput | Date | string
    logbookEntries?: logbook_entriesUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type facultyUpsertWithoutEvaluationsInput = {
    update: XOR<facultyUpdateWithoutEvaluationsInput, facultyUncheckedUpdateWithoutEvaluationsInput>
    create: XOR<facultyCreateWithoutEvaluationsInput, facultyUncheckedCreateWithoutEvaluationsInput>
    where?: facultyWhereInput
  }

  export type facultyUpdateToOneWithWhereWithoutEvaluationsInput = {
    where?: facultyWhereInput
    data: XOR<facultyUpdateWithoutEvaluationsInput, facultyUncheckedUpdateWithoutEvaluationsInput>
  }

  export type facultyUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    institution?: institutionsUpdateOneRequiredWithoutFacultyNestedInput
    user?: usersUpdateOneRequiredWithoutFacultyProfileNestedInput
    students?: profileUpdateManyWithoutFacultyNestedInput
  }

  export type facultyUncheckedUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    instituteId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    students?: profileUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type institutionsCreateWithoutFacultyInput = {
    id?: string
    instituteName: string
    state: string
    createdAt: Date | string
    adminUser: usersCreateNestedOneWithoutInstitutions_adminInput
    profiles?: profileCreateNestedManyWithoutInstitutionInput
  }

  export type institutionsUncheckedCreateWithoutFacultyInput = {
    id?: string
    instituteName: string
    state: string
    adminUserId: string
    createdAt: Date | string
    profiles?: profileUncheckedCreateNestedManyWithoutInstitutionInput
  }

  export type institutionsCreateOrConnectWithoutFacultyInput = {
    where: institutionsWhereUniqueInput
    create: XOR<institutionsCreateWithoutFacultyInput, institutionsUncheckedCreateWithoutFacultyInput>
  }

  export type usersCreateWithoutFacultyProfileInput = {
    id?: string
    displayName: string
    role?: usersCreateroleInput | string[]
    email: string
    salt: string
    phone: string
    hashPassword: string
    courseEnrollments?: courseEnrollmentsCreateNestedManyWithoutUserInput
    courses_instructor?: coursesCreateNestedManyWithoutInstructorInput
    institutions_admin?: institutionsCreateNestedManyWithoutAdminUserInput
    internships_industryUser?: internshipsCreateNestedManyWithoutIndustryUserInput
    mentors?: mentorsCreateNestedOneWithoutUserInput
    profiles?: profileCreateNestedOneWithoutUserInput
    user_notifications?: user_notificationsCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutFacultyProfileInput = {
    id?: string
    displayName: string
    role?: usersCreateroleInput | string[]
    email: string
    salt: string
    phone: string
    hashPassword: string
    courseEnrollments?: courseEnrollmentsUncheckedCreateNestedManyWithoutUserInput
    courses_instructor?: coursesUncheckedCreateNestedManyWithoutInstructorInput
    institutions_admin?: institutionsUncheckedCreateNestedManyWithoutAdminUserInput
    internships_industryUser?: internshipsUncheckedCreateNestedManyWithoutIndustryUserInput
    mentors?: mentorsUncheckedCreateNestedOneWithoutUserInput
    profiles?: profileUncheckedCreateNestedOneWithoutUserInput
    user_notifications?: user_notificationsUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutFacultyProfileInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutFacultyProfileInput, usersUncheckedCreateWithoutFacultyProfileInput>
  }

  export type internship_evaluationCreateWithoutFacultyInput = {
    id?: string
    rubric_json?: NullableJsonNullValueInput | InputJsonValue
    comments?: string | null
    final_score?: number | null
    application: internship_applicationsCreateNestedOneWithoutEvaluationsInput
  }

  export type internship_evaluationUncheckedCreateWithoutFacultyInput = {
    id?: string
    application_id: string
    rubric_json?: NullableJsonNullValueInput | InputJsonValue
    comments?: string | null
    final_score?: number | null
  }

  export type internship_evaluationCreateOrConnectWithoutFacultyInput = {
    where: internship_evaluationWhereUniqueInput
    create: XOR<internship_evaluationCreateWithoutFacultyInput, internship_evaluationUncheckedCreateWithoutFacultyInput>
  }

  export type internship_evaluationCreateManyFacultyInputEnvelope = {
    data: internship_evaluationCreateManyFacultyInput | internship_evaluationCreateManyFacultyInput[]
    skipDuplicates?: boolean
  }

  export type profileCreateWithoutFacultyInput = {
    id?: string
    bio?: string | null
    gender?: string | null
    DOB?: Date | string | null
    avatarURL?: string | null
    github?: string | null
    linkedin?: string | null
    skills?: profileCreateskillsInput | string[]
    interests?: profileCreateinterestsInput | string[]
    department?: string | null
    resourceId?: string | null
    certificates?: certificatesCreateNestedManyWithoutStudentInput
    credits?: creditsCreateNestedManyWithoutStudentInput
    internshipApplications?: internship_applicationsCreateNestedManyWithoutStudentInput
    mentorReviews?: mentorReviewsCreateNestedManyWithoutStudentInput
    mentorSessions?: mentorSessionsCreateNestedManyWithoutStudentInput
    portfolioProjects?: portfolioProjectsCreateNestedManyWithoutUserInput
    institution: institutionsCreateNestedOneWithoutProfilesInput
    user: usersCreateNestedOneWithoutProfilesInput
    learningProgress?: studentLearningProgressCreateNestedManyWithoutProfileInput
  }

  export type profileUncheckedCreateWithoutFacultyInput = {
    id?: string
    userId: string
    bio?: string | null
    gender?: string | null
    DOB?: Date | string | null
    avatarURL?: string | null
    github?: string | null
    linkedin?: string | null
    skills?: profileCreateskillsInput | string[]
    interests?: profileCreateinterestsInput | string[]
    department?: string | null
    resourceId?: string | null
    instituteId: string
    certificates?: certificatesUncheckedCreateNestedManyWithoutStudentInput
    credits?: creditsUncheckedCreateNestedManyWithoutStudentInput
    internshipApplications?: internship_applicationsUncheckedCreateNestedManyWithoutStudentInput
    mentorReviews?: mentorReviewsUncheckedCreateNestedManyWithoutStudentInput
    mentorSessions?: mentorSessionsUncheckedCreateNestedManyWithoutStudentInput
    portfolioProjects?: portfolioProjectsUncheckedCreateNestedManyWithoutUserInput
    learningProgress?: studentLearningProgressUncheckedCreateNestedManyWithoutProfileInput
  }

  export type profileCreateOrConnectWithoutFacultyInput = {
    where: profileWhereUniqueInput
    create: XOR<profileCreateWithoutFacultyInput, profileUncheckedCreateWithoutFacultyInput>
  }

  export type profileCreateManyFacultyInputEnvelope = {
    data: profileCreateManyFacultyInput | profileCreateManyFacultyInput[]
    skipDuplicates?: boolean
  }

  export type institutionsUpsertWithoutFacultyInput = {
    update: XOR<institutionsUpdateWithoutFacultyInput, institutionsUncheckedUpdateWithoutFacultyInput>
    create: XOR<institutionsCreateWithoutFacultyInput, institutionsUncheckedCreateWithoutFacultyInput>
    where?: institutionsWhereInput
  }

  export type institutionsUpdateToOneWithWhereWithoutFacultyInput = {
    where?: institutionsWhereInput
    data: XOR<institutionsUpdateWithoutFacultyInput, institutionsUncheckedUpdateWithoutFacultyInput>
  }

  export type institutionsUpdateWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adminUser?: usersUpdateOneRequiredWithoutInstitutions_adminNestedInput
    profiles?: profileUpdateManyWithoutInstitutionNestedInput
  }

  export type institutionsUncheckedUpdateWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    adminUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profiles?: profileUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type usersUpsertWithoutFacultyProfileInput = {
    update: XOR<usersUpdateWithoutFacultyProfileInput, usersUncheckedUpdateWithoutFacultyProfileInput>
    create: XOR<usersCreateWithoutFacultyProfileInput, usersUncheckedCreateWithoutFacultyProfileInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutFacultyProfileInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutFacultyProfileInput, usersUncheckedUpdateWithoutFacultyProfileInput>
  }

  export type usersUpdateWithoutFacultyProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    role?: usersUpdateroleInput | string[]
    email?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    hashPassword?: StringFieldUpdateOperationsInput | string
    courseEnrollments?: courseEnrollmentsUpdateManyWithoutUserNestedInput
    courses_instructor?: coursesUpdateManyWithoutInstructorNestedInput
    institutions_admin?: institutionsUpdateManyWithoutAdminUserNestedInput
    internships_industryUser?: internshipsUpdateManyWithoutIndustryUserNestedInput
    mentors?: mentorsUpdateOneWithoutUserNestedInput
    profiles?: profileUpdateOneWithoutUserNestedInput
    user_notifications?: user_notificationsUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutFacultyProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    role?: usersUpdateroleInput | string[]
    email?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    hashPassword?: StringFieldUpdateOperationsInput | string
    courseEnrollments?: courseEnrollmentsUncheckedUpdateManyWithoutUserNestedInput
    courses_instructor?: coursesUncheckedUpdateManyWithoutInstructorNestedInput
    institutions_admin?: institutionsUncheckedUpdateManyWithoutAdminUserNestedInput
    internships_industryUser?: internshipsUncheckedUpdateManyWithoutIndustryUserNestedInput
    mentors?: mentorsUncheckedUpdateOneWithoutUserNestedInput
    profiles?: profileUncheckedUpdateOneWithoutUserNestedInput
    user_notifications?: user_notificationsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type internship_evaluationUpsertWithWhereUniqueWithoutFacultyInput = {
    where: internship_evaluationWhereUniqueInput
    update: XOR<internship_evaluationUpdateWithoutFacultyInput, internship_evaluationUncheckedUpdateWithoutFacultyInput>
    create: XOR<internship_evaluationCreateWithoutFacultyInput, internship_evaluationUncheckedCreateWithoutFacultyInput>
  }

  export type internship_evaluationUpdateWithWhereUniqueWithoutFacultyInput = {
    where: internship_evaluationWhereUniqueInput
    data: XOR<internship_evaluationUpdateWithoutFacultyInput, internship_evaluationUncheckedUpdateWithoutFacultyInput>
  }

  export type internship_evaluationUpdateManyWithWhereWithoutFacultyInput = {
    where: internship_evaluationScalarWhereInput
    data: XOR<internship_evaluationUpdateManyMutationInput, internship_evaluationUncheckedUpdateManyWithoutFacultyInput>
  }

  export type profileUpsertWithWhereUniqueWithoutFacultyInput = {
    where: profileWhereUniqueInput
    update: XOR<profileUpdateWithoutFacultyInput, profileUncheckedUpdateWithoutFacultyInput>
    create: XOR<profileCreateWithoutFacultyInput, profileUncheckedCreateWithoutFacultyInput>
  }

  export type profileUpdateWithWhereUniqueWithoutFacultyInput = {
    where: profileWhereUniqueInput
    data: XOR<profileUpdateWithoutFacultyInput, profileUncheckedUpdateWithoutFacultyInput>
  }

  export type profileUpdateManyWithWhereWithoutFacultyInput = {
    where: profileScalarWhereInput
    data: XOR<profileUpdateManyMutationInput, profileUncheckedUpdateManyWithoutFacultyInput>
  }

  export type profileCreateWithoutCreditsInput = {
    id?: string
    bio?: string | null
    gender?: string | null
    DOB?: Date | string | null
    avatarURL?: string | null
    github?: string | null
    linkedin?: string | null
    skills?: profileCreateskillsInput | string[]
    interests?: profileCreateinterestsInput | string[]
    department?: string | null
    resourceId?: string | null
    certificates?: certificatesCreateNestedManyWithoutStudentInput
    internshipApplications?: internship_applicationsCreateNestedManyWithoutStudentInput
    mentorReviews?: mentorReviewsCreateNestedManyWithoutStudentInput
    mentorSessions?: mentorSessionsCreateNestedManyWithoutStudentInput
    portfolioProjects?: portfolioProjectsCreateNestedManyWithoutUserInput
    faculty?: facultyCreateNestedOneWithoutStudentsInput
    institution: institutionsCreateNestedOneWithoutProfilesInput
    user: usersCreateNestedOneWithoutProfilesInput
    learningProgress?: studentLearningProgressCreateNestedManyWithoutProfileInput
  }

  export type profileUncheckedCreateWithoutCreditsInput = {
    id?: string
    userId: string
    bio?: string | null
    gender?: string | null
    DOB?: Date | string | null
    avatarURL?: string | null
    github?: string | null
    linkedin?: string | null
    skills?: profileCreateskillsInput | string[]
    interests?: profileCreateinterestsInput | string[]
    department?: string | null
    resourceId?: string | null
    instituteId: string
    facultyId?: string | null
    certificates?: certificatesUncheckedCreateNestedManyWithoutStudentInput
    internshipApplications?: internship_applicationsUncheckedCreateNestedManyWithoutStudentInput
    mentorReviews?: mentorReviewsUncheckedCreateNestedManyWithoutStudentInput
    mentorSessions?: mentorSessionsUncheckedCreateNestedManyWithoutStudentInput
    portfolioProjects?: portfolioProjectsUncheckedCreateNestedManyWithoutUserInput
    learningProgress?: studentLearningProgressUncheckedCreateNestedManyWithoutProfileInput
  }

  export type profileCreateOrConnectWithoutCreditsInput = {
    where: profileWhereUniqueInput
    create: XOR<profileCreateWithoutCreditsInput, profileUncheckedCreateWithoutCreditsInput>
  }

  export type profileUpsertWithoutCreditsInput = {
    update: XOR<profileUpdateWithoutCreditsInput, profileUncheckedUpdateWithoutCreditsInput>
    create: XOR<profileCreateWithoutCreditsInput, profileUncheckedCreateWithoutCreditsInput>
    where?: profileWhereInput
  }

  export type profileUpdateToOneWithWhereWithoutCreditsInput = {
    where?: profileWhereInput
    data: XOR<profileUpdateWithoutCreditsInput, profileUncheckedUpdateWithoutCreditsInput>
  }

  export type profileUpdateWithoutCreditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarURL?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: profileUpdateskillsInput | string[]
    interests?: profileUpdateinterestsInput | string[]
    department?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    certificates?: certificatesUpdateManyWithoutStudentNestedInput
    internshipApplications?: internship_applicationsUpdateManyWithoutStudentNestedInput
    mentorReviews?: mentorReviewsUpdateManyWithoutStudentNestedInput
    mentorSessions?: mentorSessionsUpdateManyWithoutStudentNestedInput
    portfolioProjects?: portfolioProjectsUpdateManyWithoutUserNestedInput
    faculty?: facultyUpdateOneWithoutStudentsNestedInput
    institution?: institutionsUpdateOneRequiredWithoutProfilesNestedInput
    user?: usersUpdateOneRequiredWithoutProfilesNestedInput
    learningProgress?: studentLearningProgressUpdateManyWithoutProfileNestedInput
  }

  export type profileUncheckedUpdateWithoutCreditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarURL?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: profileUpdateskillsInput | string[]
    interests?: profileUpdateinterestsInput | string[]
    department?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    instituteId?: StringFieldUpdateOperationsInput | string
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
    certificates?: certificatesUncheckedUpdateManyWithoutStudentNestedInput
    internshipApplications?: internship_applicationsUncheckedUpdateManyWithoutStudentNestedInput
    mentorReviews?: mentorReviewsUncheckedUpdateManyWithoutStudentNestedInput
    mentorSessions?: mentorSessionsUncheckedUpdateManyWithoutStudentNestedInput
    portfolioProjects?: portfolioProjectsUncheckedUpdateManyWithoutUserNestedInput
    learningProgress?: studentLearningProgressUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type profileCreateWithoutCertificatesInput = {
    id?: string
    bio?: string | null
    gender?: string | null
    DOB?: Date | string | null
    avatarURL?: string | null
    github?: string | null
    linkedin?: string | null
    skills?: profileCreateskillsInput | string[]
    interests?: profileCreateinterestsInput | string[]
    department?: string | null
    resourceId?: string | null
    credits?: creditsCreateNestedManyWithoutStudentInput
    internshipApplications?: internship_applicationsCreateNestedManyWithoutStudentInput
    mentorReviews?: mentorReviewsCreateNestedManyWithoutStudentInput
    mentorSessions?: mentorSessionsCreateNestedManyWithoutStudentInput
    portfolioProjects?: portfolioProjectsCreateNestedManyWithoutUserInput
    faculty?: facultyCreateNestedOneWithoutStudentsInput
    institution: institutionsCreateNestedOneWithoutProfilesInput
    user: usersCreateNestedOneWithoutProfilesInput
    learningProgress?: studentLearningProgressCreateNestedManyWithoutProfileInput
  }

  export type profileUncheckedCreateWithoutCertificatesInput = {
    id?: string
    userId: string
    bio?: string | null
    gender?: string | null
    DOB?: Date | string | null
    avatarURL?: string | null
    github?: string | null
    linkedin?: string | null
    skills?: profileCreateskillsInput | string[]
    interests?: profileCreateinterestsInput | string[]
    department?: string | null
    resourceId?: string | null
    instituteId: string
    facultyId?: string | null
    credits?: creditsUncheckedCreateNestedManyWithoutStudentInput
    internshipApplications?: internship_applicationsUncheckedCreateNestedManyWithoutStudentInput
    mentorReviews?: mentorReviewsUncheckedCreateNestedManyWithoutStudentInput
    mentorSessions?: mentorSessionsUncheckedCreateNestedManyWithoutStudentInput
    portfolioProjects?: portfolioProjectsUncheckedCreateNestedManyWithoutUserInput
    learningProgress?: studentLearningProgressUncheckedCreateNestedManyWithoutProfileInput
  }

  export type profileCreateOrConnectWithoutCertificatesInput = {
    where: profileWhereUniqueInput
    create: XOR<profileCreateWithoutCertificatesInput, profileUncheckedCreateWithoutCertificatesInput>
  }

  export type profileUpsertWithoutCertificatesInput = {
    update: XOR<profileUpdateWithoutCertificatesInput, profileUncheckedUpdateWithoutCertificatesInput>
    create: XOR<profileCreateWithoutCertificatesInput, profileUncheckedCreateWithoutCertificatesInput>
    where?: profileWhereInput
  }

  export type profileUpdateToOneWithWhereWithoutCertificatesInput = {
    where?: profileWhereInput
    data: XOR<profileUpdateWithoutCertificatesInput, profileUncheckedUpdateWithoutCertificatesInput>
  }

  export type profileUpdateWithoutCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarURL?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: profileUpdateskillsInput | string[]
    interests?: profileUpdateinterestsInput | string[]
    department?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: creditsUpdateManyWithoutStudentNestedInput
    internshipApplications?: internship_applicationsUpdateManyWithoutStudentNestedInput
    mentorReviews?: mentorReviewsUpdateManyWithoutStudentNestedInput
    mentorSessions?: mentorSessionsUpdateManyWithoutStudentNestedInput
    portfolioProjects?: portfolioProjectsUpdateManyWithoutUserNestedInput
    faculty?: facultyUpdateOneWithoutStudentsNestedInput
    institution?: institutionsUpdateOneRequiredWithoutProfilesNestedInput
    user?: usersUpdateOneRequiredWithoutProfilesNestedInput
    learningProgress?: studentLearningProgressUpdateManyWithoutProfileNestedInput
  }

  export type profileUncheckedUpdateWithoutCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarURL?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: profileUpdateskillsInput | string[]
    interests?: profileUpdateinterestsInput | string[]
    department?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    instituteId?: StringFieldUpdateOperationsInput | string
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
    credits?: creditsUncheckedUpdateManyWithoutStudentNestedInput
    internshipApplications?: internship_applicationsUncheckedUpdateManyWithoutStudentNestedInput
    mentorReviews?: mentorReviewsUncheckedUpdateManyWithoutStudentNestedInput
    mentorSessions?: mentorSessionsUncheckedUpdateManyWithoutStudentNestedInput
    portfolioProjects?: portfolioProjectsUncheckedUpdateManyWithoutUserNestedInput
    learningProgress?: studentLearningProgressUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type user_notificationsCreateWithoutNotificationInput = {
    id?: string
    isRead: boolean
    read_at?: Date | string | null
    user: usersCreateNestedOneWithoutUser_notificationsInput
  }

  export type user_notificationsUncheckedCreateWithoutNotificationInput = {
    id?: string
    user_id: string
    isRead: boolean
    read_at?: Date | string | null
  }

  export type user_notificationsCreateOrConnectWithoutNotificationInput = {
    where: user_notificationsWhereUniqueInput
    create: XOR<user_notificationsCreateWithoutNotificationInput, user_notificationsUncheckedCreateWithoutNotificationInput>
  }

  export type user_notificationsCreateManyNotificationInputEnvelope = {
    data: user_notificationsCreateManyNotificationInput | user_notificationsCreateManyNotificationInput[]
    skipDuplicates?: boolean
  }

  export type user_notificationsUpsertWithWhereUniqueWithoutNotificationInput = {
    where: user_notificationsWhereUniqueInput
    update: XOR<user_notificationsUpdateWithoutNotificationInput, user_notificationsUncheckedUpdateWithoutNotificationInput>
    create: XOR<user_notificationsCreateWithoutNotificationInput, user_notificationsUncheckedCreateWithoutNotificationInput>
  }

  export type user_notificationsUpdateWithWhereUniqueWithoutNotificationInput = {
    where: user_notificationsWhereUniqueInput
    data: XOR<user_notificationsUpdateWithoutNotificationInput, user_notificationsUncheckedUpdateWithoutNotificationInput>
  }

  export type user_notificationsUpdateManyWithWhereWithoutNotificationInput = {
    where: user_notificationsScalarWhereInput
    data: XOR<user_notificationsUpdateManyMutationInput, user_notificationsUncheckedUpdateManyWithoutNotificationInput>
  }

  export type notificationsCreateWithoutUserNotificationsInput = {
    id?: string
    title: string
    message: string
    created_at: Date | string
  }

  export type notificationsUncheckedCreateWithoutUserNotificationsInput = {
    id?: string
    title: string
    message: string
    created_at: Date | string
  }

  export type notificationsCreateOrConnectWithoutUserNotificationsInput = {
    where: notificationsWhereUniqueInput
    create: XOR<notificationsCreateWithoutUserNotificationsInput, notificationsUncheckedCreateWithoutUserNotificationsInput>
  }

  export type usersCreateWithoutUser_notificationsInput = {
    id?: string
    displayName: string
    role?: usersCreateroleInput | string[]
    email: string
    salt: string
    phone: string
    hashPassword: string
    courseEnrollments?: courseEnrollmentsCreateNestedManyWithoutUserInput
    courses_instructor?: coursesCreateNestedManyWithoutInstructorInput
    facultyProfile?: facultyCreateNestedOneWithoutUserInput
    institutions_admin?: institutionsCreateNestedManyWithoutAdminUserInput
    internships_industryUser?: internshipsCreateNestedManyWithoutIndustryUserInput
    mentors?: mentorsCreateNestedOneWithoutUserInput
    profiles?: profileCreateNestedOneWithoutUserInput
  }

  export type usersUncheckedCreateWithoutUser_notificationsInput = {
    id?: string
    displayName: string
    role?: usersCreateroleInput | string[]
    email: string
    salt: string
    phone: string
    hashPassword: string
    courseEnrollments?: courseEnrollmentsUncheckedCreateNestedManyWithoutUserInput
    courses_instructor?: coursesUncheckedCreateNestedManyWithoutInstructorInput
    facultyProfile?: facultyUncheckedCreateNestedOneWithoutUserInput
    institutions_admin?: institutionsUncheckedCreateNestedManyWithoutAdminUserInput
    internships_industryUser?: internshipsUncheckedCreateNestedManyWithoutIndustryUserInput
    mentors?: mentorsUncheckedCreateNestedOneWithoutUserInput
    profiles?: profileUncheckedCreateNestedOneWithoutUserInput
  }

  export type usersCreateOrConnectWithoutUser_notificationsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutUser_notificationsInput, usersUncheckedCreateWithoutUser_notificationsInput>
  }

  export type notificationsUpsertWithoutUserNotificationsInput = {
    update: XOR<notificationsUpdateWithoutUserNotificationsInput, notificationsUncheckedUpdateWithoutUserNotificationsInput>
    create: XOR<notificationsCreateWithoutUserNotificationsInput, notificationsUncheckedCreateWithoutUserNotificationsInput>
    where?: notificationsWhereInput
  }

  export type notificationsUpdateToOneWithWhereWithoutUserNotificationsInput = {
    where?: notificationsWhereInput
    data: XOR<notificationsUpdateWithoutUserNotificationsInput, notificationsUncheckedUpdateWithoutUserNotificationsInput>
  }

  export type notificationsUpdateWithoutUserNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notificationsUncheckedUpdateWithoutUserNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUpsertWithoutUser_notificationsInput = {
    update: XOR<usersUpdateWithoutUser_notificationsInput, usersUncheckedUpdateWithoutUser_notificationsInput>
    create: XOR<usersCreateWithoutUser_notificationsInput, usersUncheckedCreateWithoutUser_notificationsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutUser_notificationsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutUser_notificationsInput, usersUncheckedUpdateWithoutUser_notificationsInput>
  }

  export type usersUpdateWithoutUser_notificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    role?: usersUpdateroleInput | string[]
    email?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    hashPassword?: StringFieldUpdateOperationsInput | string
    courseEnrollments?: courseEnrollmentsUpdateManyWithoutUserNestedInput
    courses_instructor?: coursesUpdateManyWithoutInstructorNestedInput
    facultyProfile?: facultyUpdateOneWithoutUserNestedInput
    institutions_admin?: institutionsUpdateManyWithoutAdminUserNestedInput
    internships_industryUser?: internshipsUpdateManyWithoutIndustryUserNestedInput
    mentors?: mentorsUpdateOneWithoutUserNestedInput
    profiles?: profileUpdateOneWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutUser_notificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    role?: usersUpdateroleInput | string[]
    email?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    hashPassword?: StringFieldUpdateOperationsInput | string
    courseEnrollments?: courseEnrollmentsUncheckedUpdateManyWithoutUserNestedInput
    courses_instructor?: coursesUncheckedUpdateManyWithoutInstructorNestedInput
    facultyProfile?: facultyUncheckedUpdateOneWithoutUserNestedInput
    institutions_admin?: institutionsUncheckedUpdateManyWithoutAdminUserNestedInput
    internships_industryUser?: internshipsUncheckedUpdateManyWithoutIndustryUserNestedInput
    mentors?: mentorsUncheckedUpdateOneWithoutUserNestedInput
    profiles?: profileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type courseEnrollmentsCreateManyUserInput = {
    id?: string
    courseId: string
    progressPercent?: number | null
    enrolledAt: Date | string
  }

  export type coursesCreateManyInstructorInput = {
    id?: string
    title: string
    description: string
    type: $Enums.CourseType
    price?: number | null
    thumbnail_url?: string | null
    created_at: Date | string
  }

  export type institutionsCreateManyAdminUserInput = {
    id?: string
    instituteName: string
    state: string
    createdAt: Date | string
  }

  export type internshipsCreateManyIndustryUserInput = {
    id?: string
    title: string
    description: string
    type: string
    stipend?: number | null
    location: string
    required_skills: JsonNullValueInput | InputJsonValue
    duration_weeks: number
    created_at: Date | string
  }

  export type user_notificationsCreateManyUserInput = {
    id?: string
    notification_id: string
    isRead: boolean
    read_at?: Date | string | null
  }

  export type courseEnrollmentsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    progressPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: coursesUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type courseEnrollmentsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    progressPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type courseEnrollmentsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    progressPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type coursesUpdateWithoutInstructorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: courseEnrollmentsUpdateManyWithoutCourseNestedInput
  }

  export type coursesUncheckedUpdateWithoutInstructorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: courseEnrollmentsUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type coursesUncheckedUpdateManyWithoutInstructorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumCourseTypeFieldUpdateOperationsInput | $Enums.CourseType
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type institutionsUpdateWithoutAdminUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    faculty?: facultyUpdateManyWithoutInstitutionNestedInput
    profiles?: profileUpdateManyWithoutInstitutionNestedInput
  }

  export type institutionsUncheckedUpdateWithoutAdminUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    faculty?: facultyUncheckedUpdateManyWithoutInstitutionNestedInput
    profiles?: profileUncheckedUpdateManyWithoutInstitutionNestedInput
  }

  export type institutionsUncheckedUpdateManyWithoutAdminUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    instituteName?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type internshipsUpdateWithoutIndustryUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    stipend?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: StringFieldUpdateOperationsInput | string
    required_skills?: JsonNullValueInput | InputJsonValue
    duration_weeks?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: internship_applicationsUpdateManyWithoutInternshipNestedInput
  }

  export type internshipsUncheckedUpdateWithoutIndustryUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    stipend?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: StringFieldUpdateOperationsInput | string
    required_skills?: JsonNullValueInput | InputJsonValue
    duration_weeks?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: internship_applicationsUncheckedUpdateManyWithoutInternshipNestedInput
  }

  export type internshipsUncheckedUpdateManyWithoutIndustryUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    stipend?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: StringFieldUpdateOperationsInput | string
    required_skills?: JsonNullValueInput | InputJsonValue
    duration_weeks?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_notificationsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notification?: notificationsUpdateOneRequiredWithoutUserNotificationsNestedInput
  }

  export type user_notificationsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification_id?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_notificationsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification_id?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type facultyCreateManyInstitutionInput = {
    id?: string
    userId: string
    name: string
    department: string
  }

  export type profileCreateManyInstitutionInput = {
    id?: string
    userId: string
    bio?: string | null
    gender?: string | null
    DOB?: Date | string | null
    avatarURL?: string | null
    github?: string | null
    linkedin?: string | null
    skills?: profileCreateskillsInput | string[]
    interests?: profileCreateinterestsInput | string[]
    department?: string | null
    resourceId?: string | null
    facultyId?: string | null
  }

  export type facultyUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    user?: usersUpdateOneRequiredWithoutFacultyProfileNestedInput
    evaluations?: internship_evaluationUpdateManyWithoutFacultyNestedInput
    students?: profileUpdateManyWithoutFacultyNestedInput
  }

  export type facultyUncheckedUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    evaluations?: internship_evaluationUncheckedUpdateManyWithoutFacultyNestedInput
    students?: profileUncheckedUpdateManyWithoutFacultyNestedInput
  }

  export type facultyUncheckedUpdateManyWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
  }

  export type profileUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarURL?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: profileUpdateskillsInput | string[]
    interests?: profileUpdateinterestsInput | string[]
    department?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    certificates?: certificatesUpdateManyWithoutStudentNestedInput
    credits?: creditsUpdateManyWithoutStudentNestedInput
    internshipApplications?: internship_applicationsUpdateManyWithoutStudentNestedInput
    mentorReviews?: mentorReviewsUpdateManyWithoutStudentNestedInput
    mentorSessions?: mentorSessionsUpdateManyWithoutStudentNestedInput
    portfolioProjects?: portfolioProjectsUpdateManyWithoutUserNestedInput
    faculty?: facultyUpdateOneWithoutStudentsNestedInput
    user?: usersUpdateOneRequiredWithoutProfilesNestedInput
    learningProgress?: studentLearningProgressUpdateManyWithoutProfileNestedInput
  }

  export type profileUncheckedUpdateWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarURL?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: profileUpdateskillsInput | string[]
    interests?: profileUpdateinterestsInput | string[]
    department?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
    certificates?: certificatesUncheckedUpdateManyWithoutStudentNestedInput
    credits?: creditsUncheckedUpdateManyWithoutStudentNestedInput
    internshipApplications?: internship_applicationsUncheckedUpdateManyWithoutStudentNestedInput
    mentorReviews?: mentorReviewsUncheckedUpdateManyWithoutStudentNestedInput
    mentorSessions?: mentorSessionsUncheckedUpdateManyWithoutStudentNestedInput
    portfolioProjects?: portfolioProjectsUncheckedUpdateManyWithoutUserNestedInput
    learningProgress?: studentLearningProgressUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type profileUncheckedUpdateManyWithoutInstitutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarURL?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: profileUpdateskillsInput | string[]
    interests?: profileUpdateinterestsInput | string[]
    department?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    facultyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type certificatesCreateManyStudentInput = {
    id?: string
    title: string
    certificateUrl: string
    issuedAt: Date | string
  }

  export type creditsCreateManyStudentInput = {
    id?: string
    credits_earned: number
  }

  export type internship_applicationsCreateManyStudentInput = {
    id?: string
    internship_id: string
    status: $Enums.InternshipStatus
    submission_url?: string | null
    score?: number | null
    applied_at: Date | string
  }

  export type mentorReviewsCreateManyStudentInput = {
    id?: string
    mentorId: string
    rating: number
    reviews?: string | null
  }

  export type mentorSessionsCreateManyStudentInput = {
    id?: string
    mentorId: string
    scheduled_at: Date | string
    status: $Enums.MentorSessionStatus
    meeting_link?: string | null
  }

  export type portfolioProjectsCreateManyUserInput = {
    id?: string
    title: string
    description?: string | null
    github_url?: string | null
    live_url?: string | null
    tags?: portfolioProjectsCreatetagsInput | string[]
  }

  export type studentLearningProgressCreateManyProfileInput = {
    id?: string
    checkpointId: string
    isCompleted: boolean
    completedAt?: Date | string | null
  }

  export type certificatesUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    certificateUrl?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type certificatesUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    certificateUrl?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type certificatesUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    certificateUrl?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type creditsUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    credits_earned?: FloatFieldUpdateOperationsInput | number
  }

  export type creditsUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    credits_earned?: FloatFieldUpdateOperationsInput | number
  }

  export type creditsUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    credits_earned?: FloatFieldUpdateOperationsInput | number
  }

  export type internship_applicationsUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInternshipStatusFieldUpdateOperationsInput | $Enums.InternshipStatus
    submission_url?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    applied_at?: DateTimeFieldUpdateOperationsInput | Date | string
    internship?: internshipsUpdateOneRequiredWithoutApplicationsNestedInput
    evaluations?: internship_evaluationUpdateManyWithoutApplicationNestedInput
    logbookEntries?: logbook_entriesUpdateManyWithoutApplicationNestedInput
  }

  export type internship_applicationsUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    internship_id?: StringFieldUpdateOperationsInput | string
    status?: EnumInternshipStatusFieldUpdateOperationsInput | $Enums.InternshipStatus
    submission_url?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    applied_at?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: internship_evaluationUncheckedUpdateManyWithoutApplicationNestedInput
    logbookEntries?: logbook_entriesUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type internship_applicationsUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    internship_id?: StringFieldUpdateOperationsInput | string
    status?: EnumInternshipStatusFieldUpdateOperationsInput | $Enums.InternshipStatus
    submission_url?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    applied_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type mentorReviewsUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    reviews?: NullableStringFieldUpdateOperationsInput | string | null
    mentor?: mentorsUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type mentorReviewsUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    mentorId?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    reviews?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type mentorReviewsUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    mentorId?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    reviews?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type mentorSessionsUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduled_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMentorSessionStatusFieldUpdateOperationsInput | $Enums.MentorSessionStatus
    meeting_link?: NullableStringFieldUpdateOperationsInput | string | null
    mentor?: mentorsUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type mentorSessionsUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    mentorId?: StringFieldUpdateOperationsInput | string
    scheduled_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMentorSessionStatusFieldUpdateOperationsInput | $Enums.MentorSessionStatus
    meeting_link?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type mentorSessionsUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    mentorId?: StringFieldUpdateOperationsInput | string
    scheduled_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMentorSessionStatusFieldUpdateOperationsInput | $Enums.MentorSessionStatus
    meeting_link?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type portfolioProjectsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    github_url?: NullableStringFieldUpdateOperationsInput | string | null
    live_url?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: portfolioProjectsUpdatetagsInput | string[]
  }

  export type portfolioProjectsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    github_url?: NullableStringFieldUpdateOperationsInput | string | null
    live_url?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: portfolioProjectsUpdatetagsInput | string[]
  }

  export type portfolioProjectsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    github_url?: NullableStringFieldUpdateOperationsInput | string | null
    live_url?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: portfolioProjectsUpdatetagsInput | string[]
  }

  export type studentLearningProgressUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkpoint?: checkpointsUpdateOneRequiredWithoutProgressNestedInput
  }

  export type studentLearningProgressUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkpointId?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type studentLearningProgressUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    checkpointId?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type checkpointsCreateManyRoadmapInput = {
    id?: string
    title: string
    description: string
    resourceType: string
    resourceUrl: string
  }

  export type checkpointsUpdateWithoutRoadmapInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceUrl?: StringFieldUpdateOperationsInput | string
    progress?: studentLearningProgressUpdateManyWithoutCheckpointNestedInput
  }

  export type checkpointsUncheckedUpdateWithoutRoadmapInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceUrl?: StringFieldUpdateOperationsInput | string
    progress?: studentLearningProgressUncheckedUpdateManyWithoutCheckpointNestedInput
  }

  export type checkpointsUncheckedUpdateManyWithoutRoadmapInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    resourceType?: StringFieldUpdateOperationsInput | string
    resourceUrl?: StringFieldUpdateOperationsInput | string
  }

  export type studentLearningProgressCreateManyCheckpointInput = {
    id?: string
    profileId: string
    isCompleted: boolean
    completedAt?: Date | string | null
  }

  export type studentLearningProgressUpdateWithoutCheckpointInput = {
    id?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: profileUpdateOneRequiredWithoutLearningProgressNestedInput
  }

  export type studentLearningProgressUncheckedUpdateWithoutCheckpointInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type studentLearningProgressUncheckedUpdateManyWithoutCheckpointInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type courseEnrollmentsCreateManyCourseInput = {
    id?: string
    userId: string
    progressPercent?: number | null
    enrolledAt: Date | string
  }

  export type courseEnrollmentsUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    progressPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutCourseEnrollmentsNestedInput
  }

  export type courseEnrollmentsUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    progressPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type courseEnrollmentsUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    progressPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type mentorReviewsCreateManyMentorInput = {
    id?: string
    rating: number
    reviews?: string | null
    studentId: string
  }

  export type mentorSessionsCreateManyMentorInput = {
    id?: string
    studentId: string
    scheduled_at: Date | string
    status: $Enums.MentorSessionStatus
    meeting_link?: string | null
  }

  export type mentorReviewsUpdateWithoutMentorInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    reviews?: NullableStringFieldUpdateOperationsInput | string | null
    student?: profileUpdateOneRequiredWithoutMentorReviewsNestedInput
  }

  export type mentorReviewsUncheckedUpdateWithoutMentorInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    reviews?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: StringFieldUpdateOperationsInput | string
  }

  export type mentorReviewsUncheckedUpdateManyWithoutMentorInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    reviews?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: StringFieldUpdateOperationsInput | string
  }

  export type mentorSessionsUpdateWithoutMentorInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduled_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMentorSessionStatusFieldUpdateOperationsInput | $Enums.MentorSessionStatus
    meeting_link?: NullableStringFieldUpdateOperationsInput | string | null
    student?: profileUpdateOneRequiredWithoutMentorSessionsNestedInput
  }

  export type mentorSessionsUncheckedUpdateWithoutMentorInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    scheduled_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMentorSessionStatusFieldUpdateOperationsInput | $Enums.MentorSessionStatus
    meeting_link?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type mentorSessionsUncheckedUpdateManyWithoutMentorInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    scheduled_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMentorSessionStatusFieldUpdateOperationsInput | $Enums.MentorSessionStatus
    meeting_link?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type internship_applicationsCreateManyInternshipInput = {
    id?: string
    student_id: string
    status: $Enums.InternshipStatus
    submission_url?: string | null
    score?: number | null
    applied_at: Date | string
  }

  export type internship_applicationsUpdateWithoutInternshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInternshipStatusFieldUpdateOperationsInput | $Enums.InternshipStatus
    submission_url?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    applied_at?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: profileUpdateOneRequiredWithoutInternshipApplicationsNestedInput
    evaluations?: internship_evaluationUpdateManyWithoutApplicationNestedInput
    logbookEntries?: logbook_entriesUpdateManyWithoutApplicationNestedInput
  }

  export type internship_applicationsUncheckedUpdateWithoutInternshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    student_id?: StringFieldUpdateOperationsInput | string
    status?: EnumInternshipStatusFieldUpdateOperationsInput | $Enums.InternshipStatus
    submission_url?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    applied_at?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: internship_evaluationUncheckedUpdateManyWithoutApplicationNestedInput
    logbookEntries?: logbook_entriesUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type internship_applicationsUncheckedUpdateManyWithoutInternshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    student_id?: StringFieldUpdateOperationsInput | string
    status?: EnumInternshipStatusFieldUpdateOperationsInput | $Enums.InternshipStatus
    submission_url?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    applied_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type internship_evaluationCreateManyApplicationInput = {
    id?: string
    faculty_id: string
    rubric_json?: NullableJsonNullValueInput | InputJsonValue
    comments?: string | null
    final_score?: number | null
  }

  export type logbook_entriesCreateManyApplicationInput = {
    id?: string
    date: Date | string
    taskDone: string
    proofUrl?: string | null
    hours_spent: number
  }

  export type internship_evaluationUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rubric_json?: NullableJsonNullValueInput | InputJsonValue
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    final_score?: NullableFloatFieldUpdateOperationsInput | number | null
    faculty?: facultyUpdateOneRequiredWithoutEvaluationsNestedInput
  }

  export type internship_evaluationUncheckedUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    faculty_id?: StringFieldUpdateOperationsInput | string
    rubric_json?: NullableJsonNullValueInput | InputJsonValue
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    final_score?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type internship_evaluationUncheckedUpdateManyWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    faculty_id?: StringFieldUpdateOperationsInput | string
    rubric_json?: NullableJsonNullValueInput | InputJsonValue
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    final_score?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type logbook_entriesUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    taskDone?: StringFieldUpdateOperationsInput | string
    proofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    hours_spent?: IntFieldUpdateOperationsInput | number
  }

  export type logbook_entriesUncheckedUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    taskDone?: StringFieldUpdateOperationsInput | string
    proofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    hours_spent?: IntFieldUpdateOperationsInput | number
  }

  export type logbook_entriesUncheckedUpdateManyWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    taskDone?: StringFieldUpdateOperationsInput | string
    proofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    hours_spent?: IntFieldUpdateOperationsInput | number
  }

  export type internship_evaluationCreateManyFacultyInput = {
    id?: string
    application_id: string
    rubric_json?: NullableJsonNullValueInput | InputJsonValue
    comments?: string | null
    final_score?: number | null
  }

  export type profileCreateManyFacultyInput = {
    id?: string
    userId: string
    bio?: string | null
    gender?: string | null
    DOB?: Date | string | null
    avatarURL?: string | null
    github?: string | null
    linkedin?: string | null
    skills?: profileCreateskillsInput | string[]
    interests?: profileCreateinterestsInput | string[]
    department?: string | null
    resourceId?: string | null
    instituteId: string
  }

  export type internship_evaluationUpdateWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rubric_json?: NullableJsonNullValueInput | InputJsonValue
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    final_score?: NullableFloatFieldUpdateOperationsInput | number | null
    application?: internship_applicationsUpdateOneRequiredWithoutEvaluationsNestedInput
  }

  export type internship_evaluationUncheckedUpdateWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    application_id?: StringFieldUpdateOperationsInput | string
    rubric_json?: NullableJsonNullValueInput | InputJsonValue
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    final_score?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type internship_evaluationUncheckedUpdateManyWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    application_id?: StringFieldUpdateOperationsInput | string
    rubric_json?: NullableJsonNullValueInput | InputJsonValue
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    final_score?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type profileUpdateWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarURL?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: profileUpdateskillsInput | string[]
    interests?: profileUpdateinterestsInput | string[]
    department?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    certificates?: certificatesUpdateManyWithoutStudentNestedInput
    credits?: creditsUpdateManyWithoutStudentNestedInput
    internshipApplications?: internship_applicationsUpdateManyWithoutStudentNestedInput
    mentorReviews?: mentorReviewsUpdateManyWithoutStudentNestedInput
    mentorSessions?: mentorSessionsUpdateManyWithoutStudentNestedInput
    portfolioProjects?: portfolioProjectsUpdateManyWithoutUserNestedInput
    institution?: institutionsUpdateOneRequiredWithoutProfilesNestedInput
    user?: usersUpdateOneRequiredWithoutProfilesNestedInput
    learningProgress?: studentLearningProgressUpdateManyWithoutProfileNestedInput
  }

  export type profileUncheckedUpdateWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarURL?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: profileUpdateskillsInput | string[]
    interests?: profileUpdateinterestsInput | string[]
    department?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    instituteId?: StringFieldUpdateOperationsInput | string
    certificates?: certificatesUncheckedUpdateManyWithoutStudentNestedInput
    credits?: creditsUncheckedUpdateManyWithoutStudentNestedInput
    internshipApplications?: internship_applicationsUncheckedUpdateManyWithoutStudentNestedInput
    mentorReviews?: mentorReviewsUncheckedUpdateManyWithoutStudentNestedInput
    mentorSessions?: mentorSessionsUncheckedUpdateManyWithoutStudentNestedInput
    portfolioProjects?: portfolioProjectsUncheckedUpdateManyWithoutUserNestedInput
    learningProgress?: studentLearningProgressUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type profileUncheckedUpdateManyWithoutFacultyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarURL?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: profileUpdateskillsInput | string[]
    interests?: profileUpdateinterestsInput | string[]
    department?: NullableStringFieldUpdateOperationsInput | string | null
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    instituteId?: StringFieldUpdateOperationsInput | string
  }

  export type user_notificationsCreateManyNotificationInput = {
    id?: string
    user_id: string
    isRead: boolean
    read_at?: Date | string | null
  }

  export type user_notificationsUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: usersUpdateOneRequiredWithoutUser_notificationsNestedInput
  }

  export type user_notificationsUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_notificationsUncheckedUpdateManyWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UsersCountOutputTypeDefaultArgs instead
     */
    export type UsersCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsersCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InstitutionsCountOutputTypeDefaultArgs instead
     */
    export type InstitutionsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InstitutionsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfileCountOutputTypeDefaultArgs instead
     */
    export type ProfileCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfileCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoadmapsCountOutputTypeDefaultArgs instead
     */
    export type RoadmapsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoadmapsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CheckpointsCountOutputTypeDefaultArgs instead
     */
    export type CheckpointsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CheckpointsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CoursesCountOutputTypeDefaultArgs instead
     */
    export type CoursesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CoursesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MentorsCountOutputTypeDefaultArgs instead
     */
    export type MentorsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MentorsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InternshipsCountOutputTypeDefaultArgs instead
     */
    export type InternshipsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InternshipsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Internship_applicationsCountOutputTypeDefaultArgs instead
     */
    export type Internship_applicationsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Internship_applicationsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FacultyCountOutputTypeDefaultArgs instead
     */
    export type FacultyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FacultyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationsCountOutputTypeDefaultArgs instead
     */
    export type NotificationsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use usersDefaultArgs instead
     */
    export type usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = usersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use institutionsDefaultArgs instead
     */
    export type institutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = institutionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use profileDefaultArgs instead
     */
    export type profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = profileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use roadmapsDefaultArgs instead
     */
    export type roadmapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = roadmapsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use checkpointsDefaultArgs instead
     */
    export type checkpointsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = checkpointsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use studentLearningProgressDefaultArgs instead
     */
    export type studentLearningProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = studentLearningProgressDefaultArgs<ExtArgs>
    /**
     * @deprecated Use coursesDefaultArgs instead
     */
    export type coursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = coursesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use courseEnrollmentsDefaultArgs instead
     */
    export type courseEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = courseEnrollmentsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use mentorsDefaultArgs instead
     */
    export type mentorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = mentorsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use mentorSessionsDefaultArgs instead
     */
    export type mentorSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = mentorSessionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use mentorReviewsDefaultArgs instead
     */
    export type mentorReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = mentorReviewsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use portfolioProjectsDefaultArgs instead
     */
    export type portfolioProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = portfolioProjectsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use internshipsDefaultArgs instead
     */
    export type internshipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = internshipsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use internship_applicationsDefaultArgs instead
     */
    export type internship_applicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = internship_applicationsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use logbook_entriesDefaultArgs instead
     */
    export type logbook_entriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = logbook_entriesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use internship_evaluationDefaultArgs instead
     */
    export type internship_evaluationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = internship_evaluationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use facultyDefaultArgs instead
     */
    export type facultyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = facultyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use creditsDefaultArgs instead
     */
    export type creditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = creditsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use certificatesDefaultArgs instead
     */
    export type certificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = certificatesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use notificationsDefaultArgs instead
     */
    export type notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = notificationsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use user_notificationsDefaultArgs instead
     */
    export type user_notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = user_notificationsDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}